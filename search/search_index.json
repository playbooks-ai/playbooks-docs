{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#playbooks-ai-natural-language-programs-verifiable-control-multi-agent","title":"Playbooks AI \u2014 Natural Language Programs, Verifiable Control, Multi-Agent","text":"<p>Playbooks AI introduces a programming paradigm where you define AI agent behavior through clear, human-readable instructions, crafted in plain English inside markdown \u201cplaybooks\u201d that look like recipes, and are fully executable. Playbooks AI is a software stack for the Software 3.0 era that seamlessly combines traditional code (Software 1.0), data-trained models (Software 2.0) and behavior defined directly in plain English, executed by LLMs as if they were CPUs (Software 3.0).</p> <p>This isn't just prompting and hoping the LLM does the right thing - it\u2019s Natural Language Programming. Business users can read, tweak, and approve the specification directly; while developers benefit from consistency, auditability, and full visibility into execution paths.</p> <p>Natural Language Playbooks program (support.pb)</p> <p>Step debugging compiled program (support.pbasm)</p>"},{"location":"#how-it-works","title":"How It Works","text":"<ul> <li>Hybrid stack of English + Python: Seamlessly combine high-level natural-language steps with embedded Python logic (e.g., for system integration, data processing) and execute on a unified call stack.</li> <li>Event-driven triggers: Define reactive workflows using natural-language conditions (like \u201cwhen X happens, run Y playbook\u201d), radically simplifying the specification of complex workflows.</li> <li>Reliability + Flexibility: Every execution is trackable - variables, call stacks, decisions, runtime flow - ensuring compliance, reproducibility, and confidence in agent behavior. At the same time, using LLMs as CPUs means programs are executed intelligently with common sense and high-level instructions.</li> <li>Multi-agent: Build systems of collaborating agents with public playbooks and messaging, simply by asking agents to do things or getting agents to participate in multi-party meetings.</li> <li>Dynamic generation of playbooks: Let agents reason over context and objectives, then create new playbooks on the fly to tackle novel tasks. Thanks to the Playbooks runtime, execution of these dynamically generated playbooks is fully trackable and auditable.</li> <li>Observer agents: Specialized overseers that monitor other agents step-by-step, catching deviations before any action takes effect, and steering them back on course for injectable governance over multi-agent systems.</li> </ul>"},{"location":"#why-it-matters","title":"Why It Matters","text":"Participant Benefit Business Users Can author and refine playbooks in natural language. Transparency and control sit at the specification level. Developers &amp; Engineers Gain a reliable runtime instead of black box LLM prompt execution, with observability, testability, triggers, multi-agent coordination, and audit-ready outputs. Governance &amp; Compliance Teams Source is English-readable, version-controlled, and verifiable\u2014ideal for reviews, sign-offs, and traceability. Product Strategy Empowers rapid iteration - tune behaviors by editing <code>.pb</code> files, experiment safely, reuse logic, and scale confidently. <p>Under the hood, Playbooks provides a Common Language Specification (CLS) and a Common Language Runtime (CLR) - the \u201cLLMOS\u201d that validates and supervises program execution.</p> <p>     Get started:      <code>pip install playbooks</code> </p> <p> Quickstart Tutorials Guides Language </p>"},{"location":"#quick-example","title":"Quick example","text":"<pre><code># Customer support agent\nA demo customer support agent for Playbooks AI\n\n## Greet the user\nIn this playbook, the customer support agent welcomes the user\n### Triggers\n- At the beginning\n### Steps\n- Tell user about yourself\n- Ask the user for their name\n- Say hello to the user by name\n- Welcome user to Playbooks AI and say goodbye\n- End program\n</code></pre>"},{"location":"#run-it","title":"Run it","text":"<p>Save the example as <code>support.pb</code>, then run:</p> <pre><code>pip install playbooks\nplaybooks run support.pb\n</code></pre>"},{"location":"#pick-your-path","title":"Pick your path","text":"<p>Choose your starting point - each tile is a direct jump into docs with just enough context to know it\u2019s right for you.</p> <ul> <li> <p> Explore Playbooks Language   Write and refine agent behavior in plain English that anyone can understand and update. Get started \u2192</p> </li> <li> <p> Build with Python   Add integrations, custom logic, or optimized computation\u2014bridge English specs with code. Learn how \u2192</p> </li> <li> <p> Design Multi-Agent Systems   Create agents that collaborate, share context, and run public or exported playbooks. See patterns \u2192</p> </li> <li> <p> Automate with Triggers   Run playbooks automatically on schedules, events, or user actions. Set up triggers \u2192</p> </li> <li> <p> Gain Full Observability   Inspect every step, replay runs, debug deterministically, and keep audit-ready logs. View tools \u2192</p> </li> <li> <p> Control Autonomy &amp; Safety   Set guardrails, approvals, and per-step autonomy to keep agents aligned with intent. Configure controls \u2192</p> </li> </ul>"},{"location":"faqs/","title":"Frequently Asked Questions","text":""},{"location":"faqs/#what-python-and-os-are-supported","title":"What Python and OS are supported?","text":"<ul> <li>Python 3.12+</li> <li>macOS, Linux, Windows (WSL recommended on Windows)</li> </ul>"},{"location":"faqs/#which-models-are-supported","title":"Which models are supported?","text":"<ul> <li>Optimized/tested: <code>claude-sonnet-4-20250514</code></li> <li>Others may work: set <code>MODEL</code> and the provider key (<code>OPENAI_API_KEY</code>, <code>GEMINI_API_KEY</code>, <code>GROQ_API_KEY</code>, <code>OPENROUTER_API_KEY</code>)</li> </ul>"},{"location":"faqs/#how-do-i-set-api-keys","title":"How do I set API keys?","text":"<ul> <li>Create a <code>.env</code> with <code>MODEL</code> and the matching provider key. The loader reads <code>.env</code> and <code>.env.&lt;ENV&gt;</code> automatically.</li> </ul>"},{"location":"faqs/#how-do-i-run-a-program","title":"How do I run a program?","text":"<pre><code>playbooks run path/to/program.pb -v\n</code></pre> <p>You can pass multiple files and mix compiled + source:</p> <pre><code>playbooks run a.pbasm b.pb\n</code></pre>"},{"location":"faqs/#what-is-pbasm-how-do-i-compile","title":"What is <code>.pbasm</code>? How do I compile?","text":"<ul> <li>PBASM is the intermediate representation. Compile with:</li> </ul> <pre><code>playbooks compile program.pb --output program.pbasm\n</code></pre> <p>Run compiled files directly:</p> <pre><code>playbooks run program.pbasm --skip-compilation\n</code></pre>"},{"location":"faqs/#where-is-the-compilation-cache","title":"Where is the compilation cache?","text":"<ul> <li>Next to the source file in <code>.pbasm_cache/</code> with versioned filenames. Delete the folder to force recompilation.</li> </ul>"},{"location":"faqs/#can-i-use-different-models-for-compilation-and-execution","title":"Can I use different models for compilation and execution?","text":"<ul> <li>Set <code>COMPILER_MODEL</code> to override the compile-time model (falls back to <code>MODEL</code>).</li> </ul>"},{"location":"faqs/#how-do-i-debug","title":"How do I debug?","text":"<p>Use the <code>playbooks</code> VSCode extension to step-debug. See VSCode for setup.</p>"},{"location":"faqs/#is-there-a-web-ui","title":"Is there a web UI?","text":"<ul> <li>Yes. Start the Web Server and open the HTML Playground. See Web Server and HTML Playground.</li> </ul>"},{"location":"faqs/#how-do-i-use-examples","title":"How do I use examples?","text":"<ul> <li>Run any program in <code>tests/data</code>:</li> </ul> <pre><code>playbooks run tests/data/01-hello-playbooks.pb\n</code></pre>"},{"location":"faqs/#how-do-i-enable-langfuse-tracing","title":"How do I enable Langfuse tracing?","text":"<ul> <li>Set <code>LANGFUSE_SECRET_KEY</code>, <code>LANGFUSE_PUBLIC_KEY</code>, and <code>LANGFUSE_HOST</code>. See Langfuse integration.</li> </ul>"},{"location":"faqs/#vscode-language-support","title":"VSCode language support?","text":"<ul> <li>Install the <code>playbooks</code> extension for syntax highlighting, preview, diagnostics, and debugging.</li> </ul>"},{"location":"faqs/#where-to-report-issues-or-get-help","title":"Where to report issues or get help?","text":"<ul> <li>Open an issue on GitHub (<code>playbooks-ai/playbooks</code>).</li> </ul>"},{"location":"faqs/#troubleshooting","title":"Troubleshooting","text":"<ul> <li> <p>Model errors or unexpected behavior</p> <ul> <li>Set <code>MODEL=claude-sonnet-4-20250514</code> to use the default tested model</li> <li>For other providers, set matching API key and model name</li> </ul> </li> <li> <p><code>ImportError: No module named playbooks</code></p> <ul> <li>Activate your virtualenv and reinstall: <code>pip install playbooks</code></li> <li>Ensure you\u2019re launching VSCode/terminal from the same environment</li> </ul> </li> <li> <p>Program not found / glob returns nothing</p> <ul> <li>Check paths and quotes. Try absolute paths or expand globs: <code>playbooks run \"tests/data/*.pb\"</code></li> </ul> </li> <li> <p>Stale compilation results</p> <ul> <li>Delete <code>.pbasm_cache</code> next to your <code>.pb</code> files to force recompilation</li> <li>Optionally precompile with <code>playbooks compile foo.pb --output foo.pbasm</code> and run the <code>.pbasm</code></li> </ul> </li> <li> <p>VSCode language features not active</p> <ul> <li>Install the <code>playbooks</code> extension and reopen a <code>.pb</code> file</li> <li>Ensure the workspace uses the correct Python interpreter</li> </ul> </li> </ul>"},{"location":"faqs/#where-can-i-learn-more-concepts","title":"Where can I learn more concepts?","text":"<ul> <li>Playbook Types</li> <li>Playbooks Language</li> </ul>"},{"location":"glossary/","title":"Glossary","text":"<ul> <li>Agent: A runtime entity that owns playbooks and state.</li> <li>Playbook: A procedure defined in markdown or Python; can be public or exported.</li> <li>PBAsm: Playbooks Assembly Language, the compiled intermediate representation.</li> <li>CLS: Common Language Specification for Playbooks programs.</li> <li>CLR: Common Language Runtime that executes and verifies programs.</li> <li>Trigger: A condition that causes a playbook to run.</li> <li>Public playbook: A playbook callable by other agents.</li> <li>Exported playbook: A playbook implementation importable into another agent\u2019s context.</li> <li>ReAct playbook: A playbook without steps that uses a think\u2013act loop.</li> <li>MCP: Model Context Protocol for tool access.</li> </ul>"},{"location":"glossary/#see-also","title":"See also","text":"<ul> <li>Playbooks Language</li> <li>Playbook Types</li> </ul>"},{"location":"advanced/","title":"Advanced Concepts and Roadmap","text":"<p>Playbooks is under active development. We are developing it in full view of the community and welcome community contributions and feedback.</p> <p>Here are some of the advanced concepts we are exploring:</p> <ul> <li>Automating Context Engineering</li> <li>Playbooks as the Common Language Specification (CLS) and Common Language Runtime (CLR) for AI Applications</li> <li>Playbooks Protocol</li> <li>Observer Agents</li> <li>Dynamic Playbook Generation</li> </ul>"},{"location":"advanced/automating-context-engineering/","title":"Automating the Art of Context Engineering with Stack-Based Context Management","text":"<p>Context Engineering is fast becoming one of the most important disciplines in building effective AI agents. In its simplest form, it\u2019s about deciding what to feed a Large Language Model (LLM) for each generation and how to arrange it so the model performs at its best with minimal token usage. In practice, it has become a nuanced craft: choosing relevant facts, ordering them, summarizing past interactions, compacting verbose histories, and stitching together system and user instructions - all while staying within tight context limits.</p> <p>In most frameworks today, context engineering is hand-rolled. Developers write intricate, case-specific logic to decide what to include in each prompt, how to place it, when to summarize, and how to balance detail with brevity. Every complex agent ends up with its own bespoke, fragile context pipeline.</p> <p>Playbooks takes a different approach: automated, stack-based context management built into the runtime. This makes advanced context engineering available to every agent, without custom code, and evolves with the platform - so all agents benefit as the capabilities grow.</p>"},{"location":"advanced/automating-context-engineering/#how-playbooks-automates-context-engineering","title":"How Playbooks Automates Context Engineering","text":"<p>Playbooks\u2019 runtime constructs each LLM call\u2019s prompt with an optimized blend of recency, relevance, and compactness - while preserving a rich execution trace.</p> <p>At the core is stack-based context:</p> <ul> <li>Each LLM call typically executes just a few lines of a playbook.</li> <li>The prompt includes the execution trace from the start of the current playbook and, recursively, from the start of each playbook on the call stack.</li> <li>This stack-shaped history is a structured narrative of everything that has happened since the agent began execution.</li> </ul> <p>When a playbook returns, the runtime auto-compacts the context by replacing its detailed trace with an auto-generated summary of what happened during that playbook\u2019s execution. The caller playbook then continues with a concise record of the result, freeing context space while preserving semantic continuity.</p> <p>This stack-based unwinding of context - with automatic summarization on return - is a capability unique to Playbooks. Other frameworks often use flat rolling buffers or ad-hoc summarizers, losing the hierarchical execution structure and forcing manual summarization strategies.</p>"},{"location":"advanced/automating-context-engineering/#additional-built-in-context-engineering-features","title":"Additional Built-In Context Engineering Features","text":"<p>Playbooks\u2019 context system goes beyond execution traces. The runtime automatically enriches the prompt with:</p> <ul> <li>Optimal use of cached prefixes to avoid repeated token overhead.</li> <li>Automatic representation of agent state - variables, artifacts, and other runtime data.</li> <li>Discovery metadata - a current listing of all agents in the system and their public playbooks.</li> <li>Self-description - the current agent\u2019s own playbooks and triggers.</li> <li>Dynamic resource inclusion - a playbook can pull in needed data (e.g., via <code>LoadFile()</code> in a description placeholder) only for its own execution. Once the playbook finishes, the resource is automatically dropped from context.</li> </ul> <p>This makes it trivial to give an agent just the right information at just the right time - and to clean it up immediately after, keeping context lean and relevant.</p>"},{"location":"advanced/automating-context-engineering/#full-control-when-needed","title":"Full Control When Needed","text":"<p>While the default stack-based context management handles the majority of cases, some scenarios require total control over the prompt. For those, Playbooks offers Raw Prompt Playbooks. In a raw prompt playbook, the runtime adds no automatic context at all, leaving the developer free to craft every detail of what the LLM sees. This provides a clean escape hatch for specialized tasks without sacrificing the benefits of the default system for everything else.</p>"},{"location":"advanced/automating-context-engineering/#why-this-matters","title":"Why This Matters","text":"<p>Advanced context engineering has historically been a barrier to scaling agent complexity - it required deep expertise and constant maintenance. Playbooks\u2019 approach turns it into infrastructure:</p> <ul> <li>Complex agents can be built without bespoke prompt pipelines.</li> <li>Context is always optimized for both effectiveness (enough relevant detail) and efficiency (minimal unnecessary tokens).</li> <li>Agents naturally benefit from future improvements to the context system without rewriting code.</li> </ul> <p>By combining stack-based execution traces, automatic compaction, dynamic resource management, and built-in system intelligence, Playbooks delivers context engineering as a platform capability - not a per-agent chore.</p>"},{"location":"advanced/automating-context-engineering/#see-also","title":"See also","text":"<ul> <li>Raw Prompt Playbooks</li> <li>ReAct Playbooks</li> <li>Markdown Playbooks \u2014 Description placeholders</li> <li>Common Language Runtime (CLR)</li> </ul>"},{"location":"advanced/cls/","title":"Playbooks as the Common Language Specification (CLS) and Common Language Runtime (CLR) for AI Applications","text":"<p>In the early days of .NET, the Common Language Specification (CLS) and Common Language Runtime (CLR) solved a major problem: how to unify disparate programming languages and runtimes under a single, verifiable execution model. Today\u2019s LLM agent ecosystem faces an almost identical challenge.</p> <p>The AI landscape is fragmented.</p> <ul> <li>LangGraph and similar orchestration frameworks define execution as directed graphs.</li> <li>Low/no-code tools like n8n capture logic as workflows.</li> <li>Proprietary agent SDKs embed logic in bespoke formats.</li> </ul> <p>All of these are isolated islands of execution. They don\u2019t share a common intermediate representation, nor a runtime that enforces correctness, observability, and safe autonomy.</p>"},{"location":"advanced/cls/#playbooks-the-cls-for-llm-applications","title":"Playbooks: The CLS for LLM Applications","text":"<p>Playbooks Common Language Specification (CLS) is a universal, human-readable, semantically precise specification for AI applications, such as AI agents and workflow automation applications. It captures the core primitives that any LLM-executed program can have - steps, triggers, variables, calls, control flow - independent of authoring tool or UI.</p> <p>Any LLM-powered application authored in as a LangGraph DAG, an n8n workflow, or a custom orchestration tool can be exported into CLS. Once in that format, it becomes interoperable, auditable, portable and verifiable. Instead of complex orchestration of LLM prompts, CLS is a disciplined specification layer that keeps natural language clarity while enforcing structure, type safety, and semantic constraints.</p>"},{"location":"advanced/cls/#the-playbooks-runtime-clr-for-the-llm-era","title":"The Playbooks Runtime: CLR for the LLM Era","text":"<p>A specification is only half the story. The Playbooks Runtime is the equivalent of the .NET Common Language Runtime (CLR), but for LLM-executed applications.</p> <p>Playbooks as the CLR is a high-performance, transparent execution environment that compiles CLS into Playbooks Assembly Language (PBAsm), an instruction set optimized for LLMs. Programs running on this runtime benefit from first-class observability \u2014 every step, every variable update, every decision path can be inspected, replayed, and explained. Developers can attach the VSCode debugger, set breakpoints, step through live execution, and watch the call stack evolve in real time. Governance teams can insert observer agents and guardrails, ensuring that no unsafe action slips through. And because the runtime enforces the CLS semantics, an agent exported from one framework will behave exactly as specified when run under Playbooks.</p>"},{"location":"advanced/cls/#why-this-matters","title":"Why This Matters","text":"<p>In a fragmented ecosystem, there are attempts to standardize the specification, execution and communication between agents and systems, with notable efforts such as the Model Context Protocol (MCP) and the Agent2Agent (A2A) protocol. We believe that Playbooks CLS and CLR is a more principled way of addressing this fragmentation and can inform the development of a industry standard and a more coherent LLM OS stack.</p> <p>Having such a standard also spurs the development of LLMs that excel at being semantic CPUs, such as the PlaybooksLM model family being developed by the Playbooks AI team. Such models can deliver the same level of safety, reliability and verifiability as traditional software, while being able to execute complex workflows and reasoning tasks.</p> <p>See also:</p> <ul> <li>Playbooks Assembly Language</li> </ul>"},{"location":"advanced/cls/#see-also","title":"See also","text":"<ul> <li>Common Language Runtime (CLR)</li> <li>Playbooks Languages</li> </ul>"},{"location":"advanced/dynamic-playbook-generation/","title":"Dynamic Playbook Generation","text":"<p>Dynamic Playbook Generation is an advanced capability in Playbooks AI that allows an agent to autonomously create, compile and execute new playbooks at runtime, based on deep reasoning and strategic planning. This enables highly adaptive behaviors suited to complex, evolving and long running tasks \u2014 without sacrificing reliability or control.</p> <p>Unlike the transient, proprietary \u201cto-do\u201d lists common in current agent frameworks, dynamically generated playbooks in Playbooks AI are structured, executable programs. They capture the dynamically generated plans with Turing-complete Playbooks, rather than lists, thus making use of branching, loop, nested calls, trigger-driven workflows, and so on, and then execute them faithfully under the Playbooks runtime.</p>"},{"location":"advanced/dynamic-playbook-generation/#how-it-works","title":"How It Works","text":"<p>The process begins when an agent, evaluates its current context and objectives. It reasons about available actions, explores available and missing playbooks, and designs an optimal sequence of steps. Once the plan is ready, the agent invokes a built-in playbook that takes in the plan and generates a new playbook in the Playbooks Language. The generated playbook is compiled into Playbooks Assembly (PBAsm) for immediate execution.</p> <p>Because Playbooks supports invoking other playbooks, a single dynamic step like \u201cWrite comprehensive tests\u201d can seamlessly call the appropriate testing playbook or delegate to another specialized agent. This allows high-level plans to drill down into deeply reliable, reusable procedures, ensuring consistent behavior and richer execution than any free-form to-do list can offer.</p> <p>Dynamically generated playbooks can be stored for future reuse, which leads to a growing library of ready procedures and workflows that can be referenced. This is a key differentiator from other agent frameworks, which typically use and discard transient to-do lists.</p> <p>Dynamic playbook generation can also be used to create personalized playbooks for each user, enabling the agent to hyper-personalize its behavior for each user over time, embedding the user's preferences and context into playbooks. This is a key to unlocking online learning in complex agentic systems.</p>"},{"location":"advanced/dynamic-playbook-generation/#execution-fidelity-and-long-horizon-coherence","title":"Execution Fidelity and Long-Horizon Coherence","text":"<p>Once generated, a dynamic playbook is executed exactly as specified, with the runtime maintaining stack-based automated context management. This includes compaction, consolidation, caching, and unwinding of execution state, enabling long-horizon agents to remain coherent over extended periods. Whether the task takes minutes or days, the agent\u2019s plan and execution context remain intact, allowing it to pick up exactly where it left off without drifting from the original intent.</p> <p>If an unexpected situation arises from a dynamically generated playbook \u2014 for example, an API call fails or a prerequisite is missing \u2014 the runtime can flag the deviation and trigger regeneration of an updated playbook, either for the affected segment or for the plan as a whole. This ensures the agent adapts to change without losing structure or oversight.</p>"},{"location":"advanced/dynamic-playbook-generation/#why-this-matters","title":"Why This Matters","text":"<p>Dynamic Playbook Generation turns ephemeral agent plans into durable, interoperable assets. Because each plan is a Playbook, it inherits the benefits of the Playbooks ecosystem: human readability, version control, auditability, and full compatibility with other agents via the Playbooks Protocol. Generated playbooks can be stored for future reuse, shared as public playbooks, or exported so that other agents can import them as new skills.</p> <p>This approach not only improves reliability in the short term but also accelerates the accumulation of proven strategies and workflows over time, creating a growing library of executable knowledge.</p>"},{"location":"advanced/dynamic-playbook-generation/#example-use-cases","title":"Example Use Cases","text":"<p>An adaptive coding agent can generate a plan for implementing a feature, with steps that call existing testing and deployment playbooks. A customer support agent can dynamically craft a troubleshooting workflow, embedding calls to specialized escalation or knowledge-retrieval playbooks. A scientific research agent can design an experiment protocol with embedded data-analysis playbooks, ready to execute as soon as results arrive.</p> <p>In each case, the generated plan is both adaptive and grounded \u2014 adaptive because it\u2019s created in real time for the specific context, grounded because it executes within the Playbooks runtime, with complete observability, context management, and the ability to call specialized sub-playbooks for consistent, deep behavior.</p>"},{"location":"advanced/dynamic-playbook-generation/#roadmap","title":"Roadmap","text":"<p>Our roadmap for Dynamic Playbook Generation includes:</p> <ul> <li>A formal API for \u201cplan \u2192 generate \u2192 compile \u2192 execute\u201d cycles within Playbooks.</li> <li>Built-in deviation handling that triggers regeneration on failure or observer-detected drift.</li> <li>Tight integration with observer agents for pre-execution review of generated plans.</li> <li>Persistent storage and retrieval for dynamically generated playbooks, enabling reuse across sessions and agents.</li> </ul> <p>By replacing ad-hoc, prompt-driven to-do lists with structured, callable, verifiable playbooks, Playbooks AI makes dynamic planning a first-class, production-ready capability for the next generation of AI agents.</p>"},{"location":"advanced/dynamic-playbook-generation/#see-also","title":"See also","text":"<ul> <li>Automating Context Engineering</li> <li>Multi-Agent Programming</li> <li>Call Playbooks</li> </ul>"},{"location":"advanced/observer-agents/","title":"Observer Agents: The Missing Piece for Reliable, Accountable AI Systems","text":"<p>In the rush to build autonomous AI agents, much of the industry\u2019s focus has been on capability: getting models to do more, faster. What has lagged behind is control \u2014 the ability to watch, guide, and correct these agents in real time. That is where observer agents come in.</p> <p>An observer agent monitors another agent\u2019s execution, step by step. It verifies that each action is correct before any side effects occur, and it keeps the bigger picture in mind, ensuring that the agent\u2019s work aligns with longer-term goals. If something is wrong \u2014 whether it\u2019s a factual error, a policy violation, or a deviation from plan \u2014 the observer steps in, corrects the course, and execution continues safely.</p> <p>The research is clear: process supervision improves correctness and alignment; critic models can catch subtle errors humans miss; runtime \u201cshields\u201d can block unsafe actions before they happen. The need for live oversight is not theoretical \u2014 it is the difference between trust and risk in production AI systems.</p>"},{"location":"advanced/observer-agents/#why-playbooks-is-a-natural-fit","title":"Why Playbooks Is a Natural Fit","text":"<p>Playbooks AI already has many of the primitives needed for effective observer agents:</p> <ul> <li>Step-level gating before side effects \u2014 The Playbooks runtime cleanly separates LLM token generation from effectful execution, making it trivial to insert an observer between \u201cintent\u201d and \u201cimpact.\u201d</li> <li>Structured, interpretable programs \u2014 Observers themselves can be written as playbooks, giving them the same transparency, version control, and auditability as the agents they supervise.</li> <li>Specialized low-latency models \u2014 Observer behavior playbooks can be executed with ultra-fast LLMs that approve correct steps instantly and intervene only when necessary, minimizing cost and delay.</li> <li>Portable, composable policies \u2014 With public and exported playbooks, observer playbooks and agents can be shared across agents \u2014 a compliance team could publish a \u201cprivacy observer\u201d that any trusted agent can use.</li> <li>Protocol readiness \u2014 Through the proposed Playbooks Protocol, an observer could monitor remote agents, subscribing to their proposed actions and issuing approvals or corrections in real time.</li> </ul> <p>This is not a bolt-on idea for Playbooks \u2014 it is an organic extension of the design philosophy: keep the specification human-readable, the execution verifiable, and the control points programmable.</p>"},{"location":"advanced/observer-agents/#the-plan","title":"The Plan","text":"<p>We intend to formalize observer agents in Playbooks by publishing a specification for observer hooks in PBAsm. These hooks will let an observer:</p> <ol> <li>Inspect the next proposed step from an agent before execution.</li> <li>Approve, patch, or reject the step, with an optional rationale.</li> <li>Optionally run longer-horizon evaluations on plan adherence, resource use, or strategic objectives.</li> </ol> <p>Our initial release will ship with reference observers for common needs \u2014 schema validation, policy enforcement, plan alignment \u2014 and a mechanism for packaging these as exported observer playbooks that anyone can bring into their own agents. Over time, we expect a marketplace of observer \u201cpolicy packs\u201d to emerge, from domain-specific QA to brand safety modules.</p>"},{"location":"advanced/observer-agents/#looking-ahead","title":"Looking ahead","text":"<p>This is where we see the space heading:</p> <ul> <li>From ad-hoc guardrails to portable observers \u2014 Organizations will want to take their governance logic with them, not rebuild it in each agent framework.</li> <li>Specialized critic models at the edge \u2014 Ultra-light evaluators will run in real time, escalating to larger models only when confidence drops.</li> <li>Hybrid oversight loops \u2014 Combining deterministic checks, rubric-driven LLM critics, and human escalation for high-impact actions.</li> <li>Observer collaboration \u2014 Just as agents can work together, observers will coordinate too \u2014 cross-verifying each other\u2019s judgments, aggregating signals, and preventing bias or collusion, with the logic for collaboration being defined as meeting playbooks.</li> <li>Standardization of oversight APIs \u2014 Much like MCP and A2A are standardizing agent communication, observer protocols will standardize how any compliant runtime can expose checkpoints for inspection and control. This</li> </ul> <p>If autonomous AI is to scale safely, it needs more than raw intelligence \u2014 it needs a nervous system for oversight. Playbooks, with its separation of intent from action, structured and shareable logic, and forthcoming observer hooks, is in a unique position to deliver that nervous system.</p> <p>We believe the next generation of AI systems will be judged not just by what they can do, but by how well they can prove they did it right. Observer agents make that possible.</p>"},{"location":"advanced/observer-agents/#see-also","title":"See also","text":"<ul> <li>Observability &amp; Debugging</li> <li>Playbooks Protocol</li> <li>Exported and Public Playbooks</li> </ul>"},{"location":"advanced/playbooks-protocol/","title":"Playbooks Protocol \u2014 A Proposed Standard for Agent Interoperability and Skill Sharing","text":"<p>The Playbooks project is pursuing three complementary standards for AI agents:</p> <ul> <li>Common Language Specification (CLS) \u2014 a universal, human-readable, semantically precise format for defining agent behavior.</li> <li>Common Language Runtime (CLR) \u2014 a verifiable, transparent execution environment for running CLS programs with consistency and safety.</li> <li>Playbooks Protocol (in exploration) \u2014 a communication and capability-sharing standard that enables agents to call each other\u2019s functions, import skills, and collaborate securely across systems.</li> </ul> <p>The CLS and CLR define how agents are built and run. The Playbooks Protocol would define how they connect and share capabilities, forming the network layer of a unified AI agent stack.</p>"},{"location":"advanced/playbooks-protocol/#purpose-and-context","title":"Purpose and Context","text":"<p>We are not building in isolation. Protocols like the Model Context Protocol (MCP) and Agent-to-Agent (A2A) are emerging standards for agent interoperability. Playbooks will support these where they fit, but we also see an opportunity for a native protocol optimized specifically for playbook sharing and execution \u2014 one that fully leverages the semantics, safety guarantees, and modularity of the Playbooks environment.</p> <p>Our goal is a protocol that can make multi-agent systems more capable, flexible, and secure \u2014 without locking into brittle, ad-hoc integrations or over-indexing on any one coordination pattern.</p>"},{"location":"advanced/playbooks-protocol/#from-tools-to-public-playbooks","title":"From Tools to Public Playbooks","text":"<p>In API design, capabilities are traditionally exposed as endpoints. MCP\u2019s concept of listing tools fits this model \u2014 they are simply public API endpoints, discoverable and documented via existing standards like OpenAPI or Swagger. Playbooks will support these conventions so that agents publishing capabilities via MCP remain accessible in the wider ecosystem.</p> <p>But object-oriented programming offers another useful analogy: public methods. In Playbooks, public playbooks are exactly that \u2014 specific workflows or functions that an agent intentionally exposes for others to call. Public playbooks can be invoked remotely, with typed parameters and structured return values, just like calling a local method.</p>"},{"location":"advanced/playbooks-protocol/#beyond-prompts-exported-playbooks","title":"Beyond Prompts \u2014 Exported Playbooks","text":"<p>In MCP, prompts are reusable templates for common operations. They\u2019re valuable, but limited: they don\u2019t carry execution semantics, runtime safety, or multi-step control flow. Playbooks are richer \u2014 fully defined, auditable workflows that can be executed deterministically.</p> <p>The Playbooks Protocol extends this further with exported playbooks: the actual code for a playbook, packaged for import into another agent\u2019s environment. An agent can \u201cimport\u201d an exported playbook from a trusted source and run it as if it were a local method. This allows agents to acquire entirely new skills \u2014 dynamically extending their capabilities without duplicating logic or reinventing proven workflows.</p>"},{"location":"advanced/playbooks-protocol/#agent-to-agent-collaboration","title":"Agent-to-Agent Collaboration","text":"<p>The Playbooks Protocol is designed to support multiple modes of collaboration between agents. Agents can:</p> <ul> <li>Call public playbooks on other agents directly, using RPC-style semantics with typed parameters and structured return values.</li> <li>Exchange natural language messages with other agents, conveying the semantic intent. The receiving agent can choose to execute a playbook to process the message and may respond with a natural language message. This enables multi-turn conversations for collaboration, negotiation and decision making.</li> <li>Multi-party meetings \u2014 For multi-party synchronous collaboration, Playbooks runtime offers a mechanisms for conducting \"meetings\". Each participant can follow their own playbook as the behavior guide for the meeting.</li> </ul>"},{"location":"advanced/playbooks-protocol/#why-standardize","title":"Why Standardize","text":"<p>Without a shared protocol, agents remain silos \u2014 each with its own format for capabilities, its own invocation semantics, its own security assumptions. The Playbooks Protocol aims to solve this by:</p> <ul> <li>Defining a portable, structured way to expose and discover capabilities.</li> <li>Providing a safe, verifiable mechanism for executing remote capabilities and imported skills.</li> <li>Enabling composability so agents can be assembled into richer systems without custom glue for each integration.</li> </ul> <p>When combined with CLS and CLR, the Playbooks Protocol could be a key part of an open, interoperable AI stack:</p> <ul> <li>CLS \u2014 defines the shape and semantics of agent logic.</li> <li>CLR \u2014 ensures any CLS-defined program runs predictably and safely.</li> <li>Playbooks Protocol \u2014 connects agents into a skill-sharing, capability-rich ecosystem.</li> </ul> <p>This is like the network layer for the AI agent era \u2014 one that makes interoperability, discoverability, and trust first-class features rather than afterthoughts.</p>"},{"location":"advanced/playbooks-protocol/#see-also","title":"See also","text":"<ul> <li>Exported and Public Playbooks</li> <li>MCP Agents</li> <li>Agents</li> </ul>"},{"location":"agents/","title":"Agents","text":"<p>Agents are first-class runtime entities in Playbooks. They can:</p> <ul> <li>Run their own playbooks</li> <li>Send messages to other agents</li> <li>Call other agents\u2019 public playbooks directly</li> </ul> <p>In multi-agent programs, use natural language to specify messaging, meetings, and public playbook calls. See the Multi-Agent Systems section for practical patterns.</p>"},{"location":"agents/#playbooks-ai-agents","title":"Playbooks AI Agents","text":""},{"location":"agents/#create-an-agent","title":"Create an agent","text":"<p>It is easy to create an AI agent using Playbooks.</p> <pre><code># Hello World Agent\nThis is a simple agent that says hello world.\n\n## Main\n\n### Trigger\n- When program starts\n\n### Steps\n- Say Hello World!\n- End program\n</code></pre> <p>This creates a Hello World agent.</p>"},{"location":"agents/#create-multiple-agents","title":"Create multiple agents","text":"<p>A program is a collection of agents. Agents that are part of a program can natively call each other's public playbooks.</p> <pre><code># Agent 1\n## PB1\npublic: true\n### Steps\n- Say Hello\n\n# Agent 2\n## PB2\n### Trigger\n- When program starts\n### Steps\n- call Agent 1's PB1\n- end program\n</code></pre>"},{"location":"agents/#create-an-agent-backed-by-an-mcp-server","title":"Create an agent backed by an MCP server","text":"<p>It is easy to create an agent that exposes tools from an MCP server as playbooks.</p> <p>Say we have an MCP server running at <code>http://localhost:8088/mcp</code> that exposes a <code>get_weather(zipcode: int) -&gt; dict</code> tool that takes a zipcode and returns a weather report.</p> <pre><code># MCP Agent\nremote:\n  type: mcp\n  transport: streamable-http\n  url: http://localhost:8088/mcp\n\n# Local Agent\n## Main\n### Trigger\n- When program starts\n### Steps\n- ask the user for a zipcode\n- get the weather for that zipcode from MCP Agent\n- describe the weather to the user\n- end program\n</code></pre>"},{"location":"agents/#next-steps","title":"Next Steps","text":"<ul> <li>See more details about MCP Agents</li> <li>Refer to tutorials for other topics</li> <li>Learn about Exported and Public Playbooks</li> </ul>"},{"location":"agents/exported-and-public-playbooks/","title":"Exported and Public Playbooks","text":""},{"location":"agents/exported-and-public-playbooks/#exported-playbooks","title":"Exported Playbooks","text":"<p>Exported playbooks are a powerful feature of Playbooks AI that allows an agent to execute playbooks defined by another agent within its own execution context as if they were implemented locally within the importing agent.</p> <p> Playbooks AI's exported playbooks capability is significantly more powerful than MCP's prompts because it enables true capability sharing and execution between agents, not just structured guidance. While MCP prompts are valuable for standardizing LLM interactions, Playbooks AI enables building extensible agent ecosystems with genuine code reuse and modular architectures.</p>"},{"location":"agents/exported-and-public-playbooks/#public-playbooks","title":"Public Playbooks","text":"<p>When an agent marks a playbook as public, another agent can call that playbook remotely.</p> <p> Public playbooks are similar to MCP's tools. When a client calls a tool, it is executed on the MCP server. Similarly, when an agent calls a public playbook on another agent, it is executed on the called agent's server.</p>"},{"location":"agents/exported-and-public-playbooks/#how-exported-playbooks-work","title":"How Exported Playbooks Work","text":"<p>When an agent exports a playbook, another agent can import implementation of that playbook and then execute that playbook within its execution context.</p>"},{"location":"agents/exported-and-public-playbooks/#exporting-playbooks","title":"Exporting Playbooks","text":"<p> This feature under active development and not available yet.</p> <p>Exported playbooks are marked using the <code>export: true</code> metadata:</p> <pre><code># AccountManagementAgent\n\n```python\n@playbook(export=True)\nasync def CloseAccount($user_id) -&gt; str:\n    \"\"\"Close an account for a user.\"\"\"\n    # ...\n```\n\n## ProvisionAccount($user_id, $service_tier)\nexport: true\n### Steps\n- ...\n</code></pre> <p>In this example, the <code>AccountManagementAgent</code> exports the <code>CloseAccount</code> and <code>ProvisionAccount</code> playbooks.</p> <p> Implementations of both markdown and Python playbooks can be exported.</p>"},{"location":"agents/exported-and-public-playbooks/#importing-exported-playbook-implementations","title":"Importing Exported Playbook Implementations","text":"<p>To import a playbook's implementation from another remote agent, register that remote agent and then use the <code>import</code> statement:</p> <pre><code># AccountManagementAgent(url=\"https://cloud.runplaybooks.ai/account-management\")\n\n# ServiceAgent\nimport CloseAccount, ProvisionAccount from AccountManagementAgent\n</code></pre> <p>This imports implementations of the <code>CloseAccount</code> Python playbook and the <code>ProvisionAccount</code> markdown playbook from the <code>AccountManagementAgent</code> agent.</p>"},{"location":"agents/exported-and-public-playbooks/#using-imported-playbooks","title":"Using Imported Playbooks","text":"<p>Once imported, you can use the playbook just like any other playbook defined within your agent:</p> <pre><code>## CreateAccount\n### Steps\n- Validate user information\n- Create user record in database\n- ProvisionAccount($user_id, $service_tier)\n- Send welcome email to user\n</code></pre> <p>The imported <code>ProvisionAccount</code> playbook is called as if it were a local playbook.</p>"},{"location":"agents/exported-and-public-playbooks/#how-public-playbooks-work","title":"How Public Playbooks Work","text":"<p> This feature under active development and not available yet.</p> <p>When agent A marks a playbook as public, another agent B can call that playbook remotely on a running instance of agent A.</p>"},{"location":"agents/exported-and-public-playbooks/#marking-playbooks-as-public","title":"Marking Playbooks as Public","text":"<p>To mark a playbook as public, use the <code>public: true</code> metadata:</p> <pre><code># AuthenticationAgent\nThis agent handles user authentication.\n\n## VerifyCredentials($username, $password)\npublic: true\n### Steps\n- Check credentials against secure store\n- Return authentication result and user details if valid\n</code></pre> <p>Both markdown and Python playbooks can be marked as public.</p>"},{"location":"agents/exported-and-public-playbooks/#calling-public-playbooks","title":"Calling Public Playbooks","text":"<p>To call a public playbook, first register the remote agent and then call the playbook as a method on that agent:</p> <pre><code># AuthenticationAgent(url=\"https://cloud.runplaybooks.ai/authentication\")\n\n# APIGatewayAgent\n\n## HandleRequest\n### Steps\n- $auth_result = AuthenticationAgent.VerifyCredentials($request.auth.username, $request.auth.password)\n- ...\n</code></pre> <p>Here, the <code>APIGatewayAgent</code> directly calls the <code>VerifyCredentials</code> playbook on the <code>AuthenticationAgent</code> instance running at <code>https://cloud.runplaybooks.ai/authentication</code>. The playbook is executed on the remote agent's server and the result is returned to the calling agent.</p>"},{"location":"agents/exported-and-public-playbooks/#differences-between-exported-and-public-playbooks","title":"Differences Between Exported and Public Playbooks","text":"<p>Exported playbooks differ from public playbooks in several important ways:</p> Exported Playbooks Public Playbooks Example <code>import CloseAccount from AccountManagementAgent</code> and then <code>CloseAccount($user_id)</code> <code># PaymentProcessingAgent(\"https://cloud.runplaybooks.ai/ppa\")</code> and then <code>PaymentProcessingAgent.ProcessPayment($amount, $payment_method)</code> Execution Context Local execution in importing agent's context Remote procedure call on the remote agent instance State Access Can access local agent's state Cannot access local agent's state"},{"location":"agents/exported-and-public-playbooks/#security-considerations","title":"Security Considerations","text":"<p> Be careful! Importing playbooks raise several security considerations.</p> <ol> <li> <p>Code Injection: An agent that imports playbooks from another agent must trust that agent. Importing playbook implementations from untrusted agents and executing them can lead to security vulnerabilities like code injection attacks.</p> </li> <li> <p>Version Control: Changes to exported playbooks may affect importing agents, requiring careful version management.</p> </li> </ol>"},{"location":"agents/exported-and-public-playbooks/#example-agent-ecosystem","title":"Example: Agent Ecosystem","text":"<p>Let's say that we have an ecosystem of three agents.</p>"},{"location":"agents/exported-and-public-playbooks/#1-databaseagent","title":"1. DatabaseAgent","text":"<pre><code># DatabaseAgent\nThis agent provides recipes for various database related tasks.\n\n## FindTable($query, $database)\nexport: true\n### Steps\n- List all tables in the $database\n- Find the table that is most likely to contain data to answer the $query\n- Return the table name\n</code></pre> <p>Let's say that <code>DatabaseAgent</code> is available at the URL <code>https://cloud.runplaybooks.ai/database.agent</code>. It exports the <code>FindTable</code> playbook. It is a generic procedure for finding a database table.</p>"},{"location":"agents/exported-and-public-playbooks/#2-authenticationagent","title":"2. AuthenticationAgent","text":"<pre><code># AuthenticationAgent\nThis agent handles user authentication.\n\n## VerifyCredentials($username, $password)\npublic: true\n### Steps\n- Check credentials against secure store\n- Return authentication result and user details if valid\n</code></pre> <p>Let's say that an instance of the <code>AuthenticationAgent</code> is running at the URL <code>https://cloud.runplaybooks.ai/authentication.agent</code>. The public <code>VerifyCredentials</code> playbook requires access to the secure store within ACME Corp's infrastructure.</p>"},{"location":"agents/exported-and-public-playbooks/#3-apigatewayagent","title":"3. APIGatewayAgent","text":"<p>APIGatewayAgent uses the above two agents. It first registers those two agents, specifying their URLs. Then it imports the <code>FindTable</code> playbook from the <code>DatabaseAgent</code>. It then remotely calls the <code>VerifyCredentials</code> playbook on the <code>AuthenticationAgent</code> instance. Finally, it locally executes the <code>FindTable</code> playbook.</p> <pre><code># DatabaseAgent(url=\"https://cloud.runplaybooks.ai/database.agent\")\n\n# AuthenticationAgent(url=\"https://cloud.runplaybooks.ai/authentication.agent\")\n\n# APIGatewayAgent\nimport FindTable from DatabaseAgent\n\n## HandleRequest\n### Triggers\n- When an API request is received\n### Steps\n- $auth_result = AuthenticationAgent.VerifyCredentials($request.auth.username, $request.auth.password)\n- If $auth_result.success is true\n  - $table_name = FindTable($request.query, $database)\n  - Return $table_name\n- Otherwise\n  - Return authentication error\n</code></pre>"},{"location":"agents/exported-and-public-playbooks/#related-topics","title":"Related Topics","text":"<ul> <li>Multi-Agent Programming - More about setting up and using multiple agents</li> <li>Python Playbooks - How to create playbooks using Python</li> <li>Markdown Playbooks - Standard playbook structure</li> </ul>"},{"location":"agents/mcp-agent/","title":"MCP Agents","text":""},{"location":"agents/mcp-agent/#overview","title":"Overview","text":"<p>Connect to external MCP servers and expose their tools as callable playbooks.</p>"},{"location":"agents/mcp-agent/#what-is-mcp","title":"What is MCP?","text":"<p>The Model Context Protocol (MCP) is an open protocol that standardizes how AI applications can access external tools and data sources. MCP servers expose tools that can perform various tasks like:</p> <ul> <li>Accessing databases</li> <li>Making API calls</li> <li>Performing calculations</li> <li>Interacting with file systems</li> <li>Running specialized algorithms</li> <li>And much more</li> </ul>"},{"location":"agents/mcp-agent/#create-an-mcp-agent","title":"Create an MCP agent","text":"<p>To create an MCP agent, you need to specify the agent's metadata with remote configuration:</p> <pre><code># Example MCP Server\nremote:\n  type: mcp\n  url: memory://test\n  transport: memory\n\n# Example MCP Client Agent\n\n## Main\n\n### Triggers\n- When program starts\n\n### Steps\n- get secret from Example MCP Server\n- reveal secret to user\n- end program\n</code></pre>"},{"location":"agents/mcp-agent/#configuration-options","title":"Configuration Options","text":"<p>The MCP agent configuration supports the following options:</p> Option Required Description Default <code>type</code> Yes Must be <code>mcp</code> for MCP agents - <code>url</code> Yes The MCP server URL or command - <code>transport</code> No Transport type (<code>sse</code>, <code>stdio</code>, <code>websocket</code>) <code>sse</code> <code>timeout</code> No Timeout in seconds for tool calls <code>30.0</code> <code>auth</code> No Authentication configuration object <code>{}</code>"},{"location":"agents/mcp-agent/#transport-types","title":"Transport types","text":"<p>MCP agents support different transport protocols:</p> <ul> <li>SSE (Server-Sent Events)</li> <li>stdio</li> <li>WebSocket</li> </ul>"},{"location":"agents/mcp-agent/#how-mcp-agents-work","title":"How MCP Agents Work","text":"<ol> <li>Connection: When the program starts, the MCP agent connects to the specified server</li> <li>Tool Discovery: The agent automatically discovers all available tools from the server</li> <li>Playbook Creation: Each MCP tool becomes a playbook that can be called</li> <li>Execution: When a playbook is called, the agent forwards the request to the MCP server</li> </ol>"},{"location":"agents/mcp-agent/#use-mcp-tools-as-playbooks","title":"Use MCP tools as playbooks","text":"<p>Once connected, all MCP tools are automatically available as playbooks. You can call them just like any other playbook:</p> <pre><code># Weather MCP Agent\nmetadata:\n  remote:\n    type: mcp\n    url: http://weather-service.example.com/mcp\n    transport: sse\n---\nThis agent connects to a weather MCP service.\n\n# Weather Assistant\n## Main\n### Trigger\n- When program starts\n\n### Steps\n- Say \"Welcome to Weather Assistant! What location would you like weather for?\"\n- Get user's location\n- Call Weather MCP Agent's get_current_weather with location=$location\n- Display the weather: \"Current weather in $location: $weather\"\n- End program\n</code></pre>"},{"location":"agents/mcp-agent/#combine-multiple-mcp-agents","title":"Combine multiple MCP agents","text":"<p>You can use multiple MCP agents in a single program:</p> <pre><code># Weather MCP\nmetadata:\n  remote:\n    type: mcp\n    url: http://weather-api.com/mcp\n---\nWeather service integration.\n\n# News MCP\nmetadata:\n  remote:\n    type: mcp\n    url: http://news-api.com/mcp\n---\nNews service integration.\n\n# Assistant\n## DailyBriefing\n### Steps\n- Get weather from Weather MCP's get_current_weather for New York\n- Get news from News MCP's get_top_headlines with technology category\n- Create briefing combining weather and news\n- Present briefing to user\n</code></pre>"},{"location":"agents/mcp-agent/#authentication","title":"Authentication","text":"<p>For MCP servers that require authentication:</p> <pre><code># Secure API Agent\nmetadata:\n  remote:\n    type: mcp\n    url: https://api.example.com/mcp\n    transport: sse\n    auth:\n      type: bearer\n      token: ${API_TOKEN}\n---\nConnects to a secured MCP endpoint.\n</code></pre>"},{"location":"agents/mcp-agent/#run-an-mcp-server-examples","title":"Run an MCP server (examples)","text":"<p>You can create simple MCP servers with <code>fastmcp</code>. Example servers in the repo:</p> <ul> <li>Insomnia server: <code>tests/data/insomnia/mcp.py</code></li> <li>Travel advisor server: <code>tests/data/travel_advisor/mcp.py</code></li> </ul> <p>Run them with:</p> <pre><code>python tests/data/insomnia/mcp.py\npython tests/data/travel_advisor/mcp.py\n</code></pre> <p>Then point your MCP agent <code>url</code> at the server (e.g., <code>http://localhost:8000</code> if using streamable-http) and set <code>transport</code> accordingly.</p>"},{"location":"agents/mcp-agent/#next-steps","title":"Next steps","text":"<ul> <li>Review tutorials for more examples</li> <li>Learn about External Playbooks</li> <li>Explore Exported and Public Playbooks</li> </ul>"},{"location":"applications/","title":"Applications","text":"<p>Playbooks provides multiple ways to run programs beyond the CLI:</p> <ul> <li>Command-line agent chat application</li> <li>Web server (HTTP + WebSocket) for external UIs</li> <li>HTML Playground for a no-build, in-browser UI</li> </ul> <p>See the pages in this section for details.</p>"},{"location":"applications/cli/","title":"Playbooks CLI","text":"<p>The <code>playbooks</code> command-line interface lets you run and compile Playbooks programs.</p>"},{"location":"applications/cli/#usage","title":"Usage","text":"<pre><code>playbooks --version\nplaybooks &lt;command&gt; [options]\n</code></pre>"},{"location":"applications/cli/#commands","title":"Commands","text":""},{"location":"applications/cli/#run","title":"run","text":"<p>Run one or more Playbooks programs.</p> <pre><code>playbooks run [options] &lt;program_paths...&gt;\n</code></pre> <ul> <li><code>program_paths</code>: One or more <code>.pb</code> or <code>.pbasm</code> files</li> </ul> <p>Options:</p> <ul> <li><code>--application &lt;module&gt;</code>: Application module to use (default: <code>playbooks.applications.agent_chat</code>)</li> <li><code>-v, --verbose</code>: Print the session log</li> <li><code>--debug</code>: Start the debug server</li> <li><code>--debug-host &lt;host&gt;</code>: Debug server host (default: <code>127.0.0.1</code>)</li> <li><code>--debug-port &lt;port&gt;</code>: Debug server port (default: <code>7529</code>)</li> <li><code>--wait-for-client</code>: Wait for a debug client to connect before starting execution</li> <li><code>--stop-on-entry</code>: Stop at the beginning of playbook execution</li> <li><code>--skip-compilation</code>: Skip compilation step (automatically skipped for <code>.pbasm</code> files)</li> </ul> <p>Examples:</p> <pre><code>playbooks run hello.pb\nplaybooks run examples/chatbot.pb --debug --wait-for-client\nplaybooks run compiled/hello.pbasm --skip-compilation\n# Mix compiled and source files\nplaybooks run compiled/hello.pbasm hello.pb\n</code></pre>"},{"location":"applications/cli/#see-also","title":"See also","text":"<ul> <li>Run with CLI</li> <li>VSCode Extension</li> </ul>"},{"location":"applications/cli/#compile","title":"compile","text":"<p>Compile one or more Playbooks programs.</p> <pre><code>playbooks compile [options] &lt;program_paths...&gt;\n</code></pre> <p>Options:</p> <ul> <li><code>--output &lt;path&gt;</code>: Output file path (if not specified, prints to stdout). Do not use when compiling multiple files.</li> </ul> <p>Examples:</p> <pre><code>playbooks compile hello.pb\nplaybooks compile hello.pb --output hello.pbasm\n</code></pre>"},{"location":"applications/cli/#exit-codes","title":"Exit codes","text":"<ul> <li><code>0</code>: Success</li> <li>Non-zero: Error (e.g., program load or compilation failure)</li> </ul>"},{"location":"applications/playground/","title":"HTML Playground","text":"<p>An in-browser, no-build conversational UI that connects to the Web Server.</p>"},{"location":"applications/playground/#usage","title":"Usage","text":"<ol> <li> <p>Start the web server: <pre><code>python -m playbooks.applications.web_server\n</code></pre></p> </li> <li> <p>Open the Playground (application/playbooks_playground.html in playbooks repository) in your browser</p> </li> <li> <p>Enter a Playbooks program path (e.g., <code>tests/data/02-personalized-greeting.pb</code>) and click Run Program</p> </li> </ol> <p>The UI will:</p> <ul> <li>Create a run via <code>POST http://localhost:8000/runs/new</code></li> <li>Connect to <code>ws://localhost:8001/ws/&lt;run_id&gt;</code></li> <li>Stream messages and execution logs with filtering controls</li> </ul>"},{"location":"applications/playground/#see-also","title":"See also","text":"<ul> <li>Web Server</li> </ul>"},{"location":"applications/web-server/","title":"Web Server","text":"<p>A WebSocket-first server exposes an HTTP API to create runs and a WebSocket to stream all execution events, enabling custom UIs.</p>"},{"location":"applications/web-server/#run-the-server","title":"Run the server","text":"<pre><code>python -m playbooks.applications.web_server --host localhost --http-port 8000 --ws-port 8001\n</code></pre> <p>On start, it prints endpoints like:</p> <ul> <li>HTTP API: <code>http://localhost:8000</code></li> <li>WebSocket: <code>ws://localhost:8001</code></li> <li>Create run: <code>POST /runs/new</code></li> </ul>"},{"location":"applications/web-server/#http-api","title":"HTTP API","text":"<ul> <li><code>POST /runs/new</code> with JSON body:</li> </ul> <pre><code>{ \"path\": \"tests/data/02-personalized-greeting.pb\" }\n</code></pre> <p>or</p> <pre><code>{ \"program\": \"# ... full Playbooks program ...\" }\n</code></pre> <p>Response:</p> <pre><code>{ \"run_id\": \"&lt;uuid&gt;\" }\n</code></pre>"},{"location":"applications/web-server/#websocket","title":"WebSocket","text":"<p>Connect to <code>ws://localhost:8001/ws/&lt;run_id&gt;</code> to receive a stream of events:</p> <ul> <li>Connection, start, termination</li> <li>Agent messages and streaming updates</li> <li>Human input prompts</li> <li>Meeting broadcasts</li> <li>Session log entries</li> </ul>"},{"location":"applications/web-server/#typical-flow","title":"Typical flow","text":"<ol> <li>Start server</li> <li><code>POST /runs/new</code> with <code>{ path: \"my.pb\" }</code></li> <li>Open WebSocket and render events in your UI</li> </ol> <p>See also: Playground for a ready-made HTML client.</p> <p>Related:</p> <ul> <li>Observability &amp; Debugging</li> </ul>"},{"location":"artifacts/","title":"Artifacts","text":"<ul> <li>See Built-in Playbooks for artifact functions like <code>SaveArtifact</code> and <code>LoadArtifact</code></li> <li>Refer to tutorials for the guided curriculum</li> </ul>"},{"location":"get-started/","title":"Getting Started with Playbooks AI","text":"<p>Playbooks AI is a framework for building AI agents using natural language programming. It allows you to create AI agents that can understand and execute natural language instructions, interact with users, and call Python functions seamlessly.</p>"},{"location":"get-started/#what-are-playbooks","title":"What are Playbooks?","text":"<p>Playbooks are procedures that define the behavior of AI agents. They can be written as:</p> <ol> <li>Natural language instructions - Step-by-step instructions for prescribed business processes</li> <li>Agentic prompts - Prompt-based playbooks for dynamically planned tasks where the AI agent decides the next steps</li> <li>Python functions - Python functions that can be called from playbooks and can call playbooks</li> </ol>"},{"location":"get-started/#installation","title":"Installation","text":"<p>To get started with Playbooks AI, you need to install the <code>playbooks</code> package:</p> <pre><code>pip install playbooks\n</code></pre>"},{"location":"get-started/#first-steps","title":"First Steps","text":"<p>Follow these guides to start building with Playbooks AI:</p> <ul> <li>Installation: Detailed installation instructions</li> <li>Quickstart: Create your first playbook in minutes</li> <li>Tutorials: Tutorials to learn from</li> </ul>"},{"location":"get-started/#see-also","title":"See also","text":"<ul> <li>Playbooks Language</li> <li>Playbook Types</li> </ul>"},{"location":"get-started/#core-concepts","title":"Core Concepts","text":"<p>Playbooks AI is built around these core concepts:</p> <ul> <li>Playbooks Language: The natural language programming syntax</li> <li>Agent Framework: The environment that Playbooks programs run in</li> <li>Playbooks Runtime: Manages interpreter, control flow, variables, artifacts, etc.</li> <li>Triggers: Event-driven programming through natural language conditions</li> <li>Artifacts: Store and access data from playbooks</li> </ul> <p>Ready to dive in? Check out the Quickstart Guide to create your first playbook. </p>"},{"location":"get-started/installation/","title":"Installation","text":"<p>This guide will walk you through the process of installing Playbooks AI and setting up your development environment.</p>"},{"location":"get-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing Playbooks AI, ensure you have:</p> <ul> <li>Python 3.12 or higher</li> <li>pip (Python package installer)</li> <li>A virtual environment tool (optional but recommended)</li> </ul>"},{"location":"get-started/installation/#installing-playbooks-ai","title":"Installing Playbooks AI","text":""},{"location":"get-started/installation/#basic-installation","title":"Basic Installation","text":"<p>The simplest way to install Playbooks AI is using pip:</p> <pre><code>pip install playbooks\n</code></pre> <p>This will install the core Playbooks AI package with all the essential dependencies.</p>"},{"location":"get-started/installation/#installation-in-a-virtual-environment","title":"Installation in a Virtual Environment","text":"<p>For a cleaner installation that doesn't affect your global Python environment, we recommend using a virtual environment:</p>"},{"location":"get-started/installation/#using-venv-built-into-python","title":"Using venv (built into Python)","text":"<pre><code># Create a virtual environment\npython -m venv playbooks-env\n\n# Activate the virtual environment\n# On Windows\nplaybooks-env\\Scripts\\activate\n# On macOS/Linux\nsource playbooks-env/bin/activate\n\n# Install Playbooks AI\npip install playbooks\n</code></pre>"},{"location":"get-started/installation/#using-poetry","title":"Using Poetry","text":"<p>If you're using Poetry for dependency management:</p> <pre><code># Create a new project with Poetry\npoetry new my-playbooks-project\ncd my-playbooks-project\n\n# Add Playbooks AI as a dependency\npoetry add playbooks\n\n# Activate the virtual environment\npoetry shell\n</code></pre>"},{"location":"get-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>You can verify that Playbooks AI is installed correctly by running:</p> <pre><code>playbooks --version\n</code></pre> <p>This should print the installed version, e.g., <code>playbooks 0.5.0</code>.</p>"},{"location":"get-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>No optional dependencies are required for Playbooks AI.</p>"},{"location":"get-started/installation/#vscode-debugging-support","title":"VSCode Debugging Support","text":"<p>For enhanced development experience, install the Playbooks Language Support extension for Visual Studio Code. See the dedicated guide:</p> <ul> <li>VSCode Extension</li> </ul>"},{"location":"get-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"get-started/installation/#common-issues","title":"Common Issues","text":"<ul> <li>ImportError: No module named 'playbooks': The package isn't installed correctly. Try reinstalling.</li> <li>Version conflicts: If you have dependency conflicts, try installing in a fresh virtual environment.</li> <li>Permission errors: You might need administrator privileges. Try using <code>sudo pip install playbooks</code> on Unix systems or run as administrator on Windows.</li> </ul>"},{"location":"get-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues during installation:</p> <ul> <li>Check the GitHub repository for known issues</li> <li>Join our community on Discord to get help from other users</li> <li>File an issue on GitHub if you've found a bug</li> </ul>"},{"location":"get-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have Playbooks AI installed, you can:</p> <ul> <li>Follow the Quickstart Guide to create your first playbook</li> <li>Explore the Playbooks Language documentation to learn about the syntax</li> </ul>"},{"location":"get-started/quickstart/","title":"Quickstart","text":"<p>This quickstart guide will help you create and run your first Playbooks AI program. By the end, you'll have a simple interactive program that asks for your name and provides a personalized greeting.</p>"},{"location":"get-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Installed Playbooks AI (see the Installation Guide)</li> <li>An API key for Anthropic (Claude Sonnet 4.0) or another supported provider</li> </ul>"},{"location":"get-started/quickstart/#step-1-set-up-your-environment","title":"Step 1: Set Up Your Environment","text":"<p>First, you need to set up your environment variables to authenticate with Anthropic.</p> <p>Create a <code>.env</code> file in your project root (the directory where you run CLI commands) and configure your API key and model:</p> <pre><code># For Anthropic (Claude Sonnet 4.0)\nANTHROPIC_API_KEY=your_anthropic_api_key_here\nMODEL=claude-sonnet-4-20250514\n\n# Cache LLM responses to disk\nLLM_CACHE_TYPE=\"disk\"\nLLM_CACHE_ENABLED=\"true\"\nLLM_CACHE_PATH=\".llm_cache\" # for disk cache\n\n# Langfuse (optional)\n# LANGFUSE_SECRET_KEY=\"sk-lf-...\"\n# LANGFUSE_PUBLIC_KEY=\"pk-lf-...\"\n# LANGFUSE_HOST=\"http://localhost:3000\"\n</code></pre> <p>Make sure to replace the placeholder with your actual API key.</p> <p> Claude Sonnet 4.0 is the only LLM currently supported by Playbooks. Other frontier LLMs may work and can be selected by setting <code>MODEL</code> and the appropriate provider API key (see Reference &gt; Configuration). The performance of other LLMs is not guaranteed.</p>"},{"location":"get-started/quickstart/#vscode-support-optional","title":"VSCode Support (optional)","text":"<p>For the best development experience, consider setting up VSCode with debugging support. See the Installation Guide for instructions on installing the Playbooks Language Support extension, which provides debugging capabilities for your playbooks programs.</p>"},{"location":"get-started/quickstart/#langfuse-optional","title":"Langfuse (optional)","text":"<p>You can specify Langfuse credentials for tracing the execution of your Playbooks programs. For developement environment, we recommend using the docker compose setup for Langfuse. After following these instructions, launch Langfuse at http://localhost:3000, create a new organization and project, and create a new secret key and public key to enable tracing.</p>"},{"location":"get-started/quickstart/#step-2-create-your-first-playbooks-program","title":"Step 2: Create Your First Playbooks program","text":"<p>Create a new file named <code>hello.pb</code> with the following content:</p> <pre><code># Personalized greeting\nThis program greets the user by name\n\n## Greet\n### Triggers\n- At the beginning of the program\n### Steps\n- Ask the user for their name\n- Say hello to the user by name and welcome them to Playbooks AI\n- End program\n</code></pre> <p>This simple Playbooks program:</p> <ul> <li>Defines a \"Personalized greeting\" agent</li> <li>Defines a \"Greet\" playbook that triggers at the beginning of program execution</li> <li>Specifies steps to ask for the user's name and respond with a personalized greeting</li> </ul>"},{"location":"get-started/quickstart/#step-3-run-your-playbooks-program","title":"Step 3: Run Your Playbooks program","text":"<p>Now, run your program:</p> <pre><code>playbooks run hello.pb\n</code></pre> <p>You should see output similar to:</p> <pre><code>Loading playbooks from: ['hello.pb']\nCompiling hello.pb\n\nPersonalizedGreeting: Hello! What's your name?\n\nUser: Amol\n\nPersonalizedGreeting: Hello Amol! Welcome to Playbooks AI. I'm excited to help you explore what we can do together!\n\n\nExecution finished, exiting...\nAgent PersonalizedGreeting(agent 1000) stopped\n</code></pre> <p>Congratulations! You've successfully run your first Playbooks program.</p>"},{"location":"get-started/quickstart/#alternative-run-with-web-server-playground","title":"Alternative: Run with web server + playground","text":"<p>If you prefer a web UI:</p> <ol> <li>Start the web server: <code>python -m playbooks.applications.web_server</code></li> <li>Open the HTML Playground and point it to your <code>hello.pb</code> (see Applications &gt; HTML Playground)</li> </ol>"},{"location":"get-started/quickstart/#understanding-whats-happening","title":"Understanding What's Happening","text":"<p>Let's break down what happened:</p> <ol> <li>The Playbooks AI framework loaded your markdown file and transpiled it into an executable format</li> <li>The AgentChat application was launched, which provides a simple command-line chat interface</li> <li>The application started executing the program</li> <li>The playbook with the \"At the beginning\" trigger was automatically executed</li> <li>The agent followed the steps defined in your playbook:</li> <li>Asked for your name</li> <li>Processed your response</li> <li>Generated a personalized greeting</li> <li>Ended the program</li> </ol>"},{"location":"get-started/quickstart/#optional-compile-to-playbooks-assembly","title":"Optional: Compile to Playbooks Assembly","text":"<p>You can compile your program to <code>.pbasm</code> for inspection or to skip compilation at run time:</p> <pre><code>playbooks compile hello.pb --output hello.pbasm\n</code></pre> <p>Run a compiled program with the same agent chat application:</p> <pre><code>playbooks run hello.pbasm\n</code></pre>"},{"location":"get-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've run your first playbook, you can:</p> <ul> <li>Go through the tutorials</li> <li>Learn about Triggers for more advanced event-based programming</li> <li>Learn how to create multi-agent systems</li> <li>Explore Markdown vs ReAct vs Raw Prompt</li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>Use these task\u2011oriented guides when you have a specific goal in mind. Each guide is short, precise, and links to reference pages for details.</p>"},{"location":"guides/adding-triggers/","title":"Adding Triggers","text":"<p>Goal: Run a playbook when a condition is met.</p>"},{"location":"guides/adding-triggers/#common-triggers","title":"Common triggers","text":"<ul> <li>At the beginning</li> <li>When $variable meets a condition (e.g., <code>When $x &gt; 10</code>)</li> <li>Before/After calling another playbook</li> <li>When user provides specific input</li> </ul>"},{"location":"guides/adding-triggers/#example","title":"Example","text":"<pre><code>## Main\n### Triggers\n- At the beginning\n### Steps\n- $x = 10\n- LoadAccount\n- $x = $x * 2\n- Tell user balance\n\n## TooBig\n### Triggers\n- When $x &gt; 15\n### Steps\n- Tell user $x is too big\n\n## AfterLoad\n### Triggers\n- After calling LoadAccount\n### Steps\n- Tell user account loaded\n</code></pre> <p>Tips:</p> <ul> <li>Write clear conditions</li> <li>Avoid mutually triggering playbooks</li> <li>Prefer triggers for validation over inline checks</li> </ul> <p>See also: Triggers</p> <p>Related:</p> <ul> <li>Tutorials Part 2 \u2013 Triggers</li> </ul>"},{"location":"guides/calling-playbooks/","title":"Call Playbooks","text":"<p>Goal: Call a playbook with arguments and capture return values.</p>"},{"location":"guides/calling-playbooks/#explicit-call","title":"Explicit call","text":"<pre><code>## Greeting($name)\n### Steps\n- Say \"Hello, $name!\"\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Ask for $name\n- Greeting($name)\n</code></pre>"},{"location":"guides/calling-playbooks/#return-values","title":"Return values","text":"<pre><code>## Total($price, $qty)\n### Steps\n- Return $price * $qty\n\n## Main\n### Steps\n- $bill = Total($p, $q)\n- Tell user bill is $bill\n</code></pre>"},{"location":"guides/calling-playbooks/#semantic-call","title":"Semantic call","text":"<pre><code>## Main\n### Steps\n- Calculate total bill amount \u2190 This will call the CalculateTotal playbook\n- Tell user the bill amount\n\n```python\n@playbook\ndef CalculateTotal(price, qty):\n    return price * qty\n```\n</code></pre> <p>Tips:</p> <ul> <li>Prefer semantic calls for readability</li> <li>Use parameters for clarity when needed</li> </ul>"},{"location":"guides/compilation-and-cache/","title":"Compilation and Cache","text":"<p>Playbooks compiles <code>.pb</code> files to PBASM. It caches results next to the source in <code>.pbasm_cache/</code>.</p>"},{"location":"guides/compilation-and-cache/#compile","title":"Compile","text":"<pre><code>playbooks compile program.pb --output program.pbasm\n</code></pre>"},{"location":"guides/compilation-and-cache/#cache","title":"Cache","text":"<ul> <li>Location: <code>.pbasm_cache/&lt;name&gt;.playbooks-&lt;version&gt;.pbasm</code></li> <li>Valid when newer than the source and the compiler prompt template</li> <li>Safe to delete to force recompilation (e.g., when switching between different LLMs)</li> <li>Compiled files can be run directly and will not be re-compiled <pre><code>playbooks run program.pbasm\n</code></pre></li> </ul> <p>See also: Environment Variables</p> <p>Related:</p> <ul> <li>Playbooks Assembly Language (PBAsm)</li> </ul>"},{"location":"guides/environment-variables/","title":"Environment Variables","text":"<p>Playbooks reads configuration primarily from environment variables. The loader searches for <code>.env</code> and <code>.env.&lt;environment&gt;</code> files automatically.</p>"},{"location":"guides/environment-variables/#environment-file-loading","title":"Environment file loading","text":"<p>At import time, Playbooks loads environment variables in this order:</p> <ol> <li><code>.env</code> in the project root (the directory where you run CLI)</li> <li><code>.env.&lt;environment&gt;</code> if present, where <code>&lt;environment&gt;</code> is taken from <code>ENV</code> or <code>ENVIRONMENT</code> (defaults to <code>development</code>)</li> </ol>"},{"location":"guides/environment-variables/#model-selection-and-api-keys","title":"Model selection and API keys","text":"<ul> <li><code>MODEL</code>: Language model to use. Default: <code>claude-sonnet-4-20250514</code>.</li> </ul> <p> Claude Sonnet 4.0 is the only LLM currently supported by Playbooks.</p> <ul> <li>Provider API keys (set the one matching your <code>MODEL</code>):</li> <li><code>ANTHROPIC_API_KEY</code> for Claude models</li> <li><code>OPENAI_API_KEY</code> for OpenAI models</li> <li><code>GEMINI_API_KEY</code> for Google Gemini models</li> <li><code>GROQ_API_KEY</code> for Groq models</li> <li> <p><code>OPENROUTER_API_KEY</code> for OpenRouter models</p> </li> <li> <p><code>COMPILER_MODEL</code>: Override the model used by the compiler stage (defaults to <code>MODEL</code> if unset)</p> </li> </ul>"},{"location":"guides/environment-variables/#llm-response-cache-optional","title":"LLM response cache (optional)","text":"<ul> <li><code>LLM_CACHE_ENABLED</code> (\"true\"/\"false\"): Enable caching. Default: false</li> <li><code>LLM_CACHE_TYPE</code>: <code>disk</code> (default) or other supported types</li> <li><code>LLM_CACHE_PATH</code>: Directory path for disk cache when <code>disk</code> is used</li> </ul>"},{"location":"guides/environment-variables/#langfuse-tracing-optional","title":"Langfuse tracing (optional)","text":"<ul> <li><code>LANGFUSE_SECRET_KEY</code></li> <li><code>LANGFUSE_PUBLIC_KEY</code></li> <li><code>LANGFUSE_HOST</code> (e.g., <code>http://localhost:3000</code>)</li> </ul>"},{"location":"guides/run-with-cli/","title":"Run with CLI","text":"<p>Run Playbooks programs from the command line.</p>"},{"location":"guides/run-with-cli/#basics","title":"Basics","text":"<pre><code>playbooks run program.pb\n</code></pre> <p>Multiple source files:</p> <pre><code>playbooks run compiled/program1.pbasm program2.pb\n</code></pre>"},{"location":"guides/run-with-cli/#compile","title":"Compile","text":"<pre><code>playbooks compile program.pb --output program.pbasm\n</code></pre>"},{"location":"guides/run-with-cli/#debug-server","title":"Debug server","text":"<p>Used by the Visual Studio Code extension for Playbooks debugging.</p> <pre><code>playbooks run program.pb --debug --wait-for-client --stop-on-entry\n</code></pre> <p>See also: Playbooks CLI</p> <p>Related:</p> <ul> <li>VSCode Extension</li> <li>Observability &amp; Debugging</li> </ul>"},{"location":"guides/user-interaction/","title":"User Interaction","text":"<p>Goal: Ask for input, validate it, and respond.</p>"},{"location":"guides/user-interaction/#basic-flow","title":"Basic flow","text":"<pre><code>## Greet\n### Triggers\n- At the beginning\n### Steps\n- Ask the user for their $name\n- Say hello to $name\n</code></pre>"},{"location":"guides/user-interaction/#validation-loop","title":"Validation loop","text":"<pre><code>## Main\n### Triggers\n- At the beginning\n### Steps\n- Ask for a 4-digit $pin\n- While $pin is not a 4-digit number\n  - Tell user PIN is invalid\n  - Ask again for $pin\n- Tell user PIN is accepted\n</code></pre>"},{"location":"guides/user-interaction/#single-line-validation-loop","title":"Single line validation loop","text":"<pre><code>## Main\n### Triggers\n- At the beginning\n### Steps\n- Ask user for a 4-digit $pin, engage in a professional conversation till user provides pin or gives up\n</code></pre>"},{"location":"guides/user-interaction/#automatic-validation","title":"Automatic validation","text":"<pre><code>## Main\n### Triggers\n- At the beginning\n### Steps\n- Ask user for a 4-digit $pin, engage in a professional conversation till user provides a valid pin or gives up\n\n## ValidatePin\n\n### Triggers\n- When user provides a new pin\n\n### Steps\n- If pin is not a 4-digit number\n  - Return \"PIN should be 4 digits\"\n- sum up the digits of the pin\n- If sum is greater than 10\n  - Return \"This is not a valid PIN\"\n- Return \"PIN is valid\"\n</code></pre> <p>Tips:</p> <ul> <li>Use variables to store responses</li> <li>Keep prompts short and specific</li> </ul> <p>See also: Tutorials Part 1</p> <p>Related:</p> <ul> <li>Markdown Playbooks</li> <li>Built-in Playbooks</li> <li>Variables &amp; Expressions</li> </ul>"},{"location":"guides/variables-and-expressions/","title":"Variables &amp; Expressions","text":"<p>Goal: Use variables safely and write expressions that evaluate reliably.</p>"},{"location":"guides/variables-and-expressions/#variables","title":"Variables","text":"<ul> <li>Use <code>$name</code> to reference a variable in steps</li> <li>Assign with <code>- $x = ...</code></li> <li>Return with <code>- Return $x</code></li> </ul>"},{"location":"guides/variables-and-expressions/#expressions","title":"Expressions","text":"<ul> <li>You can write simple Python\u2011like expressions in assignments and conditions</li> </ul> <p>Examples:</p> <pre><code>- Ask user their $age\n- If $age is less than 25\n  - Tell user about below 25 insurance requirements\n</code></pre>"},{"location":"guides/variables-and-expressions/#description-placeholders","title":"Description placeholders","text":"<p>You can use expressions in playbook descriptions with <code>{expression}</code> syntax:</p> <pre><code>## ProcessOrder\nProcessing order {$order_id} for customer {$customer_name}\n</code></pre> <p>These placeholders are resolved at runtime when the playbook executes. See Markdown Playbooks - Description placeholders for details.</p> <p>See also: Playbooks Language and Metadata.</p>"},{"location":"integrations/langfuse/","title":"Langfuse Integration","text":"<p>You can enable tracing of Playbooks executions with Langfuse.</p>"},{"location":"integrations/langfuse/#setup","title":"Setup","text":"<ol> <li>Deploy Langfuse (e.g., using their Docker Compose setup)</li> <li>Create an organization and project</li> <li>Generate a secret key and public key</li> <li>Configure environment variables in your <code>.env</code>:</li> </ol> <pre><code>LANGFUSE_SECRET_KEY=sk-lf-...\nLANGFUSE_PUBLIC_KEY=pk-lf-...\nLANGFUSE_HOST=http://localhost:3000\n</code></pre> <p>Playbooks will include tracing spans when configured.</p>"},{"location":"integrations/langfuse/#see-also","title":"See also","text":"<ul> <li>Observability &amp; Debugging</li> </ul>"},{"location":"integrations/vscode/","title":"VSCode Extension","text":"<p>Install the Playbooks VSCode extension (<code>playbooks</code>) for language support and debugging.</p>"},{"location":"integrations/vscode/#features","title":"Features","text":"<ul> <li>Syntax highlighting for <code>.pb</code> and <code>.pbasm</code></li> <li>Live Preview for <code>.pb</code></li> <li>Diagnostics and document symbols</li> <li>Step-through debugging with breakpoints and call stack</li> <li>Basic configuration options (Python path, debug port, preview theme)</li> </ul>"},{"location":"integrations/vscode/#install","title":"Install","text":"<ol> <li>Open VSCode</li> <li>Extensions (Cmd+Shift+X / Ctrl+Shift+X)</li> <li>Search for <code>playbooks</code></li> <li>Install the Playbooks extension</li> </ol>"},{"location":"integrations/vscode/#use","title":"Use","text":"<ul> <li>Open a <code>.pb</code> file to enable language features</li> <li>Live Preview: Cmd/Ctrl+Shift+V</li> <li>Run &amp; Debug: open a <code>.pb</code> and add a Playbooks debug configuration</li> </ul>"},{"location":"integrations/vscode/#debug-configuration","title":"Debug configuration","text":"<p>Add via Run and Debug UI or add to <code>launch.json</code>:</p> <pre><code>{\n  \"type\": \"playbooks\",\n  \"request\": \"launch\",\n  \"name\": \"Launch Playbook\",\n  \"program\": \"${file}\",\n  \"stopOnEntry\": true,\n  \"pythonPath\": \"python\",\n  \"cwd\": \"${fileDirname}\",\n  \"console\": \"integratedTerminal\",\n  \"env\": {\n    \"ANTHROPIC_API_KEY\": \"your-key\"\n  }\n}\n</code></pre> <p>Tip: Run your program with the CLI in debug mode to attach: <code>playbooks run my.pb --debug --wait-for-client</code>.</p> <p>See Observability &amp; Debugging for server flags and workflows.</p>"},{"location":"integrations/vscode/#see-also","title":"See also","text":"<ul> <li>Observability &amp; Debugging</li> <li>Run with CLI</li> </ul>"},{"location":"observability/","title":"Observability &amp; Debugging","text":"<p>Playbooks AI provides comprehensive observability capabilities to help you monitor, debug, and optimize your AI agents. This is essential for building reliable and trustworthy AI systems, especially in production environments.</p>"},{"location":"observability/#overview","title":"Overview","text":"<p>The observability features in Playbooks AI enable you to:</p> <ul> <li>Monitor playbook execution and performance</li> <li>Track LLM interactions and token usage</li> <li>Debug complex agent workflows</li> <li>Gain insights into agent decision-making processes</li> <li>Measure and optimize costs</li> <li>Ensure compliance and auditability</li> </ul>"},{"location":"observability/#debug-server","title":"Debug server","text":"<p>Run any program with a built-in debug server:</p> <pre><code>playbooks run my.pb --debug --wait-for-client --stop-on-entry\n</code></pre> <p>Flags:</p> <ul> <li><code>--debug</code>: start the server</li> <li><code>--debug-host</code> / <code>--debug-port</code>: address (default <code>127.0.0.1:7529</code>)</li> <li><code>--wait-for-client</code>: pause until a client attaches</li> <li><code>--stop-on-entry</code>: break at the first step</li> </ul> <p>Attach from VSCode using the Playbooks debug configuration (see Integrations &gt; VSCode). You can set breakpoints in <code>.pb</code>, step, and inspect the call stack.</p>"},{"location":"observability/#session-logs-and-events","title":"Session logs and events","text":"<p>Playbooks emits structured session logs and an event bus stream:</p> <ul> <li>Session logs: step execution, variable updates, playbook calls, LLM requests/responses</li> <li>Event bus: subscribe to <code>*</code> to print all events in a custom app; the Web Server and Playground consume this stream to visualize execution in real time</li> </ul>"},{"location":"observability/#web-server-playground","title":"Web Server &amp; Playground","text":"<p>Start the server and open the HTML Playground to visualize agent messages and logs live. See Applications &gt; Web Server and &gt; HTML Playground for details.</p>"},{"location":"observability/#see-also","title":"See also","text":"<ul> <li>VSCode Extension</li> <li>Run with CLI</li> </ul>"},{"location":"observability/#langfuse-integration","title":"LangFuse Integration","text":"<p>Playbooks AI integrates with LangFuse, an open-source observability platform specifically designed for LLM applications. LangFuse provides tracing, evaluation, and analytics for your AI agents.</p>"},{"location":"observability/#setting-up-langfuse","title":"Setting Up LangFuse","text":"<p>To enable LangFuse integration, you need to:</p> <ol> <li>Deploy your own LangFuse instance using docker compose or set up an account on LangFuse Cloud.</li> <li>Configure your environment variables in the <code>.env</code> file     <pre><code># LangFuse Configuration\nLANGFUSE_SECRET_KEY=your_langfuse_secret_key\nLANGFUSE_PUBLIC_KEY=your_langfuse_public_key\nLANGFUSE_HOST=http://localhost:3000\n</code></pre></li> </ol>"},{"location":"observability/#what-playbooks-ai-traces","title":"What Playbooks AI Traces","text":"<p>When LangFuse integration is enabled, Playbooks AI automatically traces:</p> <ol> <li>Playbook Executions: Each markdown and Python playbook run with timing and context</li> <li>LLM Interactions: Prompts, completions, tokens, and latency</li> <li>User Interactions: Messages and responses</li> <li>Agent State Changes: Variables and context updates</li> <li>Errors and Exceptions: Problems encountered during execution</li> </ol>"},{"location":"observability/#viewing-and-analyzing-data","title":"Viewing and analyzing data","text":"<p>After integrating with LangFuse, run a Playbooks program and then view the traces in the LangFuse dashboard.</p>"},{"location":"playbook-types/","title":"Playbook Types","text":"<p>Playbooks AI supports multiple types of playbooks, each with its own strengths and use cases. This flexibility allows you to choose the right tool for each aspect of your agent's behavior.</p>"},{"location":"playbook-types/#overview-of-playbook-types","title":"Overview of Playbook Types","text":""},{"location":"playbook-types/#markdown-playbooks","title":"Markdown Playbooks","text":"<p>Markdown playbooks use a structured format with clear sections for triggers, steps, and notes. They are ideal for:</p> <ul> <li>Prescribed business processes with clear steps</li> <li>Customer service workflows</li> <li>Support scripts</li> <li>Situations where the agent should follow a specific, predefined flow</li> </ul> <pre><code>## GreetCustomer\nThis playbook greets the customer and collects their information.\n\n### Triggers\n- At the beginning\n\n### Steps\n- Greet the user and ask for their name\n- Ask the user how you can help them today\n</code></pre>"},{"location":"playbook-types/#react-playbooks","title":"ReAct Playbooks","text":"<p>ReAct playbooks leverage the LLM's reasoning capabilities through a descriptive prompt. They are ideal for:</p> <ul> <li>Complex problem-solving tasks</li> <li>Research and information gathering</li> <li>Dynamic planning</li> <li>Situations requiring flexible, adaptive behavior</li> </ul> <pre><code>## ResearchProduct\nResearch information about a product the user is interested in.\n\nSearch for detailed product information, customer reviews, \npricing data, and comparisons with similar products. Analyze \nthe information to provide a comprehensive overview that \nhelps the user make an informed decision.\n</code></pre>"},{"location":"playbook-types/#python-playbooks","title":"Python Playbooks","text":"<p>Python playbooks give you the full power of Python for complex logic and external integrations. They are ideal for:</p> <ul> <li>Complex calculations</li> <li>Data processing and transformation</li> <li>Integration with external systems and APIs</li> <li>Implementing business logic</li> </ul> <pre><code>```python\n@playbook\nasync def CalculateShipping(weight: float, destination: str) -&gt; float:\n    \"\"\"Calculate shipping costs based on weight and destination.\"\"\"\n    base_rate = 5.99\n\n    # Apply weight multiplier\n    weight_cost = weight * 0.5\n\n    # Apply destination surcharge\n    destination_surcharge = get_destination_surcharge(destination)\n\n    return base_rate + weight_cost + destination_surcharge\n```\n</code></pre>"},{"location":"playbook-types/#mixing-playbook-types","title":"Mixing Playbook Types","text":"<p>One of the powerful features of Playbooks AI is the ability to mix different types of playbooks within the same agent or program. This allows you to define your agent's behavior in a flexible and modular way.</p>"},{"location":"playbook-types/#next-steps","title":"Next Steps","text":"<p>Explore each playbook type in detail:</p> <ul> <li>Markdown Playbooks - For structured, step-by-step flows</li> <li>ReAct Playbooks - For reasoning-based, adaptive behavior</li> <li>Python Playbooks - For complex logic and integrations</li> </ul> <p>Also see:</p> <ul> <li>Exported and Public Playbooks - For multi-agent systems</li> <li>Multi-Agent Programming - For creating multi-agent systems</li> <li>Raw Prompt Playbooks - For full control over prompts</li> </ul>"},{"location":"playbook-types/builtin-playbooks/","title":"Built-in Playbooks","text":"<p>Playbooks AI provides a set of built-in playbooks that are available to every agent without requiring explicit import or definition. These playbooks handle common operations like communication, artifact management, and program control flow.</p>"},{"location":"playbook-types/builtin-playbooks/#overview","title":"Overview","text":"<p>Built-in playbooks fall into two categories:</p> <ol> <li>Public Playbooks - Available for use in your playbooks (e.g., <code>Say</code>, <code>SendMessage</code>, <code>SaveArtifact</code>)</li> <li>Hidden/Internal Playbooks - Used internally by the system (marked with <code>hidden=True</code>)</li> </ol>"},{"location":"playbook-types/builtin-playbooks/#available-built-in-playbooks","title":"Available Built-in Playbooks","text":""},{"location":"playbook-types/builtin-playbooks/#saytarget-str-message-str","title":"<code>Say(target: str, message: str)</code>","text":"<p>Sends a message to a specified target (agent or user).</p> <p>Example usage: <pre><code>### Steps\n- Welcome the user\n- Ask user for account number\n- Ask Account Management Agent to handle customer's account inquiry\n</code></pre></p>"},{"location":"playbook-types/builtin-playbooks/#sendmessagetarget_agent_id-str-message-str","title":"<code>SendMessage(target_agent_id: str, message: str)</code>","text":"<p>(Hidden/Internal Playbook) Internal implementation of <code>Say</code></p>"},{"location":"playbook-types/builtin-playbooks/#waitformessagesource_agent_id-str-str-none","title":"<code>WaitForMessage(source_agent_id: str) -&gt; str | None</code>","text":"<p>(Hidden/Internal Playbook)</p> <p>Waits for a message from a specific agent or user. This is a low-level communication primitive typically used internally for agent-to-agent coordination.</p> <p>For example, when executing a step like <code>\"Ask user for account number\"</code>, the playbook will send a message to the user using <code>SendMessage(\"human\", \"What is your account number?\")</code> and wait for the user's response using <code>WaitForMessage(\"human\")</code>.</p>"},{"location":"playbook-types/builtin-playbooks/#saveartifactartifact_name-str-artifact_summary-str-artifact_content-str","title":"<code>SaveArtifact(artifact_name: str, artifact_summary: str, artifact_content: str)</code>","text":"<p>Saves data as a named artifact for later retrieval.</p> <p>Example: <pre><code>### Steps\n- Generate a detailed analysis report\n- SaveArtifact(\"quarterly_report.md\", \"Q3 2023 Sales Analysis\", generated report)\n- Tell the user the report has been saved as Artifact[\"quarterly_report.md\"]\n</code></pre></p>"},{"location":"playbook-types/builtin-playbooks/#loadartifactartifact_name-str","title":"<code>LoadArtifact(artifact_name: str)</code>","text":"<p>Artifacts are not included in the LLM context by default because they can be large. When you need to operate on the contents of an artifact, load the artifact first. This will yield execution back to the runtime, which will include the artifact in the LLM context and resume playbook execution.</p> <p>Example: <pre><code>### Steps\n- LoadArtifact(\"Q1_report.md\")\n- LoadArtifact(\"Q2_report.md\")\n- LoadArtifact(\"Q3_report.md\")\n- LoadArtifact(\"Q4_report.md\")\n- Analyze the content of the quarterly reports and generate annual report\n- SaveArtifact(\"annual_report.md\", \"Annual Report\", generated annual report)\n</code></pre></p>"},{"location":"playbook-types/builtin-playbooks/#createagentagent_klass-str-kwargs","title":"<code>CreateAgent(agent_klass: str, **kwargs)</code>","text":"<p>Creates and starts a new agent dynamically during runtime.</p> <p>Example: <pre><code>### Steps\n- Create a new SupportAgent with approprate name\n- Ask the support agent to handle customer inquiry\n- Wait for the agent's response\n</code></pre></p>"},{"location":"playbook-types/builtin-playbooks/#invitetomeetingmeeting_id-str-attendees-list","title":"<code>InviteToMeeting(meeting_id: str, attendees: list)</code>","text":"<p>Invites additional agents to an existing meeting for multi-agent collaboration.</p> <p>Example: <pre><code>### Steps\n- Start a meeting with Accountant and CFO\n- Invite Data analyst and Project manager to the meeting\n</code></pre></p>"},{"location":"playbook-types/builtin-playbooks/#loadfilefile_path-str-inline-bool-false-silent-bool-false","title":"<code>Loadfile(file_path: str, inline: bool = False, silent: bool = False)</code>","text":"<p>Loads content from a file in the filesystem. This is used in description placeholders to load reference materials to execute the playbook.</p> <p>Example: <pre><code>## Generate a summary($document)\nThis playbook generates summary of the given document.\nUse the following format: {Loadfile(\"summary-format.txt\")}\n</code></pre></p>"},{"location":"playbook-types/builtin-playbooks/#related-topics","title":"Related Topics","text":"<ul> <li>Markdown Playbooks - Using built-in playbooks in markdown</li> <li>Python Playbooks - Using built-in playbooks in Python</li> <li>Working with Artifacts - More on artifacts</li> <li>Multi-Agent Systems - Communication between agents</li> <li>Variables &amp; Expressions</li> </ul>"},{"location":"playbook-types/external-playbooks/","title":"External Playbooks","text":"<p>External playbooks are operations executed outside the local runtime. They behave like callable playbooks but do not call back into Playbooks.</p> <p>Examples:</p> <ul> <li>MCP tools exposed by remote servers (see Agents &gt; MCP Agents)</li> <li>HTTP APIs of external AI agents built with other frameworks</li> <li>(future) Exposed methods from an AI agent communicting using the A2A (Agent-to-Agent) protocol</li> </ul> <p>Usage:</p> <ul> <li>Define an agent with <code>metadata.remote</code> of type <code>mcp</code> or point to an API</li> <li>Call its public tools/playbooks like any other playbook</li> </ul> <p>Notes:</p> <ul> <li>External playbooks do not call Playbooks playbooks</li> <li>Handle authentication and transport per provider</li> </ul>"},{"location":"playbook-types/external-playbooks/#see-also","title":"See also","text":"<ul> <li>MCP Agents</li> <li>Playbooks Protocol</li> </ul>"},{"location":"playbook-types/markdown-playbooks/","title":"Markdown Playbooks","text":"<p>Define prescribed workflows in natural language with clear triggers and steps.</p>"},{"location":"playbook-types/markdown-playbooks/#overview","title":"Overview","text":"<p>Markdown playbooks are ideal for:</p> <ul> <li>Prescribed business processes with clear steps</li> <li>Customer service workflows</li> <li>Support scripts</li> <li>Situations where the agent should follow a specific, predefined flow</li> </ul>"},{"location":"playbook-types/markdown-playbooks/#structure","title":"Structure","text":"<p>A markdown playbook follows this structure:</p> <pre><code>## PlaybookName\nPlaybook description\n\n### Triggers\n- Trigger condition 1\n- Trigger condition 2\n\n### Steps\n- Step 1\n- Step 2\n- Step 3\n\n### Notes\n- Note 1\n- Note 2\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#playbook-definition","title":"Playbook definition","text":"<p>The playbook is defined with a second-level heading (<code>##</code>) followed by the playbook name. By convention, playbook names use PascalCase (e.g., <code>GreetCustomer</code>, <code>ProcessOrder</code>), but they can be any text (e.g. <code>greet the customer</code>, <code>process_order</code>).</p> <p>A description should follow the playbook name, explaining what the playbook does and when it should be used.</p>"},{"location":"playbook-types/markdown-playbooks/#parameters","title":"Parameters","text":"<p>Playbooks can accept parameters, which are indicated in the playbook name:</p> <pre><code>## CalculateDiscount($total, $membership_level)\nThis playbook calculates the appropriate discount based on the total order value and membership level.\n</code></pre> <p>These parameters will be available as variables within the playbook.</p>"},{"location":"playbook-types/markdown-playbooks/#description-placeholders","title":"Description placeholders","text":"<p>Playbook descriptions can include dynamic content using placeholder Python expressions with the <code>{expression}</code> syntax. This allows descriptions to be customized at runtime based on the current state and context.</p> <p> Description placeholders are resolved when the playbook begins execution and are not re-evaluated during the execution of the playbook.</p>"},{"location":"playbook-types/markdown-playbooks/#basic-syntax","title":"Basic syntax","text":"<p>Use curly braces to embed expressions in descriptions:</p> <pre><code>## ProcessOrder\nThis playbooks processes order {$order_id} for customer {$customer_name}\n</code></pre> <p>The placeholders are resolved when the playbook is executed, showing the actual values to the LLM.</p>"},{"location":"playbook-types/markdown-playbooks/#what-you-can-use-in-placeholders","title":"What you can use in placeholders","text":""},{"location":"playbook-types/markdown-playbooks/#variables","title":"Variables","text":"<p>Reference any variable from the current state: <pre><code>## ReviewTransaction\nReview transaction {$transaction_id} with amount ${$amount}\n</code></pre></p> <p>Note: The <code>$</code> prefix is optional - both <code>{$order_id}</code> and <code>{order_id}</code> work.</p>"},{"location":"playbook-types/markdown-playbooks/#playbook-calls","title":"Playbook calls","text":"<p>Call other playbooks to generate dynamic content. No need to await the calls. <pre><code>## Answer questions about quarterly summaries\nThis playbook answers questions about quarterly summaries.\nQ1: {QuarterlySummary(\"Q1\")}\nQ2: {QuarterlySummary(\"Q2\")} \nQ3: {QuarterlySummary(\"Q3\")}\nQ4: {QuarterlySummary(\"Q4\")}\n\n### Steps\n...\n</code></pre></p>"},{"location":"playbook-types/markdown-playbooks/#python-expressions","title":"Python expressions","text":"<p>Use any valid Python expression: <pre><code>## AnalyzePerformance\nPerformance score: {round($score * 100, 2)}%\nStatus: {\"Good\" if $score &gt; 0.8 else \"Needs Improvement\"}\nItems to process: {len([x for x in $items if x.active])}\n</code></pre></p>"},{"location":"playbook-types/markdown-playbooks/#special-variables","title":"Special variables","text":"<p>Access agent information and current execution context: <pre><code>## DebugInfo\nCurrent agent: {agent.klass}\nExecuting call: {current_playbook_call}\nFull state: {agent.state}\n</code></pre></p>"},{"location":"playbook-types/markdown-playbooks/#how-it-works","title":"How it works","text":"<ol> <li>When a playbook is executed, the description is scanned for <code>{expression}</code> patterns</li> <li> <p>Each expression is evaluated in the current context with access to:</p> <ul> <li>All state variables</li> <li>All available playbooks and functions</li> <li>The agent object and its methods</li> <li>Standard Python built-ins</li> </ul> </li> <li> <p>The resolved values replace the placeholders in the description shown to the LLM</p> </li> <li>The original playbook description remains unchanged for future invocations</li> </ol>"},{"location":"playbook-types/markdown-playbooks/#triggers","title":"Triggers","text":"<p>The <code>### Triggers</code> section defines the conditions under which the playbook should execute. The playbook will run when any of the listed triggers are met.</p> <p>Common trigger types include:</p>"},{"location":"playbook-types/markdown-playbooks/#temporal","title":"Temporal","text":"<pre><code>### Triggers\n- At the beginning\n- When program starts\n- After 5 minutes\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#user-interaction","title":"User interaction","text":"<pre><code>### Triggers\n- When user provides their email\n- When user asks about pricing\n- When user wants to speak to a human\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#statebased","title":"State\u2011based","text":"<pre><code>### Triggers\n- When $balance becomes negative\n- When $cart_total exceeds 100\n- When $attempts is greater than 3\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#execution-flow","title":"Execution flow","text":"<pre><code>### Triggers\n- After calling VerifyIdentity\n- Before calling ProcessPayment\n- When CheckoutProcess fails\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#steps","title":"Steps","text":"<p>The <code>### Steps</code> section contains a list of steps to execute, in order. Each step is a bullet point that describes an action to take:</p> <pre><code>### Steps\n- Greet the user and ask for their name\n- $name = user's response\n- If $name is empty\n  - Ask for their name again\n- Tell the user \"Hello, $name! How can I help you today?\"\n</code></pre> <p>Steps can include:</p>"},{"location":"playbook-types/markdown-playbooks/#imperative-actions","title":"Imperative actions","text":"<pre><code>- Greet the user\n- Ask the user for their order number\n- Tell the user their order status\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#variable-assignments","title":"Variable assignments","text":"<pre><code>- $total = $price * $quantity\n- $shipping_cost = CalculateShipping($weight, $destination)\n- Extract $relevant_info from the search results\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#conditional-logic","title":"Conditional logic","text":"<pre><code>- If $order_total &gt; 100\n  - Apply free shipping\n- If user is not satisfied\n  - Offer a discount\n  - Ask if they want to speak with a manager\n- Otherwise\n  - Thank them for their feedback\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#loops","title":"Loops","text":"<pre><code>- While conversation is active\n  - Wait for user input\n  - Respond appropriately\n- For each $product in $cart\n  - Calculate $product_total\n  - Add $product_total to $grand_total\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#playbook-calls_1","title":"Playbook calls","text":"<pre><code>- ValidateEmail($email)\n- $shipping_cost = CalculateShipping($weight, $destination)\n- ProcessPayment($order_total)\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#control-flow","title":"Control flow","text":"<pre><code>- End program\n- Return $result\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#notes","title":"Notes","text":"<p>The <code>### Notes</code> section provides additional guidance or rules for the playbook's execution:</p> <pre><code>### Notes\n- Maintain a professional tone throughout the conversation\n- If the user mentions a competitor, highlight our unique advantages\n- If the user is from California, mention that we're compliant with CCPA\n</code></pre> <p>Notes are used to handle exceptions, provide style guidance, or specify business rules that apply throughout the playbook.</p>"},{"location":"playbook-types/markdown-playbooks/#example","title":"Example","text":"<p>Here's a complete example of a markdown playbook for handling order status inquiries:</p> <pre><code>## CheckOrderStatusFlow($authToken)\nCheck the status of an order.\n\n### Trigger\n- When the user is authenticated and requests order status\n\n### Steps\n- Ask user for $orderId\n- $orderStatus = GetOrderStatus($orderId)\n- Extract $expectedDeliveryDate from $orderStatus\n- Say(\"Your order {$orderId} is expected to be delivered on {$expectedDeliveryDate}.\")\n\n### Notes\n- The $orderStatus dictionary includes the keys: orderId, expectedDeliveryDate.\n- Always confirm that $authToken is valid before calling GetOrderStatus.\n</code></pre>"},{"location":"playbook-types/markdown-playbooks/#best-practices","title":"Best practices","text":"<ol> <li>Be specific and clear: Write steps that clearly describe what the agent should do.</li> <li>Use variables consistently: Use the <code>$</code> prefix for all variables and maintain consistent naming.</li> <li>Handle edge cases: Include steps for handling unexpected user responses or system failures.</li> <li>Break down complex tasks: Keep steps simple and focused on a single action.</li> <li>Use playbook calls: Factor out reusable logic into separate playbooks that can be called.</li> <li>Provide helpful notes: Use the Notes section to guide the agent on tone, exceptions, and business rules.</li> <li>Use meaningful trigger conditions: Make trigger conditions specific to ensure playbooks run at the right time.</li> </ol>"},{"location":"playbook-types/markdown-playbooks/#related-topics","title":"Related topics","text":"<ul> <li>ReAct Playbooks - For less structured, reasoning-based approaches</li> <li>Python Playbooks - For complex logic and integrations</li> <li>Calling Playbooks - How to call one playbook from another</li> <li>Adding Triggers - More about trigger types and usage</li> </ul>"},{"location":"playbook-types/python-playbooks/","title":"Python Playbooks","text":"<p>Implement complex logic in Python and call playbooks in both directions.</p>"},{"location":"playbook-types/python-playbooks/#overview","title":"Overview","text":"<ul> <li>A Python playbook is an async function decorated with <code>@playbook</code></li> <li>It can call markdown or Python playbooks, and be called by them</li> <li>You can add <code>triggers=[...]</code> and <code>public=True</code> when needed</li> </ul> <p> Consider using an MCP server to implement simple python based tools that do not need trigger support or the ability to call Markdown playbooks.</p>"},{"location":"playbook-types/python-playbooks/#create-a-python-playbook","title":"Create a Python playbook","text":"<p>Define an async function decorated with <code>@playbook</code> inside a <code>``python block in your</code>.pb`:</p> <pre><code>@playbook\nasync def calculate_shipping(weight: float, destination: str) -&gt; float:\n    \"\"\"\n    Calculate shipping costs based on weight and destination.\n\n    Args:\n        weight (float): The weight of the package\n        destination (str): The destination of the package\n\n    Returns:\n        float: The shipping cost\n    \"\"\"\n    ...    \n    return base_rate + weight_cost + destination_surcharge\n</code></pre>"},{"location":"playbook-types/python-playbooks/#the-playbook-decorator","title":"The @playbook decorator","text":"<p>The <code>@playbook</code> decorator registers a Python function as a playbook that can be called by other playbooks or triggered based on conditions.</p> <pre><code>@playbook(\n    triggers=[\"When user provides payment information\"],\n    public=True\n)\nasync def validate_payment_info(amount: float, card_info: dict) -&gt; bool:\n    \"\"\"\n    Validate payment information.\n\n    Args:\n        amount (float): The amount of the payment\n        card_info (dict): The payment information\n\n    Returns:\n        bool: True if the payment information is valid, False otherwise\n    \"\"\"\n    ...\n    return True\n</code></pre>"},{"location":"playbook-types/python-playbooks/#decorator-parameters","title":"Decorator parameters","text":"<p>The <code>@playbook</code> decorator accepts several parameters that control the playbook's behavior and metadata.</p>"},{"location":"playbook-types/python-playbooks/#reserved-parameters","title":"Reserved parameters","text":"<ul> <li><code>triggers</code>: A list of trigger conditions (as strings) that will cause the playbook to execute</li> </ul>"},{"location":"playbook-types/python-playbooks/#standard-metadata","title":"Standard metadata","text":"<ul> <li><code>public</code>: A boolean indicating whether the playbook should be available to other agents to call</li> <li><code>export</code>: A boolean indicating whether the playbook's implementation can be exported to other agents</li> <li><code>remote</code>: A dictionary containing remote service configuration</li> <li><code>type</code>: mcp, playbooks, etc.</li> <li><code>url</code>: Remote service URL</li> <li><code>transport</code>: transport protocol to use for the remote service</li> </ul>"},{"location":"playbook-types/python-playbooks/#custom-metadata","title":"Custom metadata","text":"<p>All other keyword arguments become metadata attached to the playbook. This metadata can be used for documentation, configuration, etc.</p> <p>See Metadata for more details.</p>"},{"location":"playbook-types/python-playbooks/#error-handling","title":"Error handling","text":"<p>When called from markdown playbooks, return a user\u2011readable error string on failure; the LLM will handle it. Catch exceptions inside Python playbooks. Between Python playbooks, you may raise exceptions and handle them as usual.</p>"},{"location":"playbook-types/python-playbooks/#related-topics","title":"Related topics","text":"<ul> <li>Markdown Playbooks - For structured, step-by-step flows</li> <li>ReAct Playbooks - For reasoning-based, adaptive behavior</li> </ul>"},{"location":"playbook-types/raw-prompt-playbooks/","title":"Raw Prompt Playbooks","text":"<p>Use a raw prompt when you need full control over the prompt sent to the LLM. This playbook type bypasses compiler enrichment and sends playbook description verbatim after any placeholder substitutions.</p> <p>To make a raw prompt playbook, add <code>execution_mode: raw</code> to the playbook description and do not include any steps.</p>"},{"location":"playbook-types/raw-prompt-playbooks/#example","title":"Example","text":"<pre><code>## GetTicketCategory \u2190 This is a raw prompt playbook\nexecution_mode: raw\n\nHere is customer message in a support ticket: {$ticket_message}\nYou will categorize this ticket in one of the following categories:\n- Technical Support\n- Billing\n- Account Management\n- Other\n\nRespond with just the category of the ticket and nothing else.\nThe ticket category is:\n\n\n## EnrichTicketInfo($ticket) \u2190 This is a regular markdown playbook\n\n### Steps\n- $ticket.category = GetTicketCategory($ticket.message)\n- SaveTicket($ticket)\n</code></pre> <p>When to use:</p> <ul> <li>Specific single shot tasks</li> <li>When you want full control over what is sent to the LLM</li> </ul> <p>Considerations:</p> <ul> <li>You lose some safety checks and verification of how the prompt is executed</li> <li>Prefer standard markdown playbooks for control and observability</li> </ul>"},{"location":"playbook-types/raw-prompt-playbooks/#execution-context","title":"Execution context","text":"<p>Raw playbooks do not add any execution context to LLM calls. The runtime sends exactly your description (prompt) as-is, with no automatic conversation summaries, state, or helper context.</p> <ul> <li>If your prompt needs variables, prior state, or computed values, include them explicitly using description placeholders.</li> </ul> <p> Raw playbooks make a single LLM call with no loop or planning. Ensure your description, i.e. prompt, contains all necessary instructions and context.</p> <p>See also: ReAct Playbooks for the context-enriched think\u2013act loop execution flow.</p> <p>Related:</p> <ul> <li>Automating Context Engineering</li> </ul>"},{"location":"playbook-types/raw-prompt-playbooks/#description-placeholders","title":"Description placeholders","text":"<p>Use <code>{expression}</code> placeholders in the playbook description to inject execution context.</p> <p>See Markdown Playbooks - Description placeholders for full details on placeholder syntax and capabilities.</p>"},{"location":"playbook-types/react-playbooks/","title":"ReAct Playbooks","text":"<p>Let the LLM reason and plan the next action in a think\u2013act loop when steps are not known in advance.</p>"},{"location":"playbook-types/react-playbooks/#overview","title":"Overview","text":"<p>ReAct playbooks are ideal for:</p> <ul> <li>Complex problem-solving tasks</li> <li>Deep research and information gathering tasks</li> <li>Dynamic planning</li> <li>Tasks where the exact steps aren't known in advance</li> </ul>"},{"location":"playbook-types/react-playbooks/#structure","title":"Structure","text":"<p>A ReAct playbook is defined as a standard markdown playbook, but without the <code>### Steps</code> section:</p> <pre><code>## PlaybookName\nDetailed description or prompt for the task, goals, and constraints. Do not use markdown in the prompt.\n\n### Triggers\n- Trigger condition 1\n- Trigger condition 2\n</code></pre> <p>The key difference is that ReAct playbooks do not include a <code>### Steps</code> section. Instead, the system provides a default ReAct execution flow that implements a \"think - plan - select tool - execute tool - interact - evaluate\" cycle.</p> <p> Do not use markdown in the prompt for ReAct playbooks because that will interfere with the playbook program's structure that uses #, ## and ### headings. Use xml tags like <code>&lt;output_format&gt;</code>, <code>&lt;planning_rules&gt;</code>,  <code>&lt;style_guide&gt;</code>, etc. for defining various parts of the prompt.</p>"},{"location":"playbook-types/react-playbooks/#playbook-definition","title":"Playbook definition","text":"<p>Like other playbooks, a ReAct playbook is defined with a second-level heading (<code>##</code>) followed by the playbook name.</p> <p>The description that follows the playbook name is much more important in ReAct playbooks, as it serves as the primary instruction set for the LLM. This description should be detailed and clear about:</p> <ol> <li>The objective of the playbook</li> <li>The constraints and requirements</li> <li>The expected output or deliverable</li> <li>Any special considerations or approaches to take</li> </ol>"},{"location":"playbook-types/react-playbooks/#description-placeholders","title":"Description placeholders","text":"<p>Like markdown playbooks, ReAct playbook descriptions support dynamic content using <code>{expression}</code> placeholders.</p> <p>See Markdown Playbooks - Description placeholders for full details on placeholder syntax and capabilities.</p>"},{"location":"playbook-types/react-playbooks/#triggers","title":"Triggers","text":"<p>The <code>### Triggers</code> section works the same way as in standard markdown playbooks, defining the conditions under which the playbook should execute.</p>"},{"location":"playbook-types/react-playbooks/#default-execution-flow","title":"Default execution flow","text":"<p>When a ReAct playbook is executed (i.e., a playbook without explicit steps), the system automatically applies a default ReAct execution flow. This flow is dynamically compiled and added to the playbook at runtime.</p> <p>The default ReAct steps follow this pattern:</p> <pre><code>- Think deeply about the $task to understand requirements\n- Write down $exit_conditions for the task\n- While $exit_conditions are not met:\n  - Analyze current state and progress\n  - Decide what action to take next\n  - Execute the action (tool call, user interaction, computation)\n  - Evaluate results against exit conditions\n- Return final results\n</code></pre>"},{"location":"playbook-types/react-playbooks/#execution-cycle","title":"Execution cycle","text":"<p>The ReAct loop enables the LLM to:</p> <ol> <li>Understand - Analyze the task requirements deeply</li> <li>Define Success - Establish clear exit conditions for task completion</li> <li>Iterate - Loop through a cycle of analysis, action, and evaluation</li> <li>Act - Execute appropriate actions (tool calls, user interactions, computations)</li> <li>Evaluate - Check progress against exit conditions</li> <li>Complete - Return final results when exit conditions are met</li> </ol>"},{"location":"playbook-types/react-playbooks/#example","title":"Example","text":"<p>Here's an example of a ReAct playbook for deep product research:</p> <pre><code>## ResearchProduct\nThis playbook conducts comprehensive research on a product specified by the user.\n\nUse WebSearch to find relevant information. Analyze the data critically and present findings in a clear, organized format. Prioritize recent sources (within the last year if possible) and reputable websites.\n\n&lt;planning_rules&gt;\n    - Always start by determining the exact product to research\n    - Create a structured research plan with specific queries\n    - Perform multiple searches with different queries to get comprehensive information\n    - Group searches by category (general info, reviews, comparisons)\n    - Verify information across multiple sources when possible\n    - If conflicting information is found, note the discrepancy and evaluate source credibility\n&lt;/planning_rules&gt;\n\n&lt;style_guide&gt;\n    - Write in a neutral, objective tone\n    - Use clear headings and subheadings for organization\n    - Present pros and cons in balanced fashion\n    - Support claims with evidence from research\n    - When providing your recommendation, clearly explain your reasoning\n&lt;/style_guide&gt;\n\n&lt;output_format&gt;\n    # Product Research: [Product Name]\n\n    ## Overview\n    [General product information]\n\n    ## Features and Specifications\n    [Detailed features]\n\n    ## Customer Sentiment\n    [Analysis of customer reviews]\n\n    ## Competitive Comparison\n    [Comparison with alternatives]\n\n    ## Pros and Cons\n    [Balanced assessment]\n\n    ## Recommendation\n    [Final recommendation with justification]\n&lt;/output_format&gt;\n\n### Triggers\n- When user wants to research a product\n</code></pre>"},{"location":"playbook-types/react-playbooks/#related-topics","title":"Related topics","text":"<ul> <li>Markdown Playbooks - For more structured, step-by-step approaches</li> <li>Python Playbooks - For complex logic and integrations</li> <li>Working with Artifacts - How ReAct playbooks can create and store data</li> <li>Automating Context Engineering</li> </ul>"},{"location":"playbooks-language/","title":"Playbooks Languages","text":"<p>Playbooks is a comprehensive programming system designed specifically for building AI agents and LLM based automation.</p>"},{"location":"playbooks-language/#high-level-playbooks-language-pb","title":"High-Level: Playbooks Language (.pb)","text":"<p>The Playbooks Language is a human-readable, semantically interpreted programming language that allows developers to define agent behavior using natural language within a structured markdown format, combined with Python code. This high-level language prioritizes readability, maintainability, and ease of authoring.</p> <p>Learn more about Playbooks Language \u2192</p>"},{"location":"playbooks-language/#low-level-playbooks-assembly-language-pbasm","title":"Low-Level: Playbooks Assembly Language (.pbasm)","text":"<p>The Playbooks Assembly Language (PBASM) is the low-level compilation target that optimizes code execution for Large Language Models. Just as traditional programming languages compile to assembly for CPUs, Playbooks Language compiles to PBASM for LLM execution engines.</p> <p>Learn more about Playbooks Assembly Language \u2192</p>"},{"location":"playbooks-language/#playbooks-as-the-common-language-specification-cls-and-common-language-runtime-clr-for-ai-applications","title":"Playbooks as the Common Language Specification (CLS) and Common Language Runtime (CLR) for AI Applications","text":"<p>Playbooks Assembly Language and runtime can act as a the Common Language Specification (CLS) and Common Language Runtime (CLR) for AI Applications.</p> <p>Learn more \u2192</p>"},{"location":"playbooks-language/metadata/","title":"Metadata","text":"<p>Metadata in Playbooks AI allows you to attach structured information to agents and playbooks. This metadata can be used for documentation, configuration, tooling integration, and agent discovery.</p>"},{"location":"playbooks-language/metadata/#overview","title":"Overview","text":"<p>Metadata can be specified on:</p> <ul> <li>Agents - Information about the agent itself</li> <li>Playbooks - Information about individual playbooks</li> </ul> <p>The metadata system is designed to be flexible and extensible, allowing you to add custom fields that make sense for your use case.</p>"},{"location":"playbooks-language/metadata/#agent-metadata","title":"Agent Metadata","text":"<p>Agent metadata is specified immediately after the agent heading:</p> <pre><code># Accountant\nframework: GAAP\nspecialization:\n  - accounting\n  - tax\nauthor: John Doe\nThis is an accountant agent that can help with accounting tasks.\n</code></pre>"},{"location":"playbooks-language/metadata/#metadata-for-markdown-playbooks","title":"Metadata for Markdown Playbooks","text":"<p>In markdown playbooks, metadata is specified directly in the description area of agents and playbooks using YAML-like syntax. Example:</p> <pre><code>## PrepareTaxReturn\npriority: high\ncategory: tax-preparation\nestimated_time: 30 minutes\nThis playbook prepares and submits tax returns following proper procedures.\n</code></pre>"},{"location":"playbooks-language/metadata/#metadata-for-python-playbooks","title":"Metadata for Python Playbooks","text":"<p>For Python playbooks, metadata is specified directly on the <code>@playbook</code> decorator. All keyword arguments except <code>triggers</code> are treated as metadata. Example:</p> <pre><code>@playbook(\n    public=True, \n    export=True, \n    author=\"Amol Kelkar\",\n    category=\"financial\",\n    version=\"1.0\"\n)\nasync def CalculateROI(investment: float, returns: float) -&gt; float:\n    \"\"\"Calculate return on investment.\"\"\"\n    return (returns - investment) / investment * 100\n</code></pre>"},{"location":"playbooks-language/metadata/#known-metadata-fields","title":"Known Metadata Fields","text":"<p>Although any fields can be added as metadata, here are the fields that are processed by Playbooks.</p> <ul> <li><code>public</code>: Whether the playbook is public</li> <li><code>export</code>: Whether the playbook's implementation can be exported</li> <li><code>remote</code>: Remote service configuration</li> <li><code>type</code>: mcp, playbooks, etc.</li> <li><code>url</code>: Remote service URL</li> <li><code>transport</code>: transport protocol to use for the remote service</li> </ul> <p>Example: <pre><code>public: true\nexport: true\nremote:\n  type: mcp\n  transport: streamable-http\n  url: http://localhost:8088/mcp\n</code></pre></p>"},{"location":"playbooks-language/metadata/#compilation-behavior","title":"Compilation Behavior","text":"<p>When Playbooks Language (<code>.pb</code>) files are compiled to Playbooks Assembly Language (<code>.pbasm</code>), the compiler intelligently processes metadata:</p>"},{"location":"playbooks-language/metadata/#metadata-extraction-and-organization","title":"Metadata Extraction and Organization","text":"<p>The compiler gathers various metadata items specified in the description area and consolidates them under a <code>metadata:</code> section:</p> <p>Before compilation (example.pb): <pre><code># Accountant\npublic: true\nexport: true\nThis is an accountant agent that can help with accounting tasks.\nauthor: John Doe\n</code></pre></p> <p>After compilation (example.pbasm): <pre><code># Accountant\nmetadata:\n  public: true\n  export: true\n  author: John Doe\n---\nThis is an accountant agent that can help with accounting tasks.\n</code></pre></p>"},{"location":"playbooks-language/metadata/#related-topics","title":"Related Topics","text":"<ul> <li>Playbooks Language - Overall language structure</li> <li>Python Playbooks - Python-specific features</li> <li>Playbooks Assembly Language - Compilation target</li> <li>Multi-Agent Systems - Using metadata for agent coordination </li> <li>Exported and Public Playbooks</li> </ul>"},{"location":"playbooks-language/playbooks-assembly-language/","title":"Playbooks Assembly Language (PBAsm)","text":"<p>The Playbooks Assembly Language (PBAsm) is a low-level, structured representation of Playbooks programs designed specifically for execution by Large Language Models. Just as traditional assembly languages use instruction sets optimized for CPU architectures, PBAsm uses an instruction set optimized for the unique capabilities and characteristics of LLMs as execution engines.</p>"},{"location":"playbooks-language/playbooks-assembly-language/#the-llm-as-cpu-architecture","title":"The LLM as CPU Architecture","text":""},{"location":"playbooks-language/playbooks-assembly-language/#traditional-cpu-vs-llm-execution-engine","title":"Traditional CPU vs LLM Execution Engine","text":"CPU Executing Assembly/Binary code LLM Executing PBAsm code Instruction Format Binary opcodes (e.g., <code>0x89 0xE5</code> for MOV EBP, ESP) Semantic instructions (e.g., <code>01:EXE Var[$name:str, \"Alice\"]</code>) Basic Instructions MOV, ADD, JMP, CALL, RET, CMP EXE, TNK, QUE, CND, CHK, YLD, JMP, RET Memory Model Direct memory addresses, registers (EAX, EBX, ESP) Short term memory with variables (<code>$name:str</code>, <code>$count:int</code>), Long term memory system Variable Assignment <code>MOV [0x1000], 42</code> (write to memory address) <code>Var[$count:int, 42]</code> (semantic variable binding) Function Calls <code>PUSH params; CALL 0x4000; POP result</code> <code>$result = FunctionName(param=$value); YLD call</code> Control Flow <code>CMP EAX, 0; JE label</code> (compare and jump) <code>02:CND If $name is provided</code> (semantic condition) Loops <code>loop_start: DEC ECX; JNZ loop_start</code> <code>03:CND While $i &lt; 10</code> with nested steps Stack Operations <code>PUSH EAX; POP EBX</code> (explicit stack manipulation) Implicit call stack managed by runtime Return Values Store in EAX register by convention <code>04:RET $result</code> (explicit return statement) Interrupts INT 0x80 (system call), hardware IRQ <code>Trigger[\"PlaybookName:01:EVT\"]</code> (semantic events) Yielding Control Context switch via OS scheduler <code>YLD user/call/exit</code> (explicit yield reasons) Line Addressing Absolute/relative addresses (0x4000, +10) Hierarchical numbering (01, 01.01, 01.01.01) Conditional Execution Flag-based (ZF, CF, OF) after CMP Natural language conditions evaluated by LLM Data Types Primitive (byte, word, dword, float) Semantic types (str, int, float, bool, list, dict, artifact, memory) Error Handling Segfault, divide by zero, invalid opcode Graceful degradation, runtime validation of outputs Debugging GDB breakpoints, register inspection VSCode debugger - step debugging, variable inspection Side Effects Direct I/O port access, memory writes Queued operations via QUE, verified by runtime Compilation Source \u2192 AST \u2192 Machine code Playbooks \u2192 PBAsm \u2192 Runtime Context \u2192 LLM tokens Parallelism Out-of-order execution, SIMD Queued operations can batch (multiple QUE before YLD) State Persistence CPU registers reset on context switch Variables persist across YLD operations Program Counter EIP/RIP register points to next instruction Runtime tracks current playbook line number (e.g. OrderStatus:01.03) Subroutines CALL pushes return address, RET pops Playbook calls with QUE, across agents Execution Context CPU state (registers, flags, stack) Conversation history, variable state, queued ops"},{"location":"playbooks-language/playbooks-assembly-language/#the-pbasm-instruction-set","title":"The PBAsm Instruction Set","text":"<p>PBAsm's instruction set is specifically designed for these LLM characteristics:</p>"},{"location":"playbooks-language/playbooks-assembly-language/#core-instructions","title":"Core Instructions","text":"Instruction Purpose LLM Operation Runtime Verification EXE Execute imperative action/assignment Process semantic instruction, update state Parse variable assignments, validate state changes TNK Think deeply step by step Engage reasoning capabilities before proceeding Verify structured thinking output QUE Queue playbook/function call Prepare asynchronous operation Parse function calls with parameters CND Conditional/loop construct Evaluate semantic conditions and control flow Track conditional logic and execution paths CHK Apply contextual note/rule Incorporate business rules into context Verify rule application RET Return from playbook Complete function execution with optional value Parse return values JMP Jump to specific line Transfer execution control Validate line number targets YLD Yield control to runtime Pause execution, transfer control Parse yield targets (user/call/return/exit)"},{"location":"playbooks-language/playbooks-assembly-language/#yield-reasons","title":"Yield Reasons","text":"<p>The YLD instruction includes specific reasons that define why the LLM is yielding control:</p> <ul> <li><code>YLD call</code> - Execute queued function calls (including Say() calls)</li> <li><code>YLD user</code> - Wait for user input (only after asking for input)</li> <li><code>YLD agent</code> - Wait for input from another agent</li> <li><code>YLD meeting</code> - Wait for input from a meeting you are participating in</li> <li><code>YLD exit</code> - Terminate the program</li> </ul>"},{"location":"playbooks-language/playbooks-assembly-language/#structured-output-protocol","title":"Structured Output Protocol","text":"<p>Unlike traditional assembly that modifies CPU registers, PBAsm instructions produce structured outputs that the runtime can parse and verify:</p>"},{"location":"playbooks-language/playbooks-assembly-language/#variable-operations","title":"Variable Operations","text":"<p><pre><code>Var[$name, &lt;value&gt;]\n</code></pre> Similar to how assembly instructions modify CPU registers, but operates on named variables with semantic meaning. Variables must include type annotations: <code>$varname:type</code> where type is one of: <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>list</code>, <code>dict</code>, <code>artifact</code>.</p>"},{"location":"playbooks-language/playbooks-assembly-language/#function-calls","title":"Function Calls","text":"<pre><code>$result = PlaybookName(param1, param2=$value2) \u2190 Standard Python syntax\n$result = Call PlaybookName with param1, param2=$value2 \u2190 Natural language syntax\nGet $result from PlaybookName \u2190 Implicit argument passing\n$result = PlaybookName(task user specified, details=details of the task) \u2190 Natural language arguments\n</code></pre>"},{"location":"playbooks-language/playbooks-assembly-language/#trigger-events-llm-interrupts","title":"Trigger Events (LLM Interrupts)","text":"<p><pre><code>### Triggers\n- T1:BGN When program starts\n</code></pre> PBAsm's interrupt system - the LLM can signal semantic events that interrupt normal execution flow and trigger other playbooks to execute, similar to how hardware/software interrupts work in traditional CPUs.</p>"},{"location":"playbooks-language/playbooks-assembly-language/#compilation-from-playbooks-language","title":"Compilation from Playbooks Language","text":""},{"location":"playbooks-language/playbooks-assembly-language/#source-format-playbooks-language","title":"Source Format (Playbooks Language)","text":"<pre><code>## GreetUser\nThis playbook greets the user and asks for their name.\n\n### Triggers\n- At the beginning\n\n### Steps\n- Greet the user and ask for their name\n- If name is provided\n  - Thank the user by name\n- Otherwise\n  - Ask for their name again\n</code></pre>"},{"location":"playbooks-language/playbooks-assembly-language/#compiled-format-pbasm","title":"Compiled Format (PBAsm)","text":"<pre><code>## GreetUser() -&gt; None\nThis playbook greets the user and asks for their name.\n### Triggers\n- T1:BGN At the beginning\n### Steps\n- 01:QUE Say(Greet the user and ask for their $name:str); YLD user\n- 02:CND If $name is provided\n  - 02.01:QUE Say(Thank the user by $name); YLD call\n- 03:CND Otherwise\n  - 03.01:QUE Say(Ask for their $name:str again); YLD user\n- 04:RET\n</code></pre>"},{"location":"playbooks-language/playbooks-assembly-language/#line-numbering-and-control-flow","title":"Line Numbering and Control Flow","text":"<p>PBAsm uses a hierarchical line numbering system that enables precise control flow:</p> <ul> <li>Top-level steps: <code>01</code>, <code>02</code>, <code>03</code></li> <li>Sub-steps: <code>01.01</code>, <code>01.02</code>, <code>01.03</code></li> <li>Nested sub-steps: <code>01.01.01</code>, <code>01.01.02</code></li> </ul> <p>This enables: - Precise jumping: <code>JMP 01</code> to return to a specific line (used in loops) - Conditional nesting: Clear structure for if/else and loops - Error recovery: Ability to resume at specific execution points</p>"},{"location":"playbooks-language/playbooks-assembly-language/#trigger-system-llm-interrupts","title":"Trigger System: LLM Interrupts","text":"<p>PBAsm includes a sophisticated interrupt system that leverages the LLM's ability to recognize semantic patterns. Like traditional CPU interrupts, PBAsm triggers can interrupt normal execution flow when specific conditions are met:</p>"},{"location":"playbooks-language/playbooks-assembly-language/#trigger-types","title":"Trigger Types","text":"<ul> <li>BGN (Beginning): Execute when program starts</li> <li>CND (Conditional): Execute when semantic conditions are met</li> <li>EVT (Event): Execute on external events</li> </ul>"},{"location":"playbooks-language/playbooks-assembly-language/#trigger-registration-and-handling","title":"Trigger Registration and Handling","text":"<pre><code>### Triggers\n- T1:CND When user provides their email address\n- T2:BGN At the beginning  \n- T3:EVT When payment processed event is received\n- T4:EVT When Accountant agent is ready with the invoice\n</code></pre> <p>The LLM continuously monitors these semantic conditions during execution. When a trigger condition is met, it interrupts the current playbook execution, saves the current state, and invokes the triggered playbook - much like how a CPU handles interrupts.</p>"},{"location":"playbooks-language/playbooks-assembly-language/#interrupt-handling-flow","title":"Interrupt Handling Flow","text":"<ol> <li>Normal Execution: LLM processes instructions sequentially</li> <li>Condition Detection: After each step, LLM evaluates trigger conditions  </li> <li>Interrupt Signal: If condition is met, LLM signals <code>Trigger[\"PlaybookName:Line:Code\"]</code></li> <li>State Preservation: Current execution context is maintained</li> <li>Handler Invocation: Triggered playbook begins execution</li> <li>Return/Continue: After handling, execution resumes or transfers control</li> </ol> <p>This interrupt-driven architecture enables reactive, event-driven AI systems that can respond to changing conditions without polling - a fundamental advance in AI agent architecture.</p>"},{"location":"playbooks-language/playbooks-assembly-language/#key-patterns-and-best-practices","title":"Key Patterns and Best Practices","text":""},{"location":"playbooks-language/playbooks-assembly-language/#function-call-patterns","title":"Function Call Patterns","text":"<p>Simple function call: <pre><code>01:QUE $result:dict = GetWeather(city=$city); YLD call\n</code></pre></p> <p>Nested function calls (decomposed): <pre><code>01:QUE $temp:str = FuncB(x=$x); YLD call\n02:QUE $result:dict = FuncA(param=$temp); YLD call\n</code></pre></p> <p>Cross-agent calls: <pre><code>01:QUE $weather:dict = WeatherAgent.GetCurrentWeather(zip=98053); YLD call\n</code></pre></p> <p>Batch call processing (concurrent execution): <pre><code>01:EXE Initialize empty $results:dict\n02:CND For each $item in $items:list\n  02.01:QUE ProcessItem(item=$item); do not yield\n03:YLD call to execute all queued calls concurrently\n04:EXE Collect results into $results:dict by item id\n</code></pre></p>"},{"location":"playbooks-language/playbooks-assembly-language/#user-interaction-patterns","title":"User Interaction Patterns","text":"<p>Single question: <pre><code>01:QUE Say(Ask user for their $name:str); YLD user\n</code></pre></p> <p>Multi-turn conversation: <pre><code>01:QUE Say(Welcome and ask how to help); YLD user\n02:QUE Say(Continue conversation to meet criteria); YLD user; done after criteria met\n</code></pre></p> <p>Enqueue multiple messages: <pre><code>01:QUE Say(Present options); no yield needed\n02:QUE Say(Ask user to select one); YLD user\n</code></pre></p>"},{"location":"playbooks-language/playbooks-assembly-language/#metadata-and-public-playbooks","title":"Metadata and Public Playbooks","text":"<p>Agents and playbooks can include metadata in YAML format:</p> <pre><code># AgentName\nmetadata:\n  model: claude-sonnet-4.0\n  author: name@example.com\n---\nAgent description\n\n## PlaybookName\nmetadata:\n  public: true\n---\nPlaybook description\n</code></pre> <p>Public playbooks are exposed for cross-agent communication and included in the generated <code>public.json</code>.</p>"},{"location":"playbooks-language/playbooks-assembly-language/#advantages-of-pbasm","title":"Advantages of PBAsm","text":"<ol> <li>Semantic Precision: Natural language instructions with assembly-like precision</li> <li>Interoperability: Multiple authoring tools can target PBAsm</li> <li>Analysis capability: Static analysis tools can examine PBAsm programs</li> <li>Runtime flexibility: Different LLM runtimes can execute the same PBAsm code</li> <li>Debugging support: Clear execution model enables sophisticated debugging tools</li> <li>Concurrent execution: Support for batched operations and asynchronous calls</li> <li>Cross-agent communication: Built-in support for multi-agent systems</li> </ol>"},{"location":"playbooks-language/playbooks-assembly-language/#conclusion","title":"Conclusion","text":"<p>PBAsm represents a foundational step toward treating LLMs as first-class computational engines with their own optimized instruction sets, enabling the development of reliable, scalable, and maintainable AI agent systems. By providing a structured intermediate representation between natural language and LLM execution, PBAsm enables sophisticated tooling, analysis, and runtime optimization while maintaining the semantic richness that makes LLM-based computing powerful.</p>"},{"location":"playbooks-language/playbooks-assembly-language/#learn-more","title":"Learn More","text":"<p>Explore different types of playbooks:</p> <ul> <li>Markdown Playbooks - How to write playbooks in markdown</li> <li>ReAct Playbooks - How to write playbooks in ReAct</li> <li>Python Playbooks - Using Python functions as playbooks</li> </ul>"},{"location":"playbooks-language/playbooks-language/","title":"Playbooks Language","text":"<p>Define agents with natural language and Python in a structured, verifiable form.</p>"},{"location":"playbooks-language/playbooks-language/#overview","title":"Overview","text":"<p>Use Playbooks Language to:</p> <ul> <li>Write agent logic in a way that's understandable by both humans and AI</li> <li>Seamlessly integrate natural language instructions with Python code</li> <li>Create reusable, modular components that can be composed into complex workflows</li> <li>Implement event-driven behavior through triggers</li> <li>Build multi-agent systems where agents can communicate and collaborate</li> </ul>"},{"location":"playbooks-language/playbooks-language/#program-structure","title":"Program structure","text":"<p>A Playbooks program consists of one or more agents, each containing one or more playbooks. The basic structure follows standard markdown heading conventions:</p> <pre><code># Agent name\nAgent description and overview\n\n```python\n# Python playbooks are defined here using the @playbook decorator\n```\n\n## Playbook name\nPlaybook description\n\n### Triggers\n- Trigger conditions\n\n### Steps\n- Step-by-step instructions\n\n### Notes\n- Additional notes, instructions and rules\n</code></pre> <p>Multiple agents can be defined within a single Playbooks program. These agents can interact with each other. To call a playbook from another agent, use the syntax <code>AgentName.PlaybookName()</code>.</p>"},{"location":"playbooks-language/playbooks-language/#program-components","title":"Program components","text":""},{"location":"playbooks-language/playbooks-language/#1-agent-definition","title":"1. Agent definition","text":"<p>Agents are defined using a top-level heading (<code>#</code>) followed by the agent name and an optional description:</p> <pre><code># Customer Service Agent\nThis agent handles customer service inquiries and guides users through the support process.\n</code></pre> <p>An agent can have multiple playbooks and can include Python code that's accessible to its playbooks.</p>"},{"location":"playbooks-language/playbooks-language/#2-python-functions-as-playbooks","title":"2. Python functions as playbooks","text":"<p>Python functions can be defined as playbooks using the <code>@playbook</code> decorator:</p> <pre><code>@playbook\nasync def CalculateTotal(price: float, quantity: int) -&gt; float:\n    \"\"\"Calculate the total price for a given quantity of items.\"\"\"\n    return price * quantity\n\n@playbook(triggers=[\"When user provides payment information\"])\nasync def ProcessPayment(amount: float, card_info: dict) -&gt; bool:\n    \"\"\"Process a payment transaction.\"\"\"\n    # Payment processing logic\n    return True\n</code></pre> <p> By convention, Playbook names are PascalCase. While Python functions are typically named using snake_case, we suggest using PascalCase for Python playbook names.</p>"},{"location":"playbooks-language/playbooks-language/#3-markdown-playbooks","title":"3. Markdown playbooks","text":"<p>Markdown playbooks are defined using second-level headings (<code>##</code>) followed by the playbook name and an optional description:</p> <pre><code>## GreetCustomer\nThis playbook greets the customer and collects their basic information.\n</code></pre> <p>Playbooks can accept parameters:</p> <pre><code>## CalculateDiscount($total, $membership_level)\nThis playbook calculates the appropriate discount based on the total and membership level.\n</code></pre> <p>Playbooks may include additional metadata:</p> <pre><code>## ValidateCity($city)\npublic: true\nThis playbook validates a city input by the user.\n&lt;output_format&gt;\nThe output is a string of the validated city in \"Austin, TX\" format.\n&lt;/output_format&gt;\n&lt;style_guide&gt;\n- Write in a friendly, conversational tone\n- Use simple language and avoid complex words\n- Keep sentences short and concise\n&lt;/style_guide&gt;\n</code></pre>"},{"location":"playbooks-language/playbooks-language/#4-triggers","title":"4. Triggers","text":"<p>Triggers define when a playbook should execute. They're specified in a section marked by a <code>### Triggers</code> heading. The playbook will execute when any of the triggers are met.</p> <pre><code>### Triggers\n- At the beginning\n- When user provides their name\n- When $order_total exceeds 100\n</code></pre>"},{"location":"playbooks-language/playbooks-language/#5-steps","title":"5. Steps","text":"<p>Steps define the actual logic of a playbook, specified in a section marked by a <code>### Steps</code> heading:</p> <pre><code>### Steps\n- Greet the user and ask for their $age\n- If $age is less than 68\n  - Tell the user about retirement products\n- Otherwise\n  - Tell the user about investment products\n- End program\n</code></pre> <p>Steps support:</p> <ul> <li>Imperative instructions (e.g., <code>Greet the user</code>)</li> <li>Variable assignments (e.g., <code>$total = $price * $quantity</code>, <code>Extract $relevant_info from search results</code>)</li> <li>Conditionals (e.g., <code>If $status is 'approved'</code>, <code>If user is not satisfied with the answer</code>)</li> <li>Loops (e.g., <code>While conversation is active</code>, <code>While $attempts &lt; 3</code>, <code>For each $product</code>)</li> <li>Playbook calls (e.g., <code>ProcessPayment($amount)</code> <code>Calculate discount on $total</code>)</li> <li>Cross-agent playbook calls (e.g., <code>SupportAgent.HandleRequest($input)</code>)</li> <li>Control flow (e.g., <code>End program</code>, <code>Return $result</code>)</li> </ul> <p> When no steps are provided for a markdown playbook, the runtime treats the playbook's description as a ReAct-style prompt.</p> <p>For full manual control over the prompt and no runtime-enriched context, see Raw Prompt Playbooks.</p>"},{"location":"playbooks-language/playbooks-language/#6-notes","title":"6. Notes","text":"<p>The <code>### Notes</code> section can provide additional guidance or rules for the playbook:</p> <pre><code>### Notes\n- Maintain a professional tone throughout the conversation\n- If the user mentions a competitor, highlight our unique advantages\n- If the user is from California, mention that we're compliant with CCPA\n</code></pre>"},{"location":"playbooks-language/playbooks-language/#variable-usage","title":"Variable usage","text":"<p>Variables in Playbooks are denoted with a <code>$</code> prefix and must include explicit types:</p> <pre><code>- $total:float = $price:float * $quantity:int\n- Tell the user their $total:float\n</code></pre> <p>Variables can store:</p> <ul> <li>Strings (<code>str</code>)</li> <li>Numbers (<code>int</code>, <code>float</code>)</li> <li>Booleans (<code>bool</code>)</li> <li>Lists (<code>list</code>)</li> <li>Dictionaries (<code>dict</code>)</li> </ul> <p>If a variable's type is unknown, it defaults to <code>str</code>.</p>"},{"location":"playbooks-language/playbooks-language/#example","title":"Example","text":"<pre><code># CustomerSupportAgent\nThis agent handles customer support inquiries.\n\n```python\n@playbook(triggers=[\"When user provides order number\"])\nasync def ValidateOrderNumber(order_number: str) -&gt; bool:\n    \"\"\"Validate that an order number is in the correct format.\"\"\"\n    import re\n    pattern = r\"^ORD-\\d{6}$\"\n    return bool(re.match(pattern, order_number))\n```\n\n## OrderStatus\nThis playbook helps customers check their order status.\n\n### Triggers\n- When user asks about order status\n\n### Steps\n- Ask for their order number if they haven't provided it yet\n- If order number is not valid\n  - Tell the user their order number is invalid\n  - Ask the user to provide a valid order number in the format ORD-XXXXXX\n  - If order number is still not valid\n    - Apologize and offer to connect them with a human agent\n    - End program\n- $order_details = Look up order details for the $order_number\n- Tell the user the current status of their order\n- Ask if they need any additional assistance\n\n### Notes\n- If the user becomes frustrated, offer to connect them with a human agent\n- Always thank the user for their patience\n\n## Order details($order_number)\nThis playbook looks up order details for a given order number.\n...\n</code></pre>"},{"location":"playbooks-language/playbooks-language/#next-steps","title":"Next steps","text":"<ul> <li>Playbooks Assembly Language - How playbooks are compiled for execution</li> <li>Variables &amp; Expressions</li> </ul>"},{"location":"runtime/","title":"Playbooks Runtime","text":"<p>Execute PBASM programs with a fetch\u2013decode\u2013execute loop that verifies each step.</p> <pre><code>graph TD\n  A[\"Source Programs\"] --&gt; B[\"Compiler (Semantic Analysis)\"]\n  B --&gt; C[\"PBASM (Intermediate Representation)\"]\n  C --&gt; D[\"CLR Runtime\"]\n  D --&gt; E[\"LLM Execution (Markdown Steps)\"]\n  D --&gt; F[\"Python Execution (Functions)\"]\n  D --&gt; G[\"Agents &amp; Messaging\"]\n  D --&gt; H[\"Observability &amp; Debugging\"]\n\n  subgraph CLS\n    A\n    B\n  end\n  subgraph CLR\n    C\n    D\n    E\n    F\n    G\n    H\n  end</code></pre>"},{"location":"runtime/#verification-contract-summary","title":"Verification contract (summary)","text":"<ul> <li>LLM responses must use the structured format expected by the CLR</li> <li>Steps must map to valid program locations (line numbers and codes)</li> <li>Variable updates must be explicit and typed</li> <li>Triggers are evaluated between steps and on relevant updates</li> <li>Control transfer only via yield to user, call, or exit</li> </ul> <p>See also: Common Language Runtime (CLR) for details.</p> <ul> <li>Runtime main loop</li> <li>Decide which playbook to execute next<ul> <li>If processing a specific playbook call with provided parameters, load that playbook to execute</li> <li>If call stack is empty, load all BGN triggerred playbooks to execute</li> </ul> </li> <li>Executing a playbook<ul> <li>Markdown Playbook execution loop</li> <li>Call LLM to execute the next fragment of the playbook<ul> <li>Parse LLM response</li> <li>Verify LLM control flow and detect unexpected control flow</li> <li>Update execution state, variables, call stack, etc.</li> <li>Execute any queued playbooks</li> </ul> </li> <li>Python Playbook execution loop</li> <li>Use an isolated Python environment to execute the playbook function</li> <li>External Playbook (i.e. playbook from another Agent) execution loop</li> <li>Use an isolated Python environment to execute the playbook function which calls appropriate agent / external service, such as MCP or Playbooks server.</li> </ul> </li> </ul>"},{"location":"runtime/#runtime-execution-contract","title":"Runtime Execution Contract","text":"<p>The PBAsm runtime contract ensures deterministic execution despite the probabilistic nature of LLMs:</p>"},{"location":"runtime/#llm-output-format","title":"LLM Output Format","text":"<pre><code>recap \u2013 one-sentence summary of current state\nplan  \u2013 one-sentence immediate goal\n`Var[$name, &lt;value&gt;]`\n`SaveArtifact($name, \"summary\", \"content...\")`\ntrig? &lt;no | `Trigger[\"PB:Ln:Code\"]`&gt;\n`Step[\"Playbook:LineNumber:CommandCode\"]` optional inline: `Say(\"\u2026\")` or `$x = Func($y)`\ntrig? &lt;no | `Trigger[\"PB:Ln:Code\"]`&gt;\nwhat? handle unexpected situation intelligently and safely\n`Step[\"Playbook:LineNumber:CommandCode\"]` `Return[&lt;value&gt; | ]` `Var[$__, 1-5 line summary]`\nyld &lt;user | call | exit&gt;\n</code></pre> <ul> <li><code>recap</code> and <code>plan</code> start the response.</li> <li>For every executed step, one or more of the following are output:</li> <li><code>Var[$name, &lt;value&gt;]</code> is used to update the state.</li> <li><code>Step[\"Playbook:LineNumber:CommandCode\"]</code> is used to execute a step.</li> <li><code>trig? &lt;no |</code>Trigger[\"PB:Ln:Code\"]<code>&gt;</code> is used to check for triggers.</li> <li>Finally, <code>yld &lt;user | call | exit&gt;</code> is produced and control is yielded back to the runtime main loop.</li> </ul>"},{"location":"runtime/#verification-rules","title":"Verification Rules","text":"<ol> <li>Structured parsing: All outputs must be parseable by the runtime</li> <li>Variable tracking: State changes must be explicitly declared with types</li> <li>Trigger evaluation: Must check for triggers after each step and variable update</li> <li>Execution tracing: Each step must be logged with precise line numbers</li> <li>Control flow: Must use proper yield statements for control transfer</li> <li>Summary generation: Must generate $__ variable with execution summary before returning</li> </ol>"},{"location":"runtime/clr/","title":"Common Language Runtime (CLR)","text":"<p>Playbooks provides a Common Language Runtime for executing programs authored under the CLS. The CLR treats LLMs as an execution unit within a fetch\u2013decode\u2013execute loop, verifying each step against the compiled program.</p>"},{"location":"runtime/clr/#responsibilities","title":"Responsibilities","text":"<ul> <li>Load compiled PBASM and program metadata</li> <li>Manage agents, call stack, variables, artifacts, and events</li> <li>Coordinate LLM-driven step execution and Python function execution on the same stack</li> <li>Verify that LLM outputs conform to the program contract</li> <li>Provide observability (session logs, event bus, debug server)</li> </ul>"},{"location":"runtime/clr/#execution-loop","title":"Execution loop","text":"<p>High-level phases:</p> <ol> <li>Decide next playbook to execute (queued calls, triggers, or start-of-program)</li> <li>Execute next fragment:</li> <li>For Markdown Playbooks: request LLM to produce structured control actions</li> <li>For Python Playbooks: invoke Python function in-process</li> <li>Parse, verify, and apply actions: variable updates, Say, calls, returns, triggers</li> <li>Yield: to user, to call, or to exit</li> </ol>"},{"location":"runtime/clr/#verification-contract","title":"Verification contract","text":"<p>The CLR expects LLM responses in a structured format (recap, plan, Var[], Step[], trig?, yld). Responses are parsed and verified to ensure:</p> <ul> <li>Steps map to valid program locations with correct line numbers and codes</li> <li>Variable updates are explicit and typed</li> <li>Triggers are evaluated between steps and on relevant updates</li> <li>Control transfers occur only via valid yields (user, call, exit)</li> </ul> <p>If verification fails, the CLR treats it as unexpected control flow and can recover or surface errors.</p>"},{"location":"runtime/clr/#multiagent-and-messaging","title":"Multi\u2011agent and messaging","text":"<ul> <li>Agents can send messages, wait for messages, and call public playbooks of other agents</li> <li>Meetings enable broadcast-style coordination</li> <li>CLR routes messages and enforces boundaries for agent-to-agent calls</li> </ul>"},{"location":"runtime/clr/#observability-and-debugging","title":"Observability and debugging","text":"<ul> <li>Session logs with rich, structured entries</li> <li>Event bus for real\u2011time visibility</li> <li>Optional debug server for step debugging and IDE integration</li> </ul> <p>See also:</p> <ul> <li>Playbooks Runtime</li> <li>Playbooks Assembly Language</li> </ul>"},{"location":"triggers/","title":"Triggers","text":"<p>Triggers are a powerful feature in Playbooks AI that enable declarative event-driven programming through natural language conditions. They allow playbooks to be dynamically invoked when specified conditions are met.</p>"},{"location":"triggers/#what-are-triggers","title":"What are Triggers?","text":"<p>Triggers are conditions written in natural language that, when met, cause a playbook to be executed. They enable reactive and event-driven behavior in your AI agents.</p>"},{"location":"triggers/#benefits-of-triggers","title":"Benefits of Triggers","text":"<p>Triggers provide several advantages:</p> <ul> <li>Reactive Programming: Build systems that respond to events without polling</li> <li>Separation of Concerns: Organize code around events rather than control flow</li> <li>Natural Language Expressiveness: Specify complex conditions in plain language</li> <li>Reduced Complexity: Avoid complex if-else chains and state management</li> <li>Event-Driven Architecture: Create loosely coupled components that interact through events </li> </ul>"},{"location":"triggers/#next-steps","title":"Next Steps","text":"<ul> <li>See Adding Triggers</li> <li>Refer to tutorials for other topics</li> <li>Explore Playbooks Language</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Follow this series to learn Playbooks AI step by step. Each part ends with a concrete, verifiable result.</p> <p>If you have not installed Playbooks yet, complete the Installation and Quickstart first.</p>"},{"location":"tutorials/#series","title":"Series","text":"<ul> <li>Part 0: Install and first run \u2014 tutorials/part-0-install-first-run.md</li> <li>Part 1: User interaction \u2014 tutorials/part-1-user-interaction.md</li> <li>Part 2: Triggers \u2014 tutorials/part-2-triggers.md</li> <li>Part 3: Calling playbooks (Markdown \u2194 Python) \u2014 tutorials/part-3-calls-markdown-python.md</li> <li>Part 4: Agent\u2011to\u2011Agent calls \u2014 tutorials/part-4-agent-to-agent.md</li> <li>Part 5: Meetings \u2014 tutorials/part-5-meetings.md</li> <li>Part 6: Observability and debugging \u2014 tutorials/part-6-observability-debugging.md</li> <li>Part 7: Web Server and Playground \u2014 tutorials/part-7-web-server-playground.md</li> </ul> <p>You can run every step using the examples under <code>tests/data</code>.</p>"},{"location":"tutorials/part-0-install-first-run/","title":"Part 0 \u2013 Install and first run","text":"<p>Audience: Beginners</p> <p>Goal: Install Playbooks and run your first program.</p>"},{"location":"tutorials/part-0-install-first-run/#1-install","title":"1. Install","text":"<p>Follow the Installation. Verify with:</p> <pre><code>playbooks --version\n</code></pre>"},{"location":"tutorials/part-0-install-first-run/#2-configure-environment","title":"2. Configure environment","text":"<p>Create <code>.env</code> in your project root:</p> <pre><code>MODEL=claude-sonnet-4-20250514\nANTHROPIC_API_KEY=your_key\n</code></pre>"},{"location":"tutorials/part-0-install-first-run/#3-run-hello-world","title":"3. Run hello world","text":"<p>Use the example provided in the repository:</p> <pre><code>playbooks run tests/data/01-hello-playbooks.pb\n</code></pre> <p>Expected: The agent prints a greeting and exits.</p> <p>Next: Proceed to Part 1 \u2013 User interaction.</p>"},{"location":"tutorials/part-1-user-interaction/","title":"Part 1 \u2013 User interaction","text":"<p>Audience: Beginners</p> <p>Goal: Build an interactive agent that asks and responds to the user.</p>"},{"location":"tutorials/part-1-user-interaction/#run-the-example","title":"Run the example","text":"<pre><code>playbooks run tests/data/02-personalized-greeting.pb\n</code></pre> <p>Observe:</p> <ul> <li>The agent asks for your name</li> <li>You reply; it greets you by name</li> </ul> <p>Concepts:</p> <ul> <li>Say and Wait for user input</li> <li>Variables to store user data</li> </ul> <p>Next: Part 2 \u2013 Triggers.</p>"},{"location":"tutorials/part-2-triggers/","title":"Part 2 \u2013 Triggers","text":"<p>Audience: Beginners \u2192 Intermediate</p> <p>Goal: Use triggers to control when playbooks run.</p>"},{"location":"tutorials/part-2-triggers/#run-the-examples","title":"Run the examples","text":"<p>Start with basic triggers:</p> <pre><code>playbooks run tests/data/06-triggers.pb -v\n</code></pre> <p>Explore execution modes:</p> <pre><code>playbooks run tests/data/07-execution-modes.pb -v\n</code></pre> <p>Concepts:</p> <ul> <li>\u201cAt the beginning\u201d</li> <li>Condition\u2011based triggers</li> <li>Execution modes and implications</li> </ul> <p>Next: Part 3 \u2013 Calling playbooks (Markdown \u2194 Python).</p>"},{"location":"tutorials/part-3-calls-markdown-python/","title":"Part 3 \u2013 Calling playbooks (Markdown \u2194 Python)","text":"<p>Audience: Intermediate</p> <p>Goal: Compose Markdown and Python playbooks on one call stack.</p>"},{"location":"tutorials/part-3-calls-markdown-python/#run-the-examples","title":"Run the examples","text":"<p>Markdown calls Python and back:</p> <pre><code>playbooks run tests/data/03-md-calls-python.pb\n</code></pre> <p>Python interop:</p> <pre><code>playbooks run tests/data/playbooks-python-interop.pb\n</code></pre> <p>Round\u2011trip:</p> <pre><code>playbooks run tests/data/04-md-python-md.pb\n</code></pre> <p>Concepts:</p> <ul> <li><code>@playbook</code> Python functions</li> <li>Arguments and return values</li> <li>Mixed execution on a unified call stack</li> </ul> <p>Next: Part 4 \u2013 Agent\u2011to\u2011Agent calls.</p>"},{"location":"tutorials/part-4-agent-to-agent/","title":"Part 4 \u2013 Agent\u2011to\u2011Agent calls","text":"<p>Audience: Intermediate</p> <p>Goal: Make one agent call a public playbook on another agent.</p>"},{"location":"tutorials/part-4-agent-to-agent/#run-the-example","title":"Run the example","text":"<pre><code>playbooks run tests/data/multi-agent.pb -v\n</code></pre> <p>Observe:</p> <ul> <li><code>FirstAgent.A(1024)</code> is a public Python playbook invoked from another agent</li> <li>Country info agent exposes public playbooks callable by others</li> </ul> <p>Concepts:</p> <ul> <li>Public playbooks</li> <li>Cross\u2011agent calls with arguments and return values</li> </ul> <p>Next: Part 5 \u2013 Meetings.</p>"},{"location":"tutorials/part-5-meetings/","title":"Part 5 \u2013 Meetings","text":"<p>Audience: Intermediate</p> <p>Goal: Coordinate multiple agents in a shared meeting.</p>"},{"location":"tutorials/part-5-meetings/#run-the-example","title":"Run the example","text":"<pre><code>playbooks run tests/data/two-player-game.pb -v\n</code></pre> <p>Observe:</p> <ul> <li>A host orchestrates two players in a <code>meeting: true</code> room</li> <li>Broadcasts and turn\u2011taking drive the flow</li> </ul> <p>Concepts:</p> <ul> <li>Meeting playbooks</li> <li>Broadcast coordination</li> </ul> <p>Next: Part 6 \u2013 Observability and debugging.</p>"},{"location":"tutorials/part-6-observability-debugging/","title":"Part 6 \u2013 Observability and debugging","text":"<p>Audience: Intermediate</p> <p>Goal: Debug a program with breakpoints and observe execution logs.</p> <ul> <li>Load tests/data/02-personalized-greeting.pb in VSCode.</li> <li>Launch the playbooks program in debug mode using the Run menu from VSCode (see Integrations &gt; VSCode) and step through.</li> <li>You can step through the program and observe variables and the call stack.</li> </ul> <p>Next: Part 7 \u2013 Web Server and Playground.</p>"},{"location":"tutorials/part-7-web-server-playground/","title":"Part 7 \u2013 Web Server and Playground","text":"<p>Audience: Intermediate</p> <p>Goal: Run a program with a web UI and watch events stream live.</p>"},{"location":"tutorials/part-7-web-server-playground/#start-the-server","title":"Start the server","text":"<pre><code>python -m playbooks.applications.web_server\n</code></pre>"},{"location":"tutorials/part-7-web-server-playground/#open-the-playground","title":"Open the Playground","text":"<p>Open the HTML Playground (see Applications &gt; HTML Playground), set path to your <code>.pb</code>, and click Run Program.</p> <p>Expected: You see agent messages and execution logs in real time.</p> <p>Next: Continue with Guides for specific tasks.</p>"}]}