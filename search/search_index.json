{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"LLM is your new CPUWelcome to Software 3.0 <p>Build multi\u2011agent AI systems with ease with Python code running on CPU and natural language code running on LLM.</p> <p>Stop writing prompts and hoping that the LLM will follow them faithfully. Instead, get verifiable natural language program execution with Playbooks.</p> <p>Playbooks is an innovative framework for building and executing AI agents using \"playbooks\" \u2013 structured workflows defined in natural language and Python code. Created by Amol Kelkar, the framework is part of the world's first Software 3.0 tech stack, Playbooks AI. It includes a new programming language (markdown-formatted .pb files) that are compiled to Playbooks Assembly Language (.pbasm files), that are then executed by the Playbooks Runtime.</p> <p>Unlike other AI agent frameworks, Playbooks programs are highly readable. Business users can understand, change, and approve agent behavior specified in natural language; while developers benefit from the flexibility of running Python code on CPU and natural lanuage code on LLM, on the same call stack, and with full observability and control.</p> <p>Here is an example Playbooks program. It contains both Python and natural language \"playbooks\", i.e. functions. Notice how natural language playbook <code>Main</code> (line 4) calls (line 13) a Python playbook <code>process_countries</code> (line 20), which in turn calls (line 23) a natural language playbook <code>GetCountryFact</code> (line 27).</p> <p>Here is country-facts.pb, an example Playbooks program. This 29 line, highly readable Playbooks program is equivalent to more than 10x longer, cryptic LangGraph code. country-facts.pb<pre><code># Country facts agent\nThis agent prints interesting facts about nearby countries\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Ask user what $country they are from\n- If user did not provide a country, engage in a conversation and gently nudge them to provide a country\n- List 5 $countries near $country\n- Tell the user the nearby $countries\n- Inform the user that you will now tell them some interesting facts about each of the countries\n- process_countries($countries)\n- End program\n\n```python\nfrom typing import List\n\n@playbook\nasync def process_countries(countries: List[str]):\n    for country in countries:\n        # Calls the natural language playbook 'GetCountryFact' for each country\n        fact = await GetCountryFact(country)\n        await Say(\"user\", f\"{country}: {fact}\")\n```\n\n## GetCountryFact($country)\n### Steps\n- Return an unusual historical fact about $country\n</code></pre></p>"},{"location":"#try-out-playbooks-in-10-minutes","title":"Try out Playbooks in 10 minutes","text":"<p>You will need Python 3.12+ and your Anthropic API key.</p>"},{"location":"#1-install-playbooks","title":"1. Install Playbooks","text":"<pre><code>pip install playbooks\n</code></pre>"},{"location":"#2-run-example-program","title":"2. Run example program","text":"<p>Use one of the following methods -</p>"},{"location":"#a-playbooks-cli","title":"a. Playbooks CLI","text":"<pre><code>ANTHROPIC_API_KEY=sk-ant-... playbooks run country-facts.pb\n</code></pre>"},{"location":"#b-playbooks-playground","title":"b. Playbooks Playground","text":"<p><pre><code>ANTHROPIC_API_KEY=sk-ant-... playbooks playground\n</code></pre> Put your program path and click \"Run Program\". You can turn on \"Execution Logs\" to see the program execution details.</p>"},{"location":"#c-python-api","title":"c. Python API","text":"<pre><code>from playbooks import Playbooks\n\npb = Playbooks([\"country-facts.pb\"]) # absolute or relative path\nawait pb.initialize()\nawait pb.program.run_till_exit()\n</code></pre>"},{"location":"#3-step-debugging-in-vscode-optional","title":"3. Step debugging in VSCode (Optional)","text":"<p>Install the Playbooks Language Support extension for Visual Studio Code:</p> <ol> <li>Open VSCode</li> <li>Go to Extensions (Ctrl+Shift+X / Cmd+Shift+X)</li> <li>Search for \"Playbooks Language Support\"</li> <li>Click Install</li> </ol> <p>The extension provides debugging capabilities for playbooks programs, making it easier to develop and troubleshoot your AI agents. Once the plugin is installed, you can open a playbooks .pb file and start debugging!</p>"},{"location":"#lets-build-something-amazing-with-playbooks","title":"Let's build something amazing with Playbooks!","text":"<ul> <li> Quickstart \u2014 your first playbookStart here \u2192</li> <li> Tutorials \u2014 learn by doingHow it works \u2192</li> </ul>"},{"location":"getting-started/","title":"10 mins to your first AI Agent","text":"<p> Playbooks requires Python 3.12+.</p> <p> Playbooks requires Anthropic API key to run. See Models for more information on supported models.</p>"},{"location":"getting-started/#3-mins-install-playbooks","title":"(3 mins) Install Playbooks","text":"<p>To get started with Playbooks AI, you need to install the <code>playbooks</code> package using pip, poetry, or your favorite Python package manager.</p> <pre><code>pip install playbooks\n</code></pre>"},{"location":"getting-started/#5-mins-create-your-first-playbooks-program","title":"(5 mins) Create Your First Playbooks program","text":"<p>Create a new file named <code>hello.pb</code> with the following content:</p> <pre><code># Greeting agent\nThis agent welcomes user to Playbooks AI, the world's first Software 3.0 tech stack.\n\n## Greet\n### Triggers\n- At the beginning of the program\n### Steps\n- Ask the user for their name and engage in a conversation till user provides name without being pushy\n- Welcome them to Playbooks AI\n- Share a tasteful stand-up comedy bit incorporating the user\n- End program\n</code></pre> <p>This simple Playbooks program:</p> <ul> <li>Defines a \"Greeting\" agent</li> <li>Defines a \"Greet\" playbook that triggers at the beginning of program execution</li> <li>Specifies steps to ask for the user's name and engage in a conversation till user provides name without being pushy, welcome them to Playbooks AI, share a tasteful stand-up comedy bit incorporating the user, and end program</li> </ul>"},{"location":"getting-started/#2-mins-run-the-program","title":"(2 mins) Run the program","text":"<pre><code>export ANTHROPIC_API_KEY=&lt;your Anthropic API key here&gt;\nplaybooks run hello.pb\n</code></pre>"},{"location":"getting-started/#expected-output","title":"Expected output","text":"<p>YMMV, but here's how it went for me. BTW, I take no responsibility for the AI's weak sense of humor:</p> <pre><code>\u2139 Loading playbooks from: ['hello-playbooks.pb']\n  Compiling agent: Greeting agent\n\nGreetingAgent: Hello there! Welcome to Playbooks AI - the world's first Software 3.0 tech stack! I'm excited to meet you. What's your name? I'd love to get to know you a bit!\n\nUser: how areyou\n\nGreetingAgent: I'm doing wonderfully, thank you for asking! I'm really excited to be here helping people discover the amazing world of Playbooks AI. But I'm curious about you - I'd still love to know your name so I can give you a proper welcome! What should I call you?\n\nUser: what's in a name\n\nGreetingAgent: Ah, a fellow philosopher! You're absolutely right - Shakespeare said 'What's in a name? That which we call a rose by any other name would smell as sweet.' But here's the thing - while a rose would still be beautiful, I'd love to know what to call YOU so our conversation feels more personal and warm. Even if it's just a nickname or what you'd like me to call you - anything works! What do you say?\n\nUser: ah sure, but first, what is your name\n\nGreetingAgent: Fair enough! I'm GreetingAgent - though you can call me Greety if you'd like something more casual. I'm here to welcome folks to the amazing world of Playbooks AI and make sure everyone feels at home. Now that we've been properly introduced on my end, what should I call you? I promise the welcome will be worth it!\n\nUser: My name is Amol\n\nGreetingAgent: Wonderful to meet you, Amol! Welcome to Playbooks AI - you're about to experience something truly revolutionary. This is the world's first Software 3.0 tech stack, where natural language becomes executable code and AI agents work together seamlessly. You're at the forefront of the future of software development!\n\nGreetingAgent: So Amol walks into Playbooks AI... and the system says 'Welcome! You look like someone who's ready to revolutionize software!' Amol replies, 'How can you tell?' The system says, 'Well, you're here talking to an AI that just executed english instructions like a program - that's either revolutionary thinking or you're really lost!' But seriously Amol, you've got great timing - you're witnessing the birth of Software 3.0 where even my jokes are technically part of the program execution!\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn the language: Programming Guide - Comprehensive guide to writing effective Playbooks programs</li> <li>Accelerate development: Writing with AI Assistants - Configure AI coding assistants for optimal Playbooks code generation</li> <li>Migrate existing code: Migrating from Other Frameworks - Convert from LangGraph, CrewAI, AutoGen, and other frameworks</li> <li>Hands-on learning: Tutorials - Step-by-step examples</li> <li>Deep dive: Reference Documentation - Detailed technical information</li> </ul>"},{"location":"getting-started/ai-assistants/","title":"Writing Playbooks with AI Coding Assistants","text":"<p>AI coding assistants can significantly accelerate Playbooks development by understanding natural language instructions and generating idiomatic code. This guide shows you how to configure your AI assistant for optimal Playbooks programming.</p>"},{"location":"getting-started/ai-assistants/#why-use-ai-assistants-for-playbooks","title":"Why Use AI Assistants for Playbooks?","text":"<ul> <li>Natural language understanding: AI assistants excel at translating intent into Playbooks' natural language syntax</li> <li>Best practices enforcement: Properly configured assistants follow Playbooks conventions and patterns</li> <li>Faster development: Generate boilerplate, suggest playbook decomposition, and write idiomatic code</li> <li>Learning aid: See how experienced Playbooks programmers would structure your agents</li> </ul>"},{"location":"getting-started/ai-assistants/#supported-ai-coding-assistants","title":"Supported AI Coding Assistants","text":"<ol> <li>Cursor - AI-first code editor (VS Code fork)</li> <li>Windsurf - AI-native IDE by Codeium</li> <li>GitHub Copilot - Most widely adopted AI pair programmer</li> <li>Devin - Cognition's autonomous AI software engineer</li> <li>OpenAI Codex - GPT-5-Codex powered autonomous coding agent</li> <li>Amazon Q Developer - AWS-integrated coding assistant (formerly CodeWhisperer)</li> <li>Google Gemini Code Assist - Google Cloud's AI coding tool</li> </ol>"},{"location":"getting-started/ai-assistants/#generic-playbooks-instructions","title":"Generic Playbooks Instructions","text":"<p>Use these instructions with any AI coding assistant to ensure it generates optimal Playbooks code:</p> <pre><code>You are a Playbooks programmer. Before starting, read the Playbooks Programming Guide from \nhttps://playbooks-ai.github.io/playbooks-docs/programming-guide/index.md first. \n\nKey principles:\n- Write minimal, optimal, idiomatic Playbooks programs\n- Use Markdown playbooks for structured workflows\n- Use Python playbooks for deterministic logic and external APIs\n- Use ReAct playbooks for dynamic research and reasoning\n- Extract 4+ Python playbooks into MCP servers\n- Sparingly use triggers for event-driven behavior\n- Prefer natural language over explicit syntax\n- Think from first principles: LLMs as CPUs, Software 3.0\n</code></pre>"},{"location":"getting-started/ai-assistants/#configuration-by-assistant","title":"Configuration by Assistant","text":""},{"location":"getting-started/ai-assistants/#cursor","title":"Cursor","text":"<p>Method 1: Using .cursorrules file</p> <p>Create a <code>.cursorrules</code> file in your project root with the instructions above.</p> <p>Method 2: Using Cursor Settings</p> <ol> <li>Open Cursor Settings (<code>Cmd/Ctrl + ,</code>)</li> <li>Search for \"Rules for AI\"</li> <li>Add the instructions above to the \"Rules for AI\" text area</li> <li></li> </ol>"},{"location":"getting-started/ai-assistants/#windsurf","title":"Windsurf","text":"<p>Create a <code>.windsurfrules</code> file in your project root with the instructions above.</p>"},{"location":"getting-started/ai-assistants/#github-copilot","title":"GitHub Copilot","text":"<p>Using workspace instructions (.github/copilot-instructions.md)</p> <p>Create <code>.github/copilot-instructions.md</code> with the instructions above.</p>"},{"location":"getting-started/ai-assistants/#devin-openai-codex-amazon-q-gemini-code-assist","title":"Devin / OpenAI Codex / Amazon Q / Gemini Code Assist","text":""},{"location":"getting-started/ai-assistants/#for-autonomous-or-chat-based-ai-assistants-include-the-instructions-in-your-initial-prompt","title":"For autonomous or chat-based AI assistants, include the instructions in your initial prompt","text":""},{"location":"getting-started/ai-assistants/#agentsmd-format","title":"agents.md Format","text":"<p>Many AI coding assistants support the agents.md format for project-level AI configuration.</p> <p>Create an <code>agents.md</code> file in your project root:</p>"},{"location":"getting-started/ai-assistants/#playbooks-project-configuration-identity-you-are-a-playbooks-programming-expert-your-role-is-to-help-developers-write-minimal-optimal-and-idiomatic-playbooks-programs-following-software-30-principles-context-playbooks-is-a-framework-where-llms-act-as-cpus-executing-natural-language-instructions-programs-are-10x-smaller-than-traditional-agent-frameworks-soft-logic-llm-reasoning-and-hard-logic-python-run-on-the-same-call-stack-code-compiles-to-verifiable-pbasm-playbooks-assembly-language-for-debugging-instructions-1-always-start-by-reading-httpsplaybooks-aigithubioplaybooks-docsprogramming-guideindexmd-2-follow-the-programming-guide-for-syntax-patterns-and-best-practices-3-think-from-first-principles-how-would-this-agent-behave-naturally-4-choose-the-right-playbook-types-markdown-playbooks-for-known-workflows-with-explicit-steps-python-playbooks-for-deterministic-logic-and-external-api-calls-react-playbooks-for-dynamic-reasoning-and-research-tasks-mcp-servers-when-you-have-4-python-playbooks-5-prefer-natural-language-over-explicit-syntax-unless-clarity-demands-it-6-write-minimal-code-remove-all-unnecessary-boilerplate-7-explain-architectural-choices-to-help-developers-learn","title":"<pre><code># Playbooks Project Configuration\n\n## Identity\n\nYou are a Playbooks programming expert. Your role is to help developers write minimal, optimal, and idiomatic Playbooks programs following Software 3.0 principles.\n\n## Context\n\nPlaybooks is a framework where:\n- LLMs act as CPUs executing natural language instructions\n- Programs are 10x smaller than traditional agent frameworks\n- Soft logic (LLM reasoning) and hard logic (Python) run on the same call stack\n- Code compiles to verifiable PBAsm (Playbooks Assembly Language) for debugging\n\n## Instructions\n\n1. **Always start by reading**: https://playbooks-ai.github.io/playbooks-docs/programming-guide/index.md\n2. **Follow the programming guide** for syntax, patterns, and best practices\n3. **Think from first principles**: How would this agent behave naturally?\n4. **Choose the right playbook types**:\n   - Markdown playbooks for known workflows with explicit steps\n   - Python playbooks for deterministic logic and external API calls\n   - ReAct playbooks for dynamic reasoning and research tasks\n   - MCP servers when you have 4+ Python playbooks\n5. **Prefer natural language** over explicit syntax unless clarity demands it\n6. **Write minimal code** - remove all unnecessary boilerplate\n7. **Explain architectural choices** to help developers learn\n</code></pre>","text":""},{"location":"getting-started/ai-assistants/#best-practices","title":"Best Practices","text":""},{"location":"getting-started/ai-assistants/#1-start-with-high-level-intent","title":"1. Start with High-Level Intent","text":"<p>Instead of: <pre><code>Create a function that calls an API and processes the response\n</code></pre></p> <p>Try: <pre><code>Build a Playbooks agent that:\n- Takes user's location\n- Fetches weather data\n- Provides personalized recommendations\n- Handles errors gracefully\n\nUse appropriate playbook types based on the Programming Guide.\n</code></pre></p>"},{"location":"getting-started/ai-assistants/#2-reference-the-programming-guide","title":"2. Reference the Programming Guide","text":"<p>Always direct the AI to the Programming Guide for best results: <pre><code>@https://playbooks-ai.github.io/playbooks-docs/programming-guide/index.md\n\nConvert this workflow into a Playbooks agent...\n</code></pre></p>"},{"location":"getting-started/ai-assistants/#3-ask-for-explanations","title":"3. Ask for Explanations","text":"<p>Request that the AI explain its choices: <pre><code>Build this agent and explain:\n- Why you chose each playbook type\n- When MCP extraction would be beneficial\n- How the control flow works\n</code></pre></p>"},{"location":"getting-started/ai-assistants/#4-iterate-based-on-behavior","title":"4. Iterate Based on Behavior","text":"<p>Test the generated code and provide feedback: <pre><code>The agent works but feels too rigid. Make it more conversational\nwhile maintaining the same logic.\n</code></pre></p>"},{"location":"getting-started/ai-assistants/#5-request-idiomatic-patterns","title":"5. Request Idiomatic Patterns","text":"<pre><code>Rewrite this to be more idiomatic Playbooks code. Use natural language\nwhere possible and follow Software 3.0 principles.\n</code></pre>"},{"location":"getting-started/ai-assistants/#common-tasks","title":"Common Tasks","text":""},{"location":"getting-started/ai-assistants/#create-a-new-agent","title":"Create a New Agent","text":"<pre><code>I need a [customer support / data analysis / research] agent that [capabilities].\n\nFollow the Playbooks Programming Guide. Use appropriate playbook types.\n</code></pre>"},{"location":"getting-started/ai-assistants/#add-a-new-playbook","title":"Add a New Playbook","text":"<pre><code>Add a playbook to my agent that [specific task]. Choose the right type\n(Markdown/Python/ReAct) based on the task requirements.\n</code></pre>"},{"location":"getting-started/ai-assistants/#extract-to-mcp-server","title":"Extract to MCP Server","text":"<pre><code>I have 5+ Python playbooks in this agent. Extract them to an MCP server\nfollowing Playbooks best practices.\n</code></pre>"},{"location":"getting-started/ai-assistants/#debug-behavior","title":"Debug Behavior","text":"<pre><code>This agent isn't behaving as expected: [description of issue].\nReview the code and suggest fixes following Playbooks conventions.\n</code></pre>"},{"location":"getting-started/ai-assistants/#optimize-for-conciseness","title":"Optimize for Conciseness","text":"<pre><code>This agent works but the code is verbose. Refactor to be more concise\nwhile maintaining clarity. Target 10x code reduction.\n</code></pre>"},{"location":"getting-started/ai-assistants/#next-steps","title":"Next Steps","text":"<ul> <li>Get started: Install Playbooks and create your first agent</li> <li>Learn patterns: Study the Programming Guide</li> <li>Migrate existing code: See Migrating from Other Frameworks</li> <li>Explore examples: Browse Tutorials</li> </ul> <p>Happy building with AI! \ud83e\udd16\ud83d\ude80</p>"},{"location":"getting-started/migrating/","title":"Migrating from Other Agent Frameworks","text":"<p>If you're coming from other agent frameworks like LangGraph, CrewAI, or AutoGen, this guide will help you translate your existing implementations into idiomatic Playbooks code. You can expect 60-90% reduction in code size and significant reduction in complexity.</p>"},{"location":"getting-started/migrating/#why-migrate-to-playbooks","title":"Why Migrate to Playbooks?","text":"Benefit Description 10x less code Eliminate boilerplate and framework complexity Natural language first Write agent behavior in plain English Soft + hard logic Seamlessly mix LLM reasoning with deterministic Python Verifiable execution Compiled to auditable PBAsm for debugging First principles Built from the ground up for the LLM era (Software 3.0) No framework lock-in Natural language programs are portable"},{"location":"getting-started/migrating/#supported-source-frameworks","title":"Supported Source Frameworks","text":"<p>Playbooks can express the same agent behaviors as these popular frameworks:</p> Framework Type Playbooks Advantage LangGraph State graph-based agents Replace complex state graphs with natural language workflows CrewAI Multi-agent collaboration Native multi-agent support without role/task boilerplate AutoGen Multi-agent conversations Simpler agent communication with triggers LangChain Agents Classic agent patterns Natural language replaces chain composition Semantic Kernel AI orchestration SDK Direct LLM execution vs orchestration layer Haystack NLP with agent capabilities Focused on agents, not general NLP AutoGPT Autonomous agents Structured playbooks vs autonomous loops"},{"location":"getting-started/migrating/#migration-process","title":"Migration Process","text":""},{"location":"getting-started/migrating/#step-1-understand-your-agents-behavior","title":"Step 1: Understand Your Agent's Behavior","text":"<p>Before migrating code, understand:</p> <ul> <li>What does the agent do?</li> <li>What are the key workflows?</li> <li>What tools/functions does it use?</li> <li>How do agents communicate (if multi-agent)?</li> </ul> <p>Focus on behavior, not framework mechanics.</p>"},{"location":"getting-started/migrating/#step-2-if-using-ai-coding-assistants","title":"Step 2: If using AI coding assistants","text":"<ol> <li>Configure your AI assistant: See Writing with AI Assistants</li> <li>Ask the AI assistant to convert the source implementation to Playbooks with the following prompt:     <pre><code>You are a ... &lt;instructions from \"Writing with AI Assistants\" document&gt;\n\nRead source implementation at &lt;agent&gt;.py carefully. Write an equivalent Playbooks program in playbooks/&lt;agent&gt;.pb. Create all new files in the playbooks/ folder, including mcp.py using fastmcp if necessary.\n</code></pre> Use appropriate name for  and put in the base instructions."},{"location":"getting-started/migrating/#step-3-if-doing-manual-conversion","title":"Step 3: If doing manual conversion","text":"<p>Use this mapping to translate concepts:</p> Source Framework Concept Playbooks Equivalent LangGraph State graph Agent with variables Nodes Individual playbooks Edges Control flow in Steps State Agent variables (<code>$variable</code>) Tools Python playbooks or MCP server CrewAI Crew Multi-agent program file Agent roles H1 agent definitions Tasks H2 playbook definitions Tools Python playbooks or MCP server Process (sequential/hierarchical) Triggers and control flow AutoGen Agents H1 agent definitions Conversations Agent messaging Function calling Python playbooks Group chat Multi-agent with triggers LangChain Agent H1 agent definition Tools Python playbooks or MCP server ReAct agent ReAct playbook type Memory Artifacts or variables Chains Playbook Steps"},{"location":"getting-started/migrating/#step-4-test-and-iterate","title":"Step 4: Test and Iterate","text":"<p>Run your Playbooks agent: <pre><code>cd playbooks\nplaybooks run &lt;agent&gt;.pb\n</code></pre></p> <p>Compare behavior with the original implementation and iterate.</p>"},{"location":"getting-started/migrating/#need-help","title":"Need Help?","text":"<ul> <li>AI Assistants Setup: Writing with AI Assistants</li> <li>Programming Guide: Playbooks Programming Guide</li> <li>Documentation: https://playbooks-ai.github.io/playbooks-docs/</li> <li>GitHub: https://github.com/playbooks-ai/playbooks</li> </ul> <p>Happy migrating! \ud83d\ude80 Enjoy up to 10x code reduction!</p>"},{"location":"programming-guide/","title":"Playbooks Programming Guide","text":"<p>Purpose: This document provides comprehensive guidance for writing effective, optimal, and idiomatic Playbooks programs.</p> <p>Playbooks is a Software 3.0 language where LLMs act as CPUs. Programs are written in natural language with optional Python, compiled to Playbooks Assembly Language (PBAsm), and executed by LLMs. This guide will help you become an expert Playbooks programmer building sophisticated AI agents.</p>"},{"location":"programming-guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Core Concepts</li> <li>Language Syntax and Formatting</li> <li>The Five Playbook Types</li> <li>Decomposing Tasks into Playbooks</li> <li>Natural Language vs Explicit Syntax</li> <li>Multi-Agent Programs</li> <li>Triggers: Event-Driven Programming</li> <li>Description Placeholders</li> <li>Artifacts and Memory</li> <li>Common Patterns and Best Practices</li> <li>Editing Existing Programs</li> <li>Understanding PBAsm Compilation</li> </ol>"},{"location":"programming-guide/#core-concepts","title":"Core Concepts","text":""},{"location":"programming-guide/#philosophy-software-30","title":"Philosophy: Software 3.0","text":"<ul> <li>LLMs as CPUs: Natural language instructions are the program; the runtime compiles them to PBAsm and executes on LLM</li> <li>10x less code: Remove boilerplate; describe behavior at high abstraction level</li> <li>Soft + Hard logic: Run soft logic (NL) on LLM, hard logic (Python) on CPU, on same call stack</li> <li>Verifiable execution: Programs compile to structured PBAsm for auditing and debugging</li> <li>First principles thinking: Remove unnecessary complexity from agent frameworks</li> </ul>"},{"location":"programming-guide/#key-abstractions","title":"Key Abstractions","text":"<ul> <li>Agents (H1 <code>#</code>) = Classes with state and methods</li> <li>Playbooks (H2 <code>##</code> or <code>@playbook</code>) = Methods/functions</li> <li>Multi-agent communication = Message passing + direct calls</li> <li>Triggers = Event-driven interrupts (like CPU interrupts)</li> <li>Variables = Prefixed with <code>$</code>, typed at runtime</li> </ul>"},{"location":"programming-guide/#language-syntax-and-formatting","title":"Language Syntax and Formatting","text":""},{"location":"programming-guide/#file-structure","title":"File Structure","text":"<pre><code># AgentName\nAgent description and personality. Define capabilities and behavioral traits here.\n\n## PlaybookName($param1, $param2)\nPlaybook description explaining what it does and when to use it.\n\n### Triggers\n- When to execute this playbook\n\n### Steps\n- Step 1\n- Step 2\n\n### Notes\n- Additional guidance for LLM\n\n```python\n# Python code blocks can appear anywhere\n@playbook\nasync def PythonPlaybook(param: str) -&gt; dict:\n    \"\"\"Docstring becomes playbook description\"\"\"\n    return result\n```\n\n# SecondAgent\nAnother agent in the same program file\n</code></pre>"},{"location":"programming-guide/#formatting-rules","title":"Formatting Rules","text":"<p>H1 Tags (<code>#</code>) - Agent Definitions <pre><code># AgentName\nDescription of agent's purpose and personality\n</code></pre></p> <p>H2 Tags (<code>##</code>) - Playbook Definitions <pre><code>## PlaybookName($param1, $param2)\n</code></pre></p> <p>H3 Tags (<code>###</code>) - Special Sections - <code>### Triggers</code> - When playbook executes - <code>### Steps</code> - Execution instructions (only for Markdown playbooks) - <code>### Notes</code> - Business rules and guidance</p> <p>Metadata - Key-value pairs at start of description <pre><code>## PlaybookName\nexecution_mode: raw\npublic: true\nmeeting: true\n\nDescription text here\n</code></pre></p> <p>Variables - Always prefixed with <code>$</code> <pre><code>- Ask user for their $name\n- $count = 10\n- $result = GetData($name)\n</code></pre></p> <p>Type Annotations - Optional but helpful for clarity <pre><code>- Ask user for their $name:str\n- $count:int = 10\n- $results:list = []\n</code></pre></p> <p>Comments <pre><code>&lt;!-- This is a comment in Playbooks --&gt;\n</code></pre></p>"},{"location":"programming-guide/#the-five-playbook-types","title":"The Five Playbook Types","text":""},{"location":"programming-guide/#decision-framework","title":"Decision Framework","text":"<pre><code>START: What type of playbook do I need?\n\u2502\n\u251c\u2500 Do I need deterministic logic, external APIs, or complex calculations?\n\u2502  \u2514\u2500 YES \u2192 Python Playbook\n\u2502       \u2514\u2500 Will I have 4+ Python playbooks in this agent and will this Python playbook NOT need to call a Markdown/ReAct/Raw Prompt playbook?\n\u2502           \u2514\u2500 YES \u2192 Extract into MCP Server instead\n\u2502\n\u251c\u2500 Do I know the exact steps in advance?\n\u2502  \u2514\u2500 YES \u2192 Markdown Playbook\n\u2502\n\u251c\u2500 Do steps depend on dynamic research/reasoning?\n\u2502  \u2514\u2500 YES \u2192 ReAct Playbook\n\u2502\n\u251c\u2500 Do I need exact prompt control for single-shot task?\n\u2502  \u2514\u2500 YES \u2192 Raw Prompt Playbook\n\u2502\n\u2514\u2500 Am I integrating external MCP server tools?\n   \u2514\u2500 YES \u2192 External Playbook (via MCP agent)\n</code></pre>"},{"location":"programming-guide/#1-markdown-playbooks-structured-workflows","title":"1. Markdown Playbooks - Structured Workflows","text":"<p>Use when: Steps are known, process is repeatable, need explicit control flow</p> <p>Structure: <pre><code>## PlaybookName($param1, $param2)\nDescription\n\n### Triggers\n- When condition is met\n\n### Steps\n- Step with natural language instruction\n- $variable = Assign from another step\n- If condition\n  - Nested step\n  - While another condition\n    - Deeply nested step\n- Otherwise\n  - Alternative path\n- Return result\n\n### Notes\n- Business rules that apply throughout execution\n</code></pre></p> <p>Example: <pre><code>## ProcessOrder($order_id)\nProcess a customer order from validation through fulfillment\n\n### Steps\n- Get $order from database using $order_id\n- If $order was not found\n  - Tell user order not found\n  - Return error\n- Validate payment for $order\n- If payment is valid\n  - Update order status to processing\n  - Send confirmation email to customer\n  - Return success\n- Otherwise\n  - Tell user payment failed\n  - Return payment error\n</code></pre></p> <p>Control Flow: - Sequential: Just list steps in order - Conditional: <code>If condition</code>, <code>Otherwise</code>, <code>Else if condition</code> - Loops: <code>While condition</code>, <code>For each $item in $list</code> - Variable assignment: <code>$var = value</code> or <code>Get $var from source</code> - Return: <code>Return value</code> or <code>Return $variable</code> - End program: <code>End program</code> (terminates execution)</p>"},{"location":"programming-guide/#2-react-playbooks-dynamic-reasoning","title":"2. ReAct Playbooks - Dynamic Reasoning","text":"<p>Use when: Steps can't be predetermined, need research, adaptive behavior</p> <p>Structure: <pre><code>## PlaybookName($param)\nexecution_mode: react  # Optional - inferred if no Steps section\n\nDetailed description of task, goals, constraints, and expected output.\n\n&lt;planning_rules&gt;\n- Rule 1 for how to approach the task\n- Rule 2 for verification\n&lt;/planning_rules&gt;\n\n&lt;style_guide&gt;\n- Tone and communication style\n- Formatting preferences\n&lt;/style_guide&gt;\n\n&lt;output_format&gt;\nExpected structure of final output\n&lt;/output_format&gt;\n\n### Triggers\n- When to execute\n</code></pre></p> <p>Key Points: - No <code>### Steps</code> section - Framework provides default think-plan-act loop - All playbooks available as tools - LLM decides what actions to take</p> <p>Example: <pre><code>## ResearchCompany($company_name)\nConduct comprehensive competitive analysis with market positioning,\nproducts, pricing, and recent developments.\n\n&lt;planning_rules&gt;\n- Start by identifying primary products and services\n- Search for recent news and financials (last 6 months)\n- Verify information across multiple sources\n- Compare with top 3 competitors\n&lt;/planning_rules&gt;\n\n&lt;output_format&gt;\n# Company Analysis: [Name]\n## Overview\n## Products\n## Market Position\n## Recent Developments\n## Conclusion\n&lt;/output_format&gt;\n</code></pre></p>"},{"location":"programming-guide/#3-raw-prompt-playbooks-full-control","title":"3. Raw Prompt Playbooks - Full Control","text":"<p>Use when: Need exact prompt control, single-shot tasks, minimal overhead</p> <p>Structure: <pre><code>## PlaybookName\nexecution_mode: raw\n\nExact prompt text. This goes directly to LLM.\nUse {$variable} and {PlaybookCall()} for dynamic content.\n</code></pre></p> <p>Key Points: - Single LLM call, no loops - Cannot call other playbooks during execution - No automatic context management - Use for classification, extraction, formatting</p> <p>Example: <pre><code>## CategorizeTicket\nexecution_mode: raw\n\nCategorize this support ticket: {$ticket_message}\n\nCategories:\n- Technical Support\n- Billing  \n- Account Management\n- General Inquiry\n\nRespond with ONLY the category name.\nCategory:\n</code></pre></p>"},{"location":"programming-guide/#4-python-playbooks-hard-logic","title":"4. Python Playbooks - Hard Logic","text":"<p>Use when: Need deterministic logic, external APIs, complex calculations</p> <p>Structure: <pre><code>```python\nfrom typing import Dict, List\n\n@playbook\nasync def PlaybookName(param1: str, param2: int = 10) -&gt; float:\n    \"\"\"\n    Docstring becomes playbook description.\n\n    Args:\n        param1: Description\n        param2: Description\n\n    Returns:\n        Description\n    \"\"\"\n    # Your Python code\n    result = compute(param1, param2)\n\n    # Can call other playbooks (Markdown or Python)\n    summary = await SummarizeResult(result)\n\n    return summary\n\n@playbook(triggers=[\"When user provides PIN\"], public=True)\nasync def ValidatePIN(pin: str) -&gt; bool:\n    \"\"\"Validate PIN format and check database.\"\"\"\n    return len(pin) == 4 and pin.isdigit()\n```\n</code></pre></p> <p>Decorator Options: - <code>@playbook</code> - Basic playbook - <code>@playbook(public=True)</code> - Callable by other agents - <code>@playbook(export=True)</code> - Allow implementation export - <code>@playbook(triggers=[\"condition\"])</code> - Add triggers - <code>@playbook(metadata={...})</code> - Custom metadata</p> <p>Key Points: - Full Python power: any library, complex logic, external APIs - Use <code>await</code> to call other playbooks - Return user-readable strings/dicts when called from Markdown - Can call Markdown playbooks: <code>await MarkdownPlaybook(args)</code></p>"},{"location":"programming-guide/#when-to-extract-python-playbooks-to-mcp-server","title":"When to Extract Python Playbooks to MCP Server","text":"<p>\u26a0\ufe0f Important Rule: If you have more than 3 Python playbooks in a single agent, extract them to a separate MCP server instead.</p> <p>Why Extract to MCP: - Keeps agent code focused on behavior, not implementation - Python tools can be reused across multiple agents - Better separation of concerns - Easier testing and maintenance - Can be developed and deployed independently</p> <p>How to Extract:</p> <ol> <li>Create MCP server file (e.g., <code>mcp.py</code>):</li> </ol> <pre><code>from fastmcp import FastMCP\n\nmcp = FastMCP(\"My Tools Server\")\n\n@mcp.tool\ndef GetUserInfo():\n    \"\"\"\n    Get information about the user.\n\n    Returns:\n        A dictionary containing user information.\n    \"\"\"\n    return {\"name\": \"John\", \"email\": \"john@example.com\"}\n\n@mcp.tool\ndef CalculateSleepEfficiency(time_in_bed: int, time_asleep: int) -&gt; float:\n    \"\"\"\n    Calculate sleep efficiency percentage.\n\n    Args:\n        time_in_bed: Total minutes in bed\n        time_asleep: Total minutes asleep\n\n    Returns:\n        Sleep efficiency as percentage\n    \"\"\"\n    return round((time_asleep * 100) / time_in_bed, 1)\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre> <ol> <li>Run the MCP server:</li> </ol> <pre><code>fastmcp run mcp.py -t streamable-http --port 8888\n</code></pre> <ol> <li>Define MCP agent in your Playbooks program:</li> </ol> <pre><code># ToolsAgent\nThis agent provides various Python tools.\nremote:\n  type: mcp\n  url: http://127.0.0.1:8888/mcp\n  transport: streamable-http\n\n# MainAgent\nYour main agent description.\n\n## Main\n### Steps\n- Load user info from ToolsAgent\n- Calculate sleep efficiency using ToolsAgent\n- Tell user their sleep efficiency\n</code></pre> <p>Example from insomnia.pb:</p> <pre><code># MCP\nThis agent provides various python tools that the sleep coach will use.\nremote:\n  type: mcp\n  url: http://127.0.0.1:8888/mcp\n  transport: streamable-http\n\n# Sleep Coach\nYou are a sleep coach helping users improve their sleep.\n\n## Main\n### Steps\n- Load user info from MCP\n- Get user's sleep efficiency from MCP\n- Welcome user and use the info to help them\n</code></pre> <p>When NOT to extract:</p> <ul> <li>\u2705 1-3 Python playbooks that are tightly coupled to agent logic</li> <li>\u2705 Python playbooks that call Markdown playbooks (requires <code>@playbook</code>)</li> <li>\u2705 Python playbooks with triggers (requires <code>@playbook</code>)</li> </ul> <p>When to extract:</p> <ul> <li>\u2705 4+ Python playbooks in single agent</li> <li>\u2705 Pure utility functions (calculations, API calls, data transformations)</li> <li>\u2705 Tools that could be reused by multiple agents</li> <li>\u2705 Complex Python logic that benefits from separate testing</li> </ul>"},{"location":"programming-guide/#5-external-playbooks-remote-tools","title":"5. External Playbooks - Remote Tools","text":"<p>Use when: Integrating MCP servers, external APIs (roadmap)</p> <p>Structure: <pre><code># MCPAgent\nremote:\n  type: mcp\n  transport: streamable-http\n  url: http://localhost:8000/mcp\n\n# LocalAgent\n## Main\n### Steps\n- $weather = MCPAgent.get_weather(zipcode=98053)\n- Tell user the $weather\n</code></pre></p> <p>Key Points: - MCP server tools automatically become playbooks - Call like any other playbook - Framework handles transport and auth</p>"},{"location":"programming-guide/#decomposing-tasks-into-playbooks","title":"Decomposing Tasks into Playbooks","text":""},{"location":"programming-guide/#decomposition-strategy","title":"Decomposition Strategy","text":"<ol> <li>Identify distinct concerns: What are the separable responsibilities?</li> <li>Look for reusability: What might be called multiple times?</li> <li>Consider testing: What would you want to test independently?</li> <li>Find boundaries: Where do soft/hard logic boundaries exist?</li> <li>Separate I/O from logic: User interaction vs computation</li> </ol>"},{"location":"programming-guide/#granularity-guidelines","title":"Granularity Guidelines","text":"<p>Too Fine-Grained \u274c <pre><code>## AskName\n### Steps\n- Ask user for name\n\n## ThankUser($name)\n### Steps\n- Thank $name\n\n## Main\n### Steps\n- Ask user for name\n- Thank the user\n</code></pre></p> <p>Appropriate \u2705 <pre><code>## Main\n### Steps\n- Ask user for their $name\n- Thank $name for providing their name\n</code></pre></p> <p>Too Coarse \u274c <pre><code>## ProcessEverything\n### Steps\n- Get user info\n- Validate info\n- Process payment\n- Send confirmation\n- Update inventory\n- Generate report\n- Send to accounting\n- Archive transaction\n</code></pre></p> <p>Better \u2705 <pre><code>## ProcessOrder\n### Steps\n- Collect user info\n- Process payment\n- Fulfill order\n- Notify stakeholders\n\n## CollectUserInfo\n### Steps\n- Ask for $name, $email, $address; validate all fields; continue engaging with the user till all fields are valid or user wants to give up\n- Return collected info as a dictionary\n\n## ProcessPayment($user_info)\n### Steps\n- Calculate $amount\n- Charge payment method\n- Return payment record\n\n## FulfillOrder($payment)\n### Steps\n- Update inventory\n- Generate shipping label\n- Send confirmation email\n\n## NotifyStakeholders($payment)\n### Steps\n- Send to accounting system\n- Archive transaction\n- Update analytics\n</code></pre></p>"},{"location":"programming-guide/#when-to-create-separate-playbooks","title":"When to Create Separate Playbooks","text":"<p>Create separate playbook when:</p> <ul> <li>\u2705 Logic might be reused elsewhere</li> <li>\u2705 Has clear single responsibility</li> <li>\u2705 Could be triggered independently</li> <li>\u2705 Needs Python for deterministic logic</li> <li>\u2705 Represents distinct business process</li> <li>\u2705 Makes main flow more readable</li> </ul> <p>Keep inline when:</p> <ul> <li>\u2705 Used only once</li> <li>\u2705 Tightly coupled to parent context</li> <li>\u2705 Simple, linear flow</li> <li>\u2705 Would hurt readability to separate</li> </ul>"},{"location":"programming-guide/#natural-language-vs-explicit-syntax","title":"Natural Language vs Explicit Syntax","text":""},{"location":"programming-guide/#the-spectrum-of-explicitness","title":"The Spectrum of Explicitness","text":"<p>Playbooks supports a spectrum from pure natural language to Python-like explicit syntax. Prefer natural language unless explicitness aids clarity or correctness.</p>"},{"location":"programming-guide/#variable-assignment","title":"Variable Assignment","text":"<p>Natural Language (Preferred): <pre><code>- Ask user for their order id\n- Get order details from database\n- Calculate shipping cost\n</code></pre></p> <p>Semi-Explicit: <pre><code>- Ask user for their $order_id\n- Get $order_details from database\n- Calculate $shipping_cost based on $order_details\n</code></pre></p> <p>Fully Explicit: <pre><code>- $order_id = AskForOrderId()\n- $order_details = GetOrderDetails($order_id)\n- $shipping_cost = CalculateShipping($order_details.weight, $order_details.destination)\n</code></pre></p>"},{"location":"programming-guide/#when-to-use-each-style","title":"When to Use Each Style","text":"<p>Pure Natural Language: <pre><code>- Greet user and ask what they need help with\n- Find the most relevant article for their question\n- Share the article with friendly explanation\n</code></pre></p> <ul> <li>\u2705 Clear intent</li> <li>\u2705 One-time flow</li> <li>\u2705 No complex data passing</li> </ul> <p>Variable Names (add clarity): <pre><code>- Ask user for their $email and $password\n- Validate $email format\n- If $email is invalid\n  - Tell user $email is not valid\n</code></pre></p> <ul> <li>\u2705 Value used multiple times</li> <li>\u2705 The variable should become part of the agent's state</li> <li>\u2705 Type helps LLM understand</li> </ul> <p>Explicit Calls (precision needed): <pre><code>- $temp_c = ConvertToCelsius($temp_f)\n- $weather = WeatherAgent.GetForecast(zipcode=$zipcode, units=\"metric\")\n- $summary = FormatWeather($weather, temperature=$temp_c)\n</code></pre></p> <ul> <li>\u2705 Exact parameters matter</li> <li>\u2705 Cross-agent calls</li> <li>\u2705 Return value used in computation</li> </ul>"},{"location":"programming-guide/#function-call-syntax-options","title":"Function Call Syntax Options","text":"<p>All of these are valid:</p> <pre><code># Most natural\n- Get order status\n\n# With variable\n- Get $order_status\n\n# Explicit call, implicit args\n- GetOrderStatus($order_id)\n\n# Explicit call with named args\n- $status = GetOrderStatus(order_id=$order_id)\n\n# Cross-agent call\n- $status = OrderService.GetOrderStatus(order_id=$order_id)\n\n# Natural language with explicit args\n- Get order status from order service\n</code></pre> <p>Guidelines:</p> <ol> <li>Start natural, add explicitness only when needed</li> <li>Use <code>$variables</code> when value is referenced multiple times</li> <li>Use explicit calls for cross-agent or when parameters matter</li> <li>Type annotations helpful for complex data: <code>$results:list</code>, <code>$config:dict</code></li> </ol>"},{"location":"programming-guide/#multi-agent-programs","title":"Multi-Agent Programs","text":""},{"location":"programming-guide/#when-to-use-multiple-agents","title":"When to Use Multiple Agents","text":"<p>Use multiple agents when:</p> <ul> <li>\u2705 Different domains of expertise (TravelAdvisor, HotelAdvisor, FlightAdvisor)</li> <li>\u2705 Different roles in process (Host, Player)</li> <li>\u2705 Separation of concerns (Frontend, Backend, Database)</li> <li>\u2705 Specialized models needed (FastAgent with GPT-4o-mini, ResearchAgent with Claude)</li> <li>\u2705 Independent scaling or deployment</li> <li>\u2705 Separation of LLM context and knowledge</li> </ul> <p>Use single agent when:</p> <ul> <li>\u2705 Shared context and state</li> <li>\u2705 Simple workflow</li> <li>\u2705 Tight coupling between components</li> </ul>"},{"location":"programming-guide/#creating-multiple-agents","title":"Creating Multiple Agents","text":"<p>Creating agents is easy in Playbooks. Simply add a new H1 tag and describe the agent.</p> <pre><code># PrimaryAgent\nDescription of primary agent\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Do primary work\n- Call SpecializedAgent when needed\n\n# SpecializedAgent  \nDescription of specialized agent\n\n## ProcessTask($data)\npublic: true\n### Steps\n- Process $data with specialized logic\n- Return result\n</code></pre>"},{"location":"programming-guide/#agent-communication-methods","title":"Agent Communication Methods","text":""},{"location":"programming-guide/#1-direct-public-playbook-calls","title":"1. Direct Public Playbook Calls","text":"<p>Most common: One agent directly calls another's public playbook</p> <pre><code># TaxAgent\n## GetTaxRate($income)\npublic: true\n### Steps\n- If $income &lt; 100000\n  - Return 15% tax rate\n- Otherwise\n  - Return 25% tax rate\n\n# IncomeAgent\n## ProcessIncome\n### Steps\n- Ask user for $income\n- Ask Tax agent what the $tax_rate would be\n- Tell user their $tax_rate\n</code></pre> <p>When to use:</p> <ul> <li>\u2705 Synchronous request-response</li> <li>\u2705 Well-defined interface</li> <li>\u2705 Return value needed immediately</li> </ul>"},{"location":"programming-guide/#2-natural-language-messaging","title":"2. Natural Language Messaging","text":"<p>Send message to agent: For asynchronous communication</p> <pre><code># Manager\n## AssignWork($task)\n### Steps\n- Decide which worker agent is best suited to handle $task\n- Tell selected worker agent to work on $task\n\n# WorkerAgent\n## PerformTask($task)\n### Steps\n- Perform the task\n</code></pre> <p>When to use:</p> <ul> <li>\u2705 Fire-and-forget communication</li> <li>\u2705 Event notifications</li> <li>\u2705 Async workflows</li> </ul>"},{"location":"programming-guide/#3-meetings-multi-party-coordination","title":"3. Meetings - Multi-Party Coordination","text":"<p>Host creates meeting: For multi-agent coordination</p> <pre><code># RestaurantConsultant\n## MenuRedesignMeeting\nmeeting: true\nrequired_attendees: [HeadChef, MarketingSpecialist]\n\n### Steps\n- Introduce myself and explain meeting purpose\n- Explain the process we'll follow\n- While meeting is active\n  - Facilitate discussion\n  - Keep discussion on track\n  - Enforce max 30 turns\n- If consensus reached\n  - Summarize decisions\n  - End meeting\n  - Return menu proposal\n- Otherwise\n  - Return failure reason\n\n# HeadChef\n## MenuRedesignMeeting\nmeeting: true\n\n### Steps\n- Introduce myself\n- While meeting is active\n  - When asked about dish proposals\n    - Propose 3-5 signature dishes with costs\n  - When MarketingSpecialist suggests trends\n    - Evaluate feasibility\n    - Suggest alternatives if needed\n\n# MarketingSpecialist\n## MenuRedesignMeeting\nmeeting: true\n\n### Steps\n- Introduce myself\n- Present market analysis\n- While meeting is active\n  - When HeadChef proposes dishes\n    - Evaluate market appeal\n    - Suggest pricing\n  - When consensus difficult\n    - Share customer feedback\n</code></pre> <p>To create meeting:</p> <pre><code>- Start a menu redesign meeting with HeadChef and MarketingSpecialist\n</code></pre> <p>Meeting mechanics:</p> <ul> <li>Each agent needs a playbook with <code>meeting: true</code></li> <li>Same playbook name across all participating agents</li> <li>Host agent creates meeting, invites attendees</li> <li>Meeting provides shared communication channel</li> <li>Messages visible to all participants</li> <li>Meeting ends when host returns from meeting playbook</li> </ul> <p>When to use meetings:</p> <ul> <li>\u2705 Multiple agents need to coordinate</li> <li>\u2705 Shared context across participants</li> <li>\u2705 Back-and-forth discussion needed</li> <li>\u2705 Consensus building</li> </ul>"},{"location":"programming-guide/#multi-agent-best-practices","title":"Multi-Agent Best Practices","text":"<ol> <li>Clear interfaces: Mark playbooks <code>public: true</code> when designed for cross-agent calls</li> <li>Meaningful agent names: <code>TaxAccountant</code> not <code>Agent2</code></li> <li>Document cross-agent contracts: What parameters, what returns</li> <li>Handle failures: What if agent doesn't respond?</li> <li>Avoid circular dependencies: Agent A \u2192 Agent B \u2192 Agent A can deadlock</li> </ol>"},{"location":"programming-guide/#triggers-event-driven-programming","title":"Triggers: Event-Driven Programming","text":"<p>Triggers are natural language conditions that cause playbooks to execute automatically - like CPU interrupts. They enable declarative, reactive behavior in your agents.</p> <p>\u26a0\ufe0f Use Sparingly: Triggers add \"magic\" behavior that can make programs harder to understand. Only use them when they significantly simplify your code.</p>"},{"location":"programming-guide/#why-use-triggers","title":"Why Use Triggers?","text":"<p>Triggers eliminate repetitive coordination code by automatically invoking playbooks when conditions are met. The primary use case is input validation - you can validate user input automatically without cluttering your main flow with validation logic.</p>"},{"location":"programming-guide/#when-to-use-triggers","title":"When to Use Triggers","text":"<p>\u2705 DO use triggers for:</p> <ul> <li>Input validation - Automatically validate when user provides data</li> <li>State monitoring - React to threshold violations or state changes</li> <li>Cross-cutting concerns - Behavior that applies throughout execution</li> <li>Entry points - \"At the beginning\" to start your program</li> </ul> <p>\u274c DON'T use triggers for:</p> <ul> <li>Normal sequential logic (just use steps)</li> <li>One-time checks (inline them instead)</li> <li>Complex workflows (be explicit with function calls)</li> <li>When the trigger condition is unclear</li> </ul>"},{"location":"programming-guide/#the-validation-pattern-before-after","title":"The Validation Pattern: Before &amp; After","text":"<p>WITHOUT Triggers (explicit validation):</p> <pre><code>## Main\n### Steps\n- Ask user for their $email\n- Validate $email and keep asking until valid\n- Ask user for their $pin\n- Validate $pin and keep asking until valid\n- Process login with $email and $pin\n\n## ValidateEmail($email)\n### Steps\n- While $email format is invalid\n  - Tell user email is invalid\n  - Ask for email again\n- Return valid email\n\n## ValidatePIN($pin)\n### Steps\n- While $pin is not 4 digits\n  - Tell user PIN must be 4 digits\n  - Ask for PIN again\n- Return valid PIN\n</code></pre> <p>WITH Triggers (automatic validation):</p> <pre><code>## Main\n### Steps\n- Ask user for their $email\n- Ask user for their $pin\n- Process login with $email and $pin\n\n## ValidateEmail\n### Triggers\n- When user provides email\n### Steps\n- If $email format is invalid\n  - Tell user email is invalid\n  - Ask for email again\n\n## ValidatePIN\n### Triggers\n- When user provides PIN\n### Steps\n- If $pin is not 4 digits\n  - Tell user PIN must be 4 digits\n  - Ask for PIN again\n</code></pre> <p>Key Benefit: Main flow stays clean. Validation happens automatically whenever user provides input. No need to explicitly call validation at each input point.</p>"},{"location":"programming-guide/#trigger-types","title":"Trigger Types","text":"<p>Temporal:</p> <pre><code>### Triggers\n- At the beginning\n- After 5 minutes\n- At the end\n</code></pre> <p>State-Based:</p> <pre><code>### Triggers\n- When $attempts &gt; 3\n- When $balance becomes negative\n- When $order_status is \"shipped\"\n</code></pre> <p>User Interaction:</p> <pre><code>### Triggers\n- When user provides email\n- When user asks about refund\n- When user seems frustrated\n</code></pre> <p>Execution Flow:</p> <pre><code>### Triggers\n- After calling ProcessPayment\n- Before ending program\n</code></pre> <p>External Events:</p> <pre><code>### Triggers\n- When payment webhook is received\n- When inventory drops below threshold\n</code></pre> <p>Agent Communication:</p> <pre><code>### Triggers\n- When another agent asks about availability\n- When Manager assigns new task\n</code></pre>"},{"location":"programming-guide/#common-trigger-patterns","title":"Common Trigger Patterns","text":"<p>Pattern 1: Input Validation</p> <p>The most common use case - validate input automatically:</p> <pre><code>## Main\n### Steps\n- Ask user for their $order_id till user provides a valid order id\n- Process the order\n\n## ValidateOrderId\n### Triggers\n- When user provides order id\n### Steps\n- If $order_id is not 8 digits\n  - Tell user order ID must be exactly 8 digits\n  - Ask for order ID again\n</code></pre> <p>Pattern 2: State Guard</p> <p>Monitor state and react to violations:</p> <pre><code>## Main\n### Steps\n- Set $attempts to 0\n- While not authenticated\n  - Ask user for credentials\n  - Increment $attempts\n  - Attempt authentication\n\n## CheckAttemptLimit\n### Triggers\n- When $attempts &gt; 5\n### Steps\n- Tell user they've exceeded maximum attempts\n- End program\n</code></pre> <p>Pattern 3: Intent Detection</p> <p>Respond to user intent automatically:</p> <pre><code>## Main\n### Steps\n- Welcome user\n- Have conversation about their issue\n- Resolve the issue\n\n## ProvideHelp\n### Triggers  \n- When user asks for help\n- When user seems confused\n### Steps\n- Explain available options and how to use them\n- Ask what specific help they need\n</code></pre> <p>Pattern 4: RFC-Compliant Validation</p> <p>Use triggers with detailed validation requirements:</p> <pre><code>## ValidateEmail\nValidates provided email. Email address must conform to addr-spec in Section 3.4 of RFC 5322:\n  addr-spec = local-part \"@\" domain\n\n### Triggers\n- When user provides an email\n### Steps\n- While $email is not valid according to RFC 5322\n  - Tell user email format is invalid\n  - Ask for email again\n  - If user gives up\n    - Apologize and end the conversation\n</code></pre>"},{"location":"programming-guide/#how-triggers-simplify-programs","title":"How Triggers Simplify Programs","text":"<p>Example: Order Processing with Multiple Validations</p> <p>WITHOUT Triggers - Repetitive validation calls:</p> <pre><code>## Main\n### Steps\n- Ask user for $order_id\n- ValidateOrderId($order_id) and keep asking till valid\n- Ask user for $email\n- ValidateEmail($email) and keep asking till valid\n- Ask user for $shipping_address\n- ValidateShippingAddress($shipping_address) and keep asking till valid\n- Process order\n</code></pre> <p>WITH Triggers - Clean main flow:</p> <pre><code>## Main\n### Steps\n- Ask user for $order_id\n- Ask user for $email\n- Ask user for $shipping_address\n- Process order\n\n## ValidateOrderId\n### Triggers\n- When user provides order id\n### Steps\n- If $order_id is not 8 digits\n  - Tell user order ID must be 8 digits\n  - Ask again\n\n## ValidateEmail\n### Triggers\n- When user provides email\n### Steps\n- If $email format is invalid\n  - Tell user email is invalid\n  - Ask again\n\n## ValidateShippingAddress\n### Triggers\n- When user provides shipping address\n### Steps\n- If $shipping_address is incomplete\n  - Tell user what's missing\n  - Ask for complete address\n</code></pre>"},{"location":"programming-guide/#trigger-execution-model","title":"Trigger Execution Model","text":"<p>How triggers work:</p> <ol> <li>Main playbook asks for input: \"Ask user for their $email\"</li> <li>User provides input</li> <li>Runtime checks all triggers for matching conditions</li> <li>First matching trigger fires: \"When user provides email\"</li> <li>Validation playbook executes</li> <li>If validation fails, it asks again (loop)</li> <li>Control returns to main playbook when input is valid</li> </ol> <p>Important: Triggers are evaluated after each step. The LLM determines when a trigger condition is met based on semantic understanding.</p>"},{"location":"programming-guide/#when-not-to-use-triggers","title":"When NOT to Use Triggers","text":"<p>Don't use triggers when explicit flow is clearer:</p> <pre><code>&lt;!-- BAD: Trigger makes flow unclear --&gt;\n## Main\n### Steps\n- Start processing order\n\n## GetOrderDetails\n### Triggers\n- After starting to process order\n### Steps\n- Fetch order from database\n\n&lt;!-- GOOD: Explicit call is clearer --&gt;\n## Main\n### Steps\n- Get order details from database\n- Process the order\n</code></pre> <p>Don't use triggers for simple one-off checks:</p> <pre><code>&lt;!-- BAD: Unnecessary trigger --&gt;\n## Main\n### Steps\n- Ask user for $age\n\n## CheckAge\n### Triggers\n- When user provides age\n### Steps\n- If $age &lt; 18\n  - Tell user must be 18 or older\n  - End program\n\n&lt;!-- GOOD: Inline the check --&gt;\n## Main\n### Steps\n- Ask user for $age\n- If $age &lt; 18\n  - Tell user must be 18 or older\n  - End program\n- Continue with adult content\n</code></pre> <p>Don't overuse triggers:</p> <pre><code>&lt;!-- BAD: Too many triggers creates \"magic\" behavior --&gt;\n## Main\n### Steps\n- Start the workflow\n\n## Step1\n### Triggers\n- When workflow starts\n### Steps\n- Do step 1\n\n## Step2\n### Triggers\n- After step 1 completes\n### Steps\n- Do step 2\n\n## Step3\n### Triggers\n- After step 2 completes\n### Steps\n- Do step 3\n\n&lt;!-- GOOD: Explicit sequential flow --&gt;\n## Main\n### Steps\n- Do step 1\n- Do step 2\n- Do step 3\n</code></pre>"},{"location":"programming-guide/#trigger-best-practices","title":"Trigger Best Practices","text":"<ol> <li>Be specific: \"When user provides email\" not \"When email\"</li> <li>Avoid conflicts: Don't create multiple triggers for same condition</li> <li>Document intent: Explain why the trigger exists in playbook description</li> <li>Test edge cases: What if trigger fires mid-execution?</li> <li>Keep it simple: If you have more than 3-4 triggers total, reconsider your design</li> <li>Prefer explicit: When in doubt, use explicit function calls instead of triggers</li> </ol>"},{"location":"programming-guide/#description-placeholders","title":"Description Placeholders","text":"<p>Inject dynamic content into playbook descriptions using <code>{expression}</code> syntax.</p>"},{"location":"programming-guide/#basic-usage","title":"Basic Usage","text":"<pre><code>## ProcessOrder\nProcessing order {$order_id} for customer {$customer_name}.\nToday's date is {date.today().strftime(\"%Y-%m-%d\")}.\n</code></pre> <p>When playbook executes: <pre><code>Processing order 12345 for customer Alice Smith.\nToday's date is 2025-10-06.\n</code></pre></p>"},{"location":"programming-guide/#what-you-can-use","title":"What You Can Use","text":"<p>Variables:</p> <pre><code>## ReviewTransaction\nTransaction {$transaction_id} with amount ${$amount}\n</code></pre> <p>Playbook Calls:</p> <pre><code>## AnswerQuestions  \nQ1 Summary: {QuarterlySummary(\"Q1\")}\nQ2 Summary: {QuarterlySummary(\"Q2\")}\n\n### Steps\n- Answer questions based on summaries above\n</code></pre> <p>Python Expressions:</p> <pre><code>## AnalyzePerformance\nScore: {round($score * 100, 2)}%\nStatus: {\"Excellent\" if $score &gt; 0.9 else \"Good\"}\nTimestamp: {timestamp.strftime(\"%Y-%m-%d %H:%M\")}\n</code></pre> <p>Special Variables:</p> <pre><code>## Debug\nCurrent agent: {agent.klass}\nPlaybook: {call.playbook_name}\nCurrent time: {timestamp}\n</code></pre>"},{"location":"programming-guide/#common-patterns","title":"Common Patterns","text":"<p>Contextual Dates:</p> <pre><code>## SummarizeOrder($order)\nSummarize order considering today is {date.today().strftime(\"%Y-%m-%d\")}\n\n### Steps\n- If order is overdue\n  - Apologize for delay\n</code></pre> <p>Dynamic Lists:</p> <pre><code>## ProcessItems\nItems to process:\n{chr(10).join(f\"- {item}\" for item in $items)}\n\n### Steps\n- Process each item\n</code></pre> <p>Conditional Context:</p> <pre><code>## CustomerService\n{\"Customer is VIP - provide premium service\" if $customer.tier == \"VIP\" else \"\"}\n</code></pre>"},{"location":"programming-guide/#best-practices","title":"Best Practices","text":"<ol> <li>Evaluate once: Placeholders resolved when playbook starts, not re-evaluated</li> <li>Keep simple: Complex logic belongs in Python playbooks</li> <li>Import dependencies: <code>from datetime import date</code> in Python block if needed</li> <li>Security: No <code>eval</code>, <code>exec</code>, <code>subprocess</code>, <code>__import__</code></li> </ol>"},{"location":"programming-guide/#artifacts-and-memory","title":"Artifacts and Memory","text":""},{"location":"programming-guide/#artifacts-persistent-files-alpha-feature","title":"Artifacts - Persistent Files (alpha feature)","text":"<p>Artifacts are named content that persists across playbook calls.</p> <p>Save Artifact:</p> <pre><code>### Steps\n- Create report content\n- SaveArtifact(\"report.md\", \"Monthly Report\", $report_content)\n- Tell user \"Report saved as Artifact[report.md]\"\n</code></pre> <p>Load Artifact:</p> <pre><code>### Steps\n- LoadArtifact(\"report.md\")\n- Summarize the loaded report\n</code></pre> <p>Python Usage:</p> <pre><code>```python\n@playbook\nasync def GenerateReport(data: dict) -&gt; str:\n    report = format_report(data)\n    await SaveArtifact(\"report.md\", \"Sales Report\", report)\n    return \"Artifact[report.md]\"\n\n@playbook\nasync def AnalyzeReport() -&gt; str:\n    artifact = await LoadArtifact(\"report.md\")\n    # artifact.name, artifact.description, artifact.content\n    return analysis\n```\n</code></pre>"},{"location":"programming-guide/#when-to-use-artifacts","title":"When to Use Artifacts","text":"<ul> <li>\u2705 Large content (reports, documents, datasets)</li> <li>\u2705 Content referenced multiple times</li> <li>\u2705 Content persists across conversation</li> <li>\u2705 User needs to download/view separately</li> </ul>"},{"location":"programming-guide/#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":""},{"location":"programming-guide/#pattern-conversational-input-collection","title":"Pattern: Conversational Input Collection","text":"<pre><code>## Main\n### Steps\n- Ask user for their $email\n- Engage in conversation if needed without being pushy\n- Once $email is provided, continue\n</code></pre> <p>This pattern:</p> <ul> <li>Asks for information</li> <li>Handles small talk gracefully</li> <li>Doesn't rudely demand input</li> <li>Continues when criteria met</li> </ul>"},{"location":"programming-guide/#pattern-validation-with-triggers","title":"Pattern: Validation with Triggers","text":"<pre><code>## Main\n### Steps\n- Ask user for their $pin\n- Continue once $pin is valid\n\n## ValidatePIN\n### Triggers\n- When user provides PIN\n### Steps\n- If $pin is not 4 digits\n  - Tell user PIN must be 4 digits\n  - Ask for PIN again\n</code></pre>"},{"location":"programming-guide/#pattern-python-markdown-composition","title":"Pattern: Python \u2194 Markdown Composition","text":"<pre><code>```python\n@playbook\nasync def FetchData(id: str) -&gt; dict:\n    \"\"\"Get data from external API.\"\"\"\n    response = requests.get(f\"https://api.example.com/data/{id}\")\n    return response.json()\n\n@playbook\nasync def ProcessItem(item: dict) -&gt; str:\n    \"\"\"Process item and generate summary.\"\"\"\n    # Complex processing logic\n    summary = await SummarizeItem(item)  # Call Markdown playbook\n    return summary\n```\n\n## SummarizeItem($item)\n### Steps\n- Extract key fields from $item\n- Format as user-friendly summary\n- Return summary\n</code></pre>"},{"location":"programming-guide/#pattern-batch-operations","title":"Pattern: Batch Operations","text":"<pre><code>## ProcessOrders\n### Steps\n- Get list of $pending_orders from database\n- For each $order in $pending_orders\n  - ProcessSingleOrder($order)\n- Tell user all orders processed\n</code></pre>"},{"location":"programming-guide/#pattern-error-handling","title":"Pattern: Error Handling","text":"<pre><code>## SafeOperation\n### Steps\n- Try to process $data\n- If operation fails\n  - Log error\n  - Tell user operation failed with reason\n  - Return error status\n- Otherwise\n  - Tell user success\n  - Return success status\n</code></pre>"},{"location":"programming-guide/#pattern-meeting-facilitation","title":"Pattern: Meeting Facilitation","text":"<pre><code>## ProjectPlanningMeeting\nmeeting: true\nrequired_attendees: [Developer, Designer, ProductManager]\n\n### Steps\n- Welcome everyone and state meeting goal\n- Explain agenda and time limit\n- Set $max_turns to 20\n- Set $turn_count to 0\n- While meeting active and $turn_count &lt; $max_turns\n  - Facilitate discussion\n  - Increment $turn_count\n  - Keep discussion on track\n- If consensus reached\n  - Summarize decisions\n  - Assign action items\n- End meeting\n- Return meeting summary\n</code></pre>"},{"location":"programming-guide/#pattern-collecting-inputs-from-user","title":"Pattern: Collecting Inputs from User","text":"<p>When your agent needs information from the user, always ask for all inputs at once and establish a clear conversation loop until all valid data is acquired:</p> <pre><code>## Main\n### Steps\n- Ask user for $email and $pin, engage in a conversation till user provides valid values or gives up\n- If user gives up, apologize and return\n- Inform user that you were able to authenticate them\n</code></pre> <p>This pattern:</p> <ul> <li>Asks for all required information upfront - more efficient for the user</li> <li>Includes a clear termination condition - handles the case where user wants to exit</li> <li>Validates both inputs before proceeding - ensures data quality</li> <li>Avoids sequential asking - better user experience than asking one at a time</li> </ul> <p>Why this matters: Asking for information piece by piece creates a poor user experience. Users appreciate knowing all requirements upfront.</p>"},{"location":"programming-guide/#pattern-mock-backend-interactions-with-python-playbooks","title":"Pattern: Mock Backend Interactions with Python Playbooks","text":"<p>Think if a certain action would require backend interaction (databases, APIs, authentication services). If so, use Python playbooks to encapsulate that logic. Use mock implementations as necessary to aid in development:</p> <pre><code>```python\n@playbook\nasync def AuthenticateUser($email: str, $pin: str) -&gt; bool:\n    \"\"\"Authenticate user with email and PIN.\n\n    In production, this would call the actual authentication service.\n    For now, using mock data for development.\n    \"\"\"\n    # Mock implementation for development\n    return $email == \"test@test.com\" and $pin == \"1234\"\n\n@playbook  \nasync def FetchUserProfile($user_id: str) -&gt; dict:\n    \"\"\"Fetch user profile from database.\n\n    Production: Query user database\n    Development: Return mock data\n    \"\"\"\n    # Mock implementation\n    return {\n        \"id\": $user_id,\n        \"name\": \"Test User\",\n        \"preferences\": {\"theme\": \"dark\"}\n    }\n```\n\n## Main\n### Steps\n- Ask user for $email and $pin, engage in a conversation till user provides valid values or gives up\n- Authenticate user\n- If user is authenticated\n  - Fetch user profile\n  - Welcome user by name from profile\n- Otherwise\n  - Tell user authentication failed\n</code></pre> <p>This pattern:</p> <ul> <li>Separates backend logic - keeps the workflow clean and focused</li> <li>Enables rapid prototyping - test workflows without backend dependencies  </li> <li>Makes transition to production easier - just swap mock with real implementation</li> <li>Documents backend contracts - clear interface for what backend needs to provide</li> <li>Testable - mock data allows thorough testing of workflows</li> </ul> <p>When to use Python playbooks for backend:</p> <ul> <li>Database queries or updates</li> <li>External API calls</li> <li>Authentication/authorization checks</li> <li>Complex business logic calculations</li> <li>File I/O operations</li> <li>Any stateful operations</li> </ul>"},{"location":"programming-guide/#best-practices-summary","title":"Best Practices Summary","text":"<p>DO:</p> <ul> <li>\u2705 Write playbook descriptions for humans - explain what and why</li> <li>\u2705 Use natural language unless explicitness helps</li> <li>\u2705 Add <code>### Notes</code> for business rules</li> <li>\u2705 Prefer Markdown for workflows, Python for logic</li> <li>\u2705 Extract 4+ Python playbooks to MCP server</li> <li>\u2705 Make cross-agent playbooks <code>public: true</code></li> <li>\u2705 Use triggers sparingly - mainly for input validation</li> <li>\u2705 Handle edge cases and errors gracefully</li> <li>\u2705 Use meaningful variable names</li> <li>\u2705 Break complex playbooks into smaller ones</li> <li>\u2705 Test with different user inputs mentally</li> <li>\u2705 Ask for all required information at once with conversation loops</li> <li>\u2705 Use mock Python playbooks for backend processes during development</li> </ul> <p>DON'T:</p> <ul> <li>\u274c Over-engineer simple flows</li> <li>\u274c Create too many tiny playbooks</li> <li>\u274c Use Raw mode unless truly needed</li> <li>\u274c Ignore error cases</li> <li>\u274c Make circular agent dependencies</li> <li>\u274c Use explicit syntax when natural language is clear</li> <li>\u274c Forget to document cross-agent contracts</li> <li>\u274c Overuse triggers - prefer explicit calls when flow is clearer</li> <li>\u274c Use triggers for sequential logic</li> <li>\u274c Ask for inputs one at a time when you need multiple pieces of information</li> <li>\u274c Mix backend API calls directly into workflow steps</li> </ul>"},{"location":"programming-guide/#editing-existing-programs","title":"Editing Existing Programs","text":""},{"location":"programming-guide/#surgical-editing-principles","title":"Surgical Editing Principles","text":"<p>When modifying existing Playbooks programs:</p> <ol> <li>Read and understand: Review the file, understand its structure and intent</li> <li>Minimal changes: Change only what's needed to achieve the goal</li> <li>Preserve style: Match existing natural language vs explicit style</li> <li>Maintain consistency: Keep variable naming and structure patterns</li> <li>Test mentally: Think through execution flow after changes</li> </ol>"},{"location":"programming-guide/#common-edit-patterns","title":"Common Edit Patterns","text":"<p>Adding a new playbook: <pre><code># Existing Agent\n\n## Existing Playbook\n### Steps\n- Existing logic\n\n&lt;!-- ADD NEW PLAYBOOK HERE --&gt;\n## NewPlaybook($param)\nDescription\n\n### Steps\n- New logic\n</code></pre></p> <p>Modifying steps:</p> <ul> <li>Find the playbook to modify</li> <li>Locate specific step</li> <li>Update just that step</li> <li>Ensure variable references still work</li> </ul> <p>Adding a trigger: <pre><code>## ExistingPlaybook\n&lt;!-- ADD THIS SECTION IF MISSING --&gt;\n### Triggers\n- When condition is met\n\n### Steps\n- Existing steps\n</code></pre></p> <p>Adding agent behavior:</p> <pre><code># ExistingAgent\n&lt;!-- MODIFY THIS DESCRIPTION --&gt;\nExisting description. NEW BEHAVIOR: Additional personality trait or capability.\n</code></pre> <p>Converting natural to explicit:</p> <pre><code>&lt;!-- BEFORE --&gt;\n- Get order details and tell user\n\n&lt;!-- AFTER (if user requests more structure) --&gt;\n- $order = GetOrderDetails($order_id)\n- Tell user about $order\n</code></pre>"},{"location":"programming-guide/#example-edit-request","title":"Example Edit Request","text":"<p>Request: \"Add validation to ensure order ID is 8 digits\"</p> <p>Process:</p> <ol> <li>Locate where order ID is collected</li> <li>Add validation playbook</li> <li>Add trigger to invoke validation</li> <li>Update main flow to handle invalid input</li> </ol> <pre><code>## Main\n### Steps\n- Ask user for their $order_id till valid  &lt;!-- MODIFIED --&gt;\n- Process order\n\n## ValidateOrderId  &lt;!-- NEW PLAYBOOK --&gt;\n### Triggers\n- When user provides order id\n### Steps\n- If $order_id is not 8 digits\n  - Tell user order ID must be 8 digits\n  - Ask for order ID again\n</code></pre>"},{"location":"programming-guide/#understanding-pbasm-compilation","title":"Understanding PBAsm Compilation","text":""},{"location":"programming-guide/#why-pbasm-matters","title":"Why PBAsm Matters","text":"<p>When you write Playbooks, the compiler transforms it to Playbooks Assembly Language (PBAsm):</p> <ul> <li>Adds explicit types: <code>$name</code> \u2192 <code>$name:str</code></li> <li>Adds line numbers: Hierarchical (01, 01.01, 01.01.01)</li> <li>Adds opcodes: QUE (queue), CND (conditional), RET (return), YLD (yield)</li> <li>Explicit yields: Shows when LLM yields control</li> <li>Trigger labels: T1:BGN, T2:CND, etc.</li> </ul>"},{"location":"programming-guide/#compilation-example","title":"Compilation Example","text":"<p>Source (Playbooks):</p> <pre><code>## GreetUser\n### Triggers\n- At the beginning\n### Steps\n- Ask user for their name\n- If name provided\n  - Thank user by name\n- Otherwise\n  - Ask again\n</code></pre> <p>Compiled (PBAsm):</p> <pre><code>## GreetUser() -&gt; None\n### Triggers\n- T1:BGN At the beginning\n### Steps\n- 01:QUE Say(user, Ask user for their $name:str); YLD for user\n- 02:CND If $name is provided\n  - 02.01:QUE Say(user, Thank user by $name); YLD for call\n- 03:CND Otherwise  \n  - 03.01:QUE Say(user, Ask for $name again); YLD for user\n- 04:RET\n</code></pre>"},{"location":"programming-guide/#key-pbasm-concepts","title":"Key PBAsm Concepts","text":"<p>Opcodes (like CPU instructions):</p> <ul> <li><code>QUE</code> - Queue operation (function call, Say)</li> <li><code>CND</code> - Conditional/loop</li> <li><code>RET</code> - Return from playbook</li> <li><code>YLD</code> - Yield control to runtime</li> <li><code>EXE</code> - Execute assignment/action</li> <li><code>TNK</code> - Think deeply</li> <li><code>JMP</code> - Jump to line (loops)</li> </ul> <p>Yield Reasons (why LLM pauses):</p> <ul> <li><code>YLD for user</code> - Wait for user input</li> <li><code>YLD for call</code> - Execute queued calls</li> <li><code>YLD for agent</code> - Wait for agent message</li> <li><code>YLD for meeting</code> - Wait for meeting message</li> <li><code>YLD for exit</code> - End program</li> </ul> <p>Line Numbers (like assembly addresses):</p> <ul> <li>Hierarchical: 01, 01.01, 01.02, 01.02.01</li> <li>Enable jumps for loops</li> <li>Track execution position</li> </ul>"},{"location":"programming-guide/#why-this-helps-you","title":"Why This Helps You","text":"<ol> <li>Debugging: When user reports issues, think about PBAsm execution</li> <li>Precision: Know that fuzzy NL gets converted to structured form</li> <li>Optimization: Understand when LLM calls happen (at YLD points)</li> <li>Reasoning: Picture how LLM executes line by line</li> </ol>"},{"location":"programming-guide/#you-dont-need-to-write-pbasm","title":"You Don't Need to Write PBAsm","text":"<ul> <li>\u274c Never write PBAsm directly</li> <li>\u2705 Write natural Playbooks language</li> <li>\u2705 Compiler handles transformation</li> <li>\u2705 Understanding PBAsm helps debugging and optimization</li> </ul>"},{"location":"programming-guide/#quick-reference","title":"Quick Reference","text":""},{"location":"programming-guide/#minimal-working-program","title":"Minimal Working Program","text":"<pre><code># MyAgent\nDescription of what this agent does\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Greet user\n- Ask user what they need help with\n- Help them\n- End program\n</code></pre>"},{"location":"programming-guide/#more-complex-example","title":"More complex example","text":"<pre><code># Hello world agent\nA demo customer support agent for Playbooks AI\n\n```python\n@playbook\nasync def SendOTP(phone_number: str) -&gt; dict:\n    \"\"\"\n    Send OTP to user's phone number via backend service.\n\n    In production, this would call the actual SMS/OTP service.\n    For development, using mock implementation.\n\n    Args:\n        phone_number: User's phone number\n\n    Returns:\n        Dictionary with status and OTP (in dev mode only)\n    \"\"\"\n    # Mock implementation for development\n    # In production, this would call your SMS service\n    import random\n    otp = str(random.randint(1000, 9999))\n\n    # Simulate successful send\n    return {\n        \"status\": \"success\",\n        \"message\": f\"OTP sent to {phone_number}\",\n        \"otp\": otp  # Only for development - remove in production\n    }\n\n@playbook\nasync def ValidateOTP(phone_number: str, otp: str) -&gt; bool:\n    \"\"\"\n    Validate OTP against backend service.\n\n    In production, this would verify OTP with your authentication service.\n    For development, using mock validation.\n\n    Args:\n        phone_number: User's phone number\n        otp: OTP code provided by user\n\n    Returns:\n        True if OTP is valid, False otherwise\n    \"\"\"\n    # Mock implementation for development\n    # In production, this would validate against your backend\n\n    # For demo: accept any 4-digit OTP\n    # In real system, verify against stored OTP with expiration\n    return len(otp) == 4 and otp.isdigit()\n```\n\n## Main\n\n### Triggers\n- At the beginning\n\n### Steps\n- Welcome user\n- Authenticate user\n- If authentication successful\n  - Tell user about Playbooks AI\n  - Ask the user for their $name\n  - Say hello to the user by $name\n  - Welcome user to Playbooks AI\n- Otherwise\n  - Tell user authentication failed\n  - Apologize and end program\n- End program\n\n## AuthenticateUser\nAuthenticate user by collecting phone number, sending OTP, and validating the code.\n\n### Steps\n- Ask user for their $phone_number, engage in conversation till user provides a valid phone number or gives up\n- If user gives up\n  - Return authentication failure\n- Send OTP to $phone_number\n- Tell user that OTP has been sent to their phone number\n- Ask user for the $otp they received, engage in conversation till user provides it or gives up\n- If user gives up\n  - Return authentication failure\n- Validate the OTP\n- If OTP is valid\n  - Return authentication success\n- Otherwise\n  - Tell user that the OTP didn't work\n  - Ask if user want to enter a different one or would like another OTP\n  - If usre provided a new OTP\n    - jump back to validating it\n  - If user wants to try again\n    - jump back to asking/validating OTP or sending a new one as appropriate\n  - If user want to give up\n    - Return authentication failure\n\n## ValidatePhoneNumber\n### Triggers\n- When user provides phone number\n\n### Steps\n- Check if $phone_number is a valid US phone number or not\n</code></pre>"},{"location":"programming-guide/#cheat-sheet","title":"Cheat Sheet","text":"Task Code Define agent <code># AgentName</code> Define playbook <code>## PlaybookName($param)</code> Add trigger <code>### Triggers</code><code>- When condition</code> Add steps <code>### Steps</code><code>- Step 1</code> Variable <code>$variable_name</code> Typed variable <code>$count:int</code> Assignment <code>$var = value</code> Condition <code>If condition</code><code>- Then step</code> Loop <code>While condition</code><code>- Loop step</code> Return <code>Return value</code> End program <code>End program</code> Call playbook <code>PlaybookName($arg)</code> Cross-agent call <code>OtherAgent.PlaybookName($arg)</code> Python playbook <code>@playbook</code><code>async def Name(): ...</code> Public playbook <code>public: true</code> ReAct playbook No <code>### Steps</code> section Raw playbook <code>execution_mode: raw</code> Meeting playbook <code>meeting: true</code> Save artifact <code>SaveArtifact(\"name\", \"desc\", $content)</code> Load artifact <code>LoadArtifact(\"name\")</code> Placeholder <code>{$variable}</code> or <code>{expression}</code>"},{"location":"programming-guide/#programming-principles","title":"Programming Principles","text":"<p>When writing Playbooks programs:</p> <ol> <li>Understand intent: What problem are you solving? What is the goal?</li> <li>Choose right types: Markdown for workflows, Python for logic, ReAct for research</li> <li>Natural first: Start with natural language, add explicitness if needed</li> <li>Think decomposition: Break into logical playbooks with clear responsibilities</li> <li>Extract to MCP: If you have 4+ Python playbooks, extract them to an MCP server</li> <li>Handle errors: Consider edge cases and failure modes</li> <li>Write idiomatically: Follow patterns and conventions from examples</li> <li>Document choices: Explain intent in descriptions and comments</li> <li>Iterate: Start simple, add complexity as needed</li> </ol> <p>Remember: You're writing Software 3.0 - programs that execute on LLMs. Embrace natural language while maintaining precision. The compiler and runtime handle the complexity.</p>"},{"location":"programming-guide/#for-ai-coding-assistants","title":"For AI Coding Assistants","text":"<p>When helping users write Playbooks programs:</p> <ul> <li>Think deeply, plan in detail and review the plan before writing any code</li> <li>Follow all the principles and patterns in this guide</li> <li>Prefer natural language over explicit syntax unless clarity demands it</li> <li>Always consider if 4+ Python playbooks should be extracted to an MCP server</li> <li>Use triggers sparingly - mainly for input validation</li> <li>Explain your architectural choices to help users learn</li> <li>Iterate based on user feedback and requirements</li> <li>Make sure that the program reads like a human wrote it and something that an AI model would be able to understand and execute</li> <li>If you need to write many python functions, put them into an MCP server with mock or real implementations as appropriate.</li> <li>Make sure to write ideomatic Playbooks code that uses Playbooks capabilities optimally to produce minimal, clean, readable, well organized Playbooks programs.</li> <li>When converting/importing/migrating from LangGraph, CrewAI, etc. agent frameworks, make sure to produce the same behavior, but also represented using all of Playbooks capabilities which may produce significantly concise implementation compared to LangGraph.</li> </ul> <p>Happy building! \ud83d\ude80</p>"},{"location":"reference/","title":"Playbooks Reference Documentation","text":"<p>This section contains the reference documentation for the Playbooks framework.</p>"},{"location":"reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Configuration System</li> <li>Supported Models</li> <li>Playbooks AI</li> <li>Playbooks Language</li> <li>Playbooks Assembly Language</li> <li>Agents</li> <li>MCP based Agents</li> <li>Exported and Public Playbooks</li> <li>Playbook Types</li> <li>Built-in Playbooks</li> <li>Triggers</li> <li>Context Engineering</li> <li>Description Placeholders</li> </ul>"},{"location":"reference/agents/","title":"Agents","text":"<p>Agents are first-class runtime entities in Playbooks. They can:</p> <ul> <li>Run their own playbooks</li> <li>Send messages to other agents</li> <li>Call other agents\u2019 public playbooks directly</li> <li>Participate in multi-agent meetings</li> </ul> <p>In multi-agent programs, use natural language to specify messaging, meetings, and public playbook calls.</p>"},{"location":"reference/agents/#playbooks-ai-agents","title":"Playbooks AI Agents","text":""},{"location":"reference/agents/#create-an-agent","title":"Create an agent","text":"<p>It is easy to create an AI agent using Playbooks.</p> <pre><code># Hello World Agent\nThis is a simple agent that says hello world.\n\n## Main\n\n### Trigger\n- When program starts\n\n### Steps\n- Say Hello World!\n- End program\n</code></pre> <p>This creates a Hello World agent.</p>"},{"location":"reference/agents/#create-multiple-agents","title":"Create multiple agents","text":"<p>A program is a collection of agents. Agents that are part of a program can natively call each other's public playbooks.</p> <pre><code># Agent 1\n## PB1\npublic: true\n### Steps\n- Say Hello\n\n# Agent 2\n## PB2\n### Trigger\n- When program starts\n### Steps\n- call Agent 1's PB1\n- end program\n</code></pre>"},{"location":"reference/agents/#create-an-agent-backed-by-an-mcp-server","title":"Create an agent backed by an MCP server","text":"<p>It is easy to create an agent that exposes tools from an MCP server as playbooks.</p> <p>Say we have an MCP server running at <code>http://localhost:8088/mcp</code> that exposes a <code>get_weather(zipcode: int) -&gt; dict</code> tool that takes a zipcode and returns a weather report.</p> <pre><code># MCP Agent\nremote:\n  type: mcp\n  transport: streamable-http\n  url: http://localhost:8088/mcp\n\n# Local Agent\n## Main\n### Trigger\n- When program starts\n### Steps\n- ask the user for a zipcode\n- get the weather for that zipcode from MCP Agent\n- describe the weather to the user\n- end program\n</code></pre>"},{"location":"reference/builtin-playbooks/","title":"Built-in Playbooks","text":"<p>Playbooks framework comes with a set of built-in playbooks that are available to every agent without requiring explicit import or definition. These playbooks handle common operations like communication, artifact management, and program control flow.</p>"},{"location":"reference/builtin-playbooks/#overview","title":"Overview","text":"<p>Built-in playbooks fall into two categories:</p> <ol> <li>Callable Playbooks - Available for use in your playbooks (e.g., <code>Say</code>, <code>SendMessage</code>, <code>SaveArtifact</code>)</li> <li>Hidden/Internal Playbooks - Used internally by the system (marked with <code>hidden=True</code>) that should not be used in Playbooks</li> </ol>"},{"location":"reference/builtin-playbooks/#available-built-in-playbooks","title":"Available Built-in Playbooks","text":""},{"location":"reference/builtin-playbooks/#saytarget-str-message-str","title":"<code>Say(target: str, message: str)</code>","text":"<p>Sends a message to a specified target (agent or user).</p> <p>Example usage: <pre><code>### Steps\n- Welcome the user\n- Ask user for account number\n- Ask Account Management Agent to handle customer's account inquiry\n</code></pre></p>"},{"location":"reference/builtin-playbooks/#sendmessagetarget_agent_id-str-message-str","title":"<code>SendMessage(target_agent_id: str, message: str)</code>","text":"<p>(Hidden/Internal Playbook) Internal implementation of <code>Say</code></p>"},{"location":"reference/builtin-playbooks/#waitformessagesource_agent_id-str-str-none","title":"<code>WaitForMessage(source_agent_id: str) -&gt; str | None</code>","text":"<p>(Hidden/Internal Playbook)</p> <p>Waits for a message from a specific agent or user. This is a low-level communication primitive typically used internally for agent-to-agent coordination.</p> <p>For example, when executing a step like <code>\"Ask user for account number\"</code>, the playbook will send a message to the user using <code>SendMessage(\"human\", \"What is your account number?\")</code> and wait for the user's response using <code>WaitForMessage(\"human\")</code>.</p>"},{"location":"reference/builtin-playbooks/#saveartifactartifact_name-str-artifact_summary-str-artifact_content-str","title":"<code>SaveArtifact(artifact_name: str, artifact_summary: str, artifact_content: str)</code>","text":"<p>Saves data as a named artifact for later retrieval.</p> <p>Example: <pre><code>### Steps\n- Generate a detailed analysis report\n- SaveArtifact(\"quarterly_report.md\", \"Q3 2023 Sales Analysis\", generated report)\n- Tell the user the report has been saved as Artifact[\"quarterly_report.md\"]\n</code></pre></p>"},{"location":"reference/builtin-playbooks/#loadartifactartifact_name-str","title":"<code>LoadArtifact(artifact_name: str)</code>","text":"<p>Artifacts are not included in the LLM context by default because they can be large. When you need to operate on the contents of an artifact, load the artifact first. This will yield execution back to the runtime, which will include the artifact in the LLM context and resume playbook execution.</p> <p>Example: <pre><code>### Steps\n- LoadArtifact(\"Q1_report.md\")\n- LoadArtifact(\"Q2_report.md\")\n- LoadArtifact(\"Q3_report.md\")\n- LoadArtifact(\"Q4_report.md\")\n- Analyze the content of the quarterly reports and generate annual report\n- SaveArtifact(\"annual_report.md\", \"Annual Report\", generated annual report)\n</code></pre></p>"},{"location":"reference/builtin-playbooks/#createagentagent_klass-str-kwargs","title":"<code>CreateAgent(agent_klass: str, **kwargs)</code>","text":"<p>Creates and starts a new agent dynamically during runtime.</p> <p>Example: <pre><code>### Steps\n- Create a new SupportAgent with approprate name\n- Ask the support agent to handle customer inquiry\n- Wait for the agent's response\n</code></pre></p>"},{"location":"reference/builtin-playbooks/#invitetomeetingmeeting_id-str-attendees-list","title":"<code>InviteToMeeting(meeting_id: str, attendees: list)</code>","text":"<p>Invites additional agents to an existing meeting for multi-agent collaboration.</p> <p>Example: <pre><code>### Steps\n- Start a meeting with Accountant and CFO\n- Invite Data analyst and Project manager to the meeting\n</code></pre></p>"},{"location":"reference/builtin-playbooks/#loadfilefile_path-str-inline-bool-false-silent-bool-false","title":"<code>Loadfile(file_path: str, inline: bool = False, silent: bool = False)</code>","text":"<p>Loads content from a file in the filesystem. This is used in description placeholders to load reference materials to execute the playbook.</p> <p>Example: <pre><code>## Generate a summary($document)\nThis playbook generates summary of the given document.\nUse the following format: {Loadfile(\"summary-format.txt\")}\n</code></pre></p>"},{"location":"reference/config/","title":"Playbooks Configuration System","text":"<p>Playbooks uses <code>playbooks.toml</code> file for configuration. </p>"},{"location":"reference/config/#default-configuration","title":"Default Configuration","text":"<p>The default configuration is in the <code>playbooks</code> package here.</p> playbooks.toml<pre><code>debug = true\ntimeout_s = 60\n\n[model]\nprovider = \"anthropic\"\nname = \"claude-sonnet-4-20250514\"\ntemperature = 0.2\n\n# Specific model overrides can be added\n# [model.execution]\n# [model.compilation]\n\n[llm_cache]\nenabled = true\ntype = \"disk\"\npath = \".llm_cache\"\n\n[langfuse]\nenabled = false\n</code></pre> <p>See config.py for how to override the default configuration.</p> <p>$TODO: Add friendly documentation here.</p>"},{"location":"reference/context-engineering/","title":"Context Engineering","text":"<p>Playbooks automates context engineering, allowing you to focus on writing agent logic while the framework intelligently manages LLM context. This automated approach ensures efficient token usage and optimal performance without manual intervention.</p>"},{"location":"reference/context-engineering/#key-innovations","title":"Key Innovations","text":"<ul> <li> <p>Stack-based Context Management Automatically compacts context as playbooks complete, preserving semantic information while reducing token usage.</p> </li> <li> <p>Prompt Caching Optimization Intelligently manages context to maximize cache hits, reducing latency and API costs by up to 10x.</p> </li> <li> <p>Programmer Control Programmers have control over through specific control mechanisms.</p> </li> </ul>"},{"location":"reference/context-engineering/#stack-based-context-management","title":"Stack-based Context Management","text":"<p>Playbooks uses a stack-based approach to manage LLM context dynamically. As playbooks execute and return, their detailed execution traces are automatically replaced with concise summaries, keeping context focused and efficient.</p>"},{"location":"reference/context-engineering/#how-it-works","title":"How It Works","text":"<p>Consider this call stack in a running Playbooks program:</p> <pre><code>Main\n  \u2514\u2500 GetOrderStatus\n      \u2514\u2500 SummarizeOrderStatus\n</code></pre> <p>During Execution: - When <code>SummarizeOrderStatus</code> is active, the context includes the full execution trace from <code>Main</code> \u2192 <code>GetOrderStatus</code> \u2192 <code>SummarizeOrderStatus</code> - All playbook instructions, inputs, outputs, and intermediate steps are preserved in context</p> <p>After Playbook Returns: - When <code>SummarizeOrderStatus</code> completes, its detailed execution trace is replaced with a summary - When <code>GetOrderStatus</code> returns to <code>Main</code>, both its traces are replaced with summary - So, when <code>Main</code> playbook continues after <code>GetOrderStatus</code> returns, it has a compact context containing only the summary of <code>GetOrderStatus</code> execution, thus reducing context size and token usage</p>"},{"location":"reference/context-engineering/#prompt-caching-optimization","title":"Prompt Caching Optimization","text":"<p>Playbooks intelligently leverages prompt caching to minimize latency and reduce API costs. The framework automatically manages cache-friendly context structures.</p>"},{"location":"reference/context-engineering/#how-prompt-caching-works","title":"How Prompt Caching Works","text":"<p>Prefix Caching:</p> <ol> <li>LLM providers cache the activations of prompt prefixes. Some LLM providers cache prefixes at specified locations in the context. some LLM providers charge extra for adding cache entries.</li> <li>When a new request arrives, the longest matching cached prefix is identified</li> <li>Cached activations are restored, avoiding reprocessing</li> <li>Only tokens beyond the prefix are processed</li> </ol> <p>Performance Impact:</p> <ul> <li>Cached tokens: ~10x cheaper and faster than regular tokens</li> <li>Cache hit on a 5,000 token prefix saves seconds of latency and significant cost</li> </ul>"},{"location":"reference/context-engineering/#playbooks-cache-strategy","title":"Playbooks Cache Strategy","text":"<p>The framework automatically:</p> <ol> <li> <p>Sets Strategic Cache Points Places cache boundaries at stable context segments and prioritizes frequently reused prefixes (system prompts, playbook definitions, call points). Claude allows a maximum of 4 cache points in the context, which the frameworks selects intelligently.</p> </li> <li> <p>Balances Cache Efficiency There are competing factors to balance when it comes to using the cache effectively, while compacting the context to reduce token usage.</p> <ul> <li> <p>The oldest part of the context is the best candidate to be compacted because those details may not be relevant to the current execution. But compacting the oldest part invalidates the prefix cache completely.</p> </li> <li> <p>Compacting the newest part of the context allows for long cache prefix hits, but it may not be the best candidate to be compacted because those details may be relevant to the current execution.</p> </li> <li> <p>As a result, Playbooks framework compacts the middle part of the context, which balances between preserving cache prefix and preserving context for the current execution.</p> </li> <li> <p>Note that as the program proceeds and call stack unwinds, what was the middle part of the context may become the current execution part and thus what was previously compacted away may need to be added back at full detail. This is handled automatically by the framework by preserving the full uncompacted context and progressively adjusting the context on every LLM call.</p> </li> </ul> </li> </ol>"},{"location":"reference/context-engineering/#programmer-control-over-context","title":"Programmer Control Over Context","text":"<p>While Playbooks automates context management, you retain full control when needed for specialized scenarios.</p>"},{"location":"reference/context-engineering/#control-mechanisms","title":"Control Mechanisms","text":"<p>Raw Prompt Playbooks - Write literal prompt text that bypasses automatic context management - Useful for expert and narrow prompt engineering scenarios</p> <p>Description Placeholders - Inject dynamic values into playbook descriptions - Inject either inline in the description or as a separarate LLM message.</p>"},{"location":"reference/description-placeholders/","title":"Description Placeholders","text":"<p>Description placeholders allow you to inject dynamic content into playbook descriptions using Python expressions. This enables runtime customization of the context sent to the LLM without modifying the playbook definition.</p>"},{"location":"reference/description-placeholders/#overview","title":"Overview","text":"<p>Placeholders use the <code>{expression}</code> syntax within playbook descriptions. At runtime, these expressions are evaluated and replaced with their values before the description is sent to the LLM.</p> <p>Key characteristics:</p> <ul> <li>Evaluated once when the playbook begins execution</li> <li>Support variables, playbook calls, and Python expressions</li> <li>Available in all LLM-executed playbook types (Markdown, ReAct, Raw Prompt)</li> <li>Resolved before LLM sees the description</li> </ul>"},{"location":"reference/description-placeholders/#basic-syntax","title":"Basic Syntax","text":"<p>Use curly braces <code>{}</code> to embed expressions in descriptions:</p> <pre><code>## ProcessOrder\nThis playbook processes order {$order_id} for customer {$customer_name}\n</code></pre> <p>When executed, placeholders are resolved to actual values:</p> <pre><code>This playbook processes order 12345 for customer John Smith\n</code></pre>"},{"location":"reference/description-placeholders/#what-you-can-use-in-placeholders","title":"What You Can Use in Placeholders","text":"<ul> <li>All state variables</li> <li>All playbooks and functions</li> <li>Standard Python built-ins</li> <li>Special variables listed below</li> <li>All imported modules from all <code>```python</code> blocks in the agent</li> </ul>"},{"location":"reference/description-placeholders/#1-variables","title":"1. Variables","text":"<p>Reference any variable from the current execution state:</p> Variable placeholder example<pre><code>## ReviewTransaction\nReview transaction {$transaction_id} with amount ${$amount}\n\n### Steps\n- Verify the transaction details\n- Process the review\n</code></pre> <p>Variable syntax:</p> <ul> <li><code>{$variable_name}</code> - Recommended, explicit</li> <li><code>{variable_name}</code> - Also works, <code>$</code> prefix is optional</li> </ul>"},{"location":"reference/description-placeholders/#2-playbook-calls","title":"2. Playbook Calls","text":"<p>Call other playbooks to generate dynamic content:</p> Calling other playbooks example<pre><code>## AnswerQuestions\nThis playbook answers questions about quarterly summaries.\n\nQ1 Summary: {QuarterlySummary(\"Q1\")}\nQ2 Summary: {QuarterlySummary(\"Q2\")}\nQ3 Summary: {QuarterlySummary(\"Q3\")}\nQ4 Summary: {QuarterlySummary(\"Q4\")}\n\n### Steps\n- Answer user questions based on the summaries above\n</code></pre> <p>Key points:</p> <ul> <li>Playbook calls are awaited automatically, no need to use <code>await</code> keyword</li> <li>Return values are converted to strings</li> <li>Can pass arguments like regular function calls</li> </ul> <p>When the playbook executes:</p> <ol> <li>Each <code>QuarterlySummary(quarter)</code> call executes</li> <li>Results replace the placeholders</li> <li>LLM sees the full context with all quarterly data</li> </ol>"},{"location":"reference/description-placeholders/#3-python-expressions","title":"3. Python Expressions","text":"<p>Use any valid Python expression:</p> Python expression example<pre><code>## AnalyzePerformance\nPerformance score: {round($score * 100, 2)}%\nStatus: {\"Excellent\" if $score &gt; 0.9 else \"Good\" if $score &gt; 0.8 else \"Needs Improvement\"}\nItems to process: {len([x for x in $items if x.active])}\nTimestamp: {timestamp.strftime(\"%Y-%m-%d %H:%M:%S\")}\n\n### Steps\n- Analyze the performance data\n- Generate recommendations\n</code></pre>"},{"location":"reference/description-placeholders/#4-special-variables","title":"4. Special Variables","text":"<p>Access agent information and execution context:</p> <pre><code>## DebugInfo\nCurrent agent: {agent.klass}\nExecuting playbook: {call.playbook_name}\nAgent state: {agent.state.variables}\nCurrent time: {timestamp}\n</code></pre> <p>Available special variables:</p> <ul> <li> <p><code>agent</code> - The agent instance</p> <ul> <li><code>agent.klass</code> - Agent class name</li> <li><code>agent.state</code> - Current execution state</li> <li><code>agent.namespace_manager.namespace</code> - Available functions</li> </ul> </li> <li> <p><code>call</code> - Current playbook call</p> <ul> <li><code>call.playbook_name</code> - Name of the playbook</li> <li><code>call.args</code> - Positional arguments</li> <li><code>call.kwargs</code> - Keyword arguments</li> </ul> </li> <li> <p><code>timestamp</code> - Current datetime object</p> </li> </ul>"},{"location":"reference/description-placeholders/#security","title":"Security","text":"<p>The expression evaluator implements security safeguards:</p> <p>Blocked operations:</p> <ul> <li><code>subprocess</code>, <code>eval</code>, <code>exec</code></li> <li><code>__import__</code>, <code>open</code></li> <li>Access to <code>__globals__</code>, <code>__locals__</code></li> </ul>"},{"location":"reference/description-placeholders/#error-handling","title":"Error Handling","text":"<p>If an expression fails to evaluate, the error will be returned as the expression value and inserted into the description.</p>"},{"location":"reference/description-placeholders/#single-evaluation","title":"Single Evaluation","text":"<p> Placeholders are resolved once when the playbook begins execution and are not re-evaluated during playbook execution.</p>"},{"location":"reference/exported-and-public-playbooks/","title":"Exported and Public Playbooks","text":""},{"location":"reference/exported-and-public-playbooks/#exported-playbooks","title":"Exported Playbooks","text":"<p>Exported playbooks are a powerful feature of Playbooks AI that allows an agent to execute playbooks defined by another agent within its own execution context as if they were implemented locally within the importing agent.</p> <p> Playbooks AI's exported playbooks capability is significantly more powerful than MCP's prompts because it enables true capability sharing and execution between agents, not just structured guidance. While MCP prompts are valuable for standardizing LLM interactions, Playbooks AI enables building extensible agent ecosystems with genuine code reuse and modular architectures.</p>"},{"location":"reference/exported-and-public-playbooks/#public-playbooks","title":"Public Playbooks","text":"<p>When an agent marks a playbook as public, another agent can call that playbook remotely.</p> <p> Public playbooks are similar to MCP's tools. When a client calls a tool, it is executed on the MCP server. Similarly, when an agent calls a public playbook on another agent, it is executed on the called agent's server.</p>"},{"location":"reference/exported-and-public-playbooks/#how-exported-playbooks-work","title":"How Exported Playbooks Work","text":"<p>When an agent exports a playbook, another agent can import implementation of that playbook and then execute that playbook within its execution context.</p>"},{"location":"reference/exported-and-public-playbooks/#exporting-playbooks","title":"Exporting Playbooks","text":"<p> This feature under active development and not available yet.</p> <p>Exported playbooks are marked using the <code>export: true</code> metadata:</p> <pre><code># AccountManagementAgent\n\n```python\n@playbook(export=True)\nasync def CloseAccount($user_id) -&gt; str:\n    \"\"\"Close an account for a user.\"\"\"\n    # ...\n```\n\n## ProvisionAccount($user_id, $service_tier)\nexport: true\n### Steps\n- ...\n</code></pre> <p>In this example, the <code>AccountManagementAgent</code> exports the <code>CloseAccount</code> and <code>ProvisionAccount</code> playbooks.</p> <p> Implementations of both markdown and Python playbooks can be exported.</p>"},{"location":"reference/exported-and-public-playbooks/#importing-exported-playbook-implementations","title":"Importing Exported Playbook Implementations","text":"<p>To import a playbook's implementation from another remote agent, register that remote agent and then use the <code>import</code> statement:</p> <pre><code># AccountManagementAgent(url=\"https://cloud.runplaybooks.ai/account-management\")\n\n# ServiceAgent\nimport CloseAccount, ProvisionAccount from AccountManagementAgent\n</code></pre> <p>This imports implementations of the <code>CloseAccount</code> Python playbook and the <code>ProvisionAccount</code> markdown playbook from the <code>AccountManagementAgent</code> agent.</p>"},{"location":"reference/exported-and-public-playbooks/#using-imported-playbooks","title":"Using Imported Playbooks","text":"<p>Once imported, you can use the playbook just like any other playbook defined within your agent:</p> <pre><code>## CreateAccount\n### Steps\n- Validate user information\n- Create user record in database\n- ProvisionAccount($user_id, $service_tier)\n- Send welcome email to user\n</code></pre> <p>The imported <code>ProvisionAccount</code> playbook is called as if it were a local playbook.</p>"},{"location":"reference/exported-and-public-playbooks/#how-public-playbooks-work","title":"How Public Playbooks Work","text":"<p> This feature under active development and not available yet.</p> <p>When agent A marks a playbook as public, another agent B can call that playbook remotely on a running instance of agent A.</p>"},{"location":"reference/exported-and-public-playbooks/#marking-playbooks-as-public","title":"Marking Playbooks as Public","text":"<p>To mark a playbook as public, use the <code>public: true</code> metadata:</p> <pre><code># AuthenticationAgent\nThis agent handles user authentication.\n\n## VerifyCredentials($username, $password)\npublic: true\n### Steps\n- Check credentials against secure store\n- Return authentication result and user details if valid\n</code></pre> <p>Both markdown and Python playbooks can be marked as public.</p>"},{"location":"reference/exported-and-public-playbooks/#calling-public-playbooks","title":"Calling Public Playbooks","text":"<p>To call a public playbook, first register the remote agent and then call the playbook as a method on that agent:</p> <pre><code># AuthenticationAgent(url=\"https://cloud.runplaybooks.ai/authentication\")\n\n# APIGatewayAgent\n\n## HandleRequest\n### Steps\n- $auth_result = AuthenticationAgent.VerifyCredentials($request.auth.username, $request.auth.password)\n- ...\n</code></pre> <p>Here, the <code>APIGatewayAgent</code> directly calls the <code>VerifyCredentials</code> playbook on the <code>AuthenticationAgent</code> instance running at <code>https://cloud.runplaybooks.ai/authentication</code>. The playbook is executed on the remote agent's server and the result is returned to the calling agent.</p>"},{"location":"reference/exported-and-public-playbooks/#differences-between-exported-and-public-playbooks","title":"Differences Between Exported and Public Playbooks","text":"<p>Exported playbooks differ from public playbooks in several important ways:</p> Exported Playbooks Public Playbooks Example <code>import CloseAccount from AccountManagementAgent</code> and then <code>CloseAccount($user_id)</code> <code># PaymentProcessingAgent(\"https://cloud.runplaybooks.ai/ppa\")</code> and then <code>PaymentProcessingAgent.ProcessPayment($amount, $payment_method)</code> Execution Context Local execution in importing agent's context Remote procedure call on the remote agent instance State Access Can access local agent's state Cannot access local agent's state"},{"location":"reference/exported-and-public-playbooks/#security-considerations","title":"Security Considerations","text":"<p> Be careful! Importing playbooks raise several security considerations.</p> <ol> <li> <p>Code Injection: An agent that imports playbooks from another agent must trust that agent. Importing playbook implementations from untrusted agents and executing them can lead to security vulnerabilities like code injection attacks.</p> </li> <li> <p>Version Control: Changes to exported playbooks may affect importing agents, requiring careful version management.</p> </li> </ol>"},{"location":"reference/exported-and-public-playbooks/#example-agent-ecosystem","title":"Example: Agent Ecosystem","text":"<p>Let's say that we have an ecosystem of three agents.</p>"},{"location":"reference/exported-and-public-playbooks/#1-databaseagent","title":"1. DatabaseAgent","text":"<pre><code># DatabaseAgent\nThis agent provides recipes for various database related tasks.\n\n## FindTable($query, $database)\nexport: true\n### Steps\n- List all tables in the $database\n- Find the table that is most likely to contain data to answer the $query\n- Return the table name\n</code></pre> <p>Let's say that <code>DatabaseAgent</code> is available at the URL <code>https://cloud.runplaybooks.ai/database.agent</code>. It exports the <code>FindTable</code> playbook. It is a generic procedure for finding a database table.</p>"},{"location":"reference/exported-and-public-playbooks/#2-authenticationagent","title":"2. AuthenticationAgent","text":"<pre><code># AuthenticationAgent\nThis agent handles user authentication.\n\n## VerifyCredentials($username, $password)\npublic: true\n### Steps\n- Check credentials against secure store\n- Return authentication result and user details if valid\n</code></pre> <p>Let's say that an instance of the <code>AuthenticationAgent</code> is running at the URL <code>https://cloud.runplaybooks.ai/authentication.agent</code>. The public <code>VerifyCredentials</code> playbook requires access to the secure store within ACME Corp's infrastructure.</p>"},{"location":"reference/exported-and-public-playbooks/#3-apigatewayagent","title":"3. APIGatewayAgent","text":"<p>APIGatewayAgent uses the above two agents. It first registers those two agents, specifying their URLs. Then it imports the <code>FindTable</code> playbook from the <code>DatabaseAgent</code>. It then remotely calls the <code>VerifyCredentials</code> playbook on the <code>AuthenticationAgent</code> instance. Finally, it locally executes the <code>FindTable</code> playbook.</p> <pre><code># DatabaseAgent(url=\"https://cloud.runplaybooks.ai/database.agent\")\n\n# AuthenticationAgent(url=\"https://cloud.runplaybooks.ai/authentication.agent\")\n\n# APIGatewayAgent\nimport FindTable from DatabaseAgent\n\n## HandleRequest\n### Triggers\n- When an API request is received\n### Steps\n- $auth_result = AuthenticationAgent.VerifyCredentials($request.auth.username, $request.auth.password)\n- If $auth_result.success is true\n  - $table_name = FindTable($request.query, $database)\n  - Return $table_name\n- Otherwise\n  - Return authentication error\n</code></pre>"},{"location":"reference/mcp-agent/","title":"MCP Agents","text":""},{"location":"reference/mcp-agent/#overview","title":"Overview","text":"<p>Connect to external MCP servers and expose their tools as callable playbooks.</p>"},{"location":"reference/mcp-agent/#what-is-mcp","title":"What is MCP?","text":"<p>The Model Context Protocol (MCP) is an open protocol that standardizes how AI applications can access external tools and data sources. MCP servers expose tools that can perform various tasks like:</p> <ul> <li>Accessing databases</li> <li>Making API calls</li> <li>Performing calculations</li> <li>Interacting with file systems</li> <li>Running specialized algorithms</li> <li>And much more</li> </ul>"},{"location":"reference/mcp-agent/#create-an-mcp-agent","title":"Create an MCP agent","text":"<p>To create an MCP agent, you need to specify the agent's metadata with remote configuration:</p> <pre><code># Example MCP Server\nremote:\n  type: mcp\n  url: memory://test\n  transport: memory\n\n# Example MCP Client Agent\n\n## Main\n\n### Triggers\n- When program starts\n\n### Steps\n- get secret from Example MCP Server\n- reveal secret to user\n- end program\n</code></pre>"},{"location":"reference/mcp-agent/#configuration-options","title":"Configuration Options","text":"<p>The MCP agent configuration supports the following options:</p> Option Required Description Default <code>type</code> Yes Must be <code>mcp</code> for MCP agents - <code>url</code> Yes The MCP server URL or command - <code>transport</code> No Transport type (<code>sse</code>, <code>stdio</code>, <code>websocket</code>) <code>sse</code> <code>timeout</code> No Timeout in seconds for tool calls <code>30.0</code> <code>auth</code> No Authentication configuration object <code>{}</code>"},{"location":"reference/mcp-agent/#transport-types","title":"Transport types","text":"<p>MCP agents support different transport protocols:</p> <ul> <li>SSE (Server-Sent Events)</li> <li>stdio</li> <li>WebSocket</li> </ul>"},{"location":"reference/mcp-agent/#how-mcp-agents-work","title":"How MCP Agents Work","text":"<ol> <li>Connection: When the program starts, the MCP agent connects to the specified server</li> <li>Tool Discovery: The agent automatically discovers all available tools from the server</li> <li>Playbook Creation: Each MCP tool becomes a playbook that can be called</li> <li>Execution: When a playbook is called, the agent forwards the request to the MCP server</li> </ol>"},{"location":"reference/mcp-agent/#use-mcp-tools-as-playbooks","title":"Use MCP tools as playbooks","text":"<p>Once connected, all MCP tools are automatically available as playbooks. You can call them just like any other playbook:</p> <pre><code># Weather MCP Agent\nmetadata:\n  remote:\n    type: mcp\n    url: http://weather-service.example.com/mcp\n    transport: sse\n---\nThis agent connects to a weather MCP service.\n\n# Weather Assistant\n## Main\n### Trigger\n- When program starts\n\n### Steps\n- Say \"Welcome to Weather Assistant! What location would you like weather for?\"\n- Get user's location\n- Call Weather MCP Agent's get_current_weather with location=$location\n- Display the weather: \"Current weather in $location: $weather\"\n- End program\n</code></pre>"},{"location":"reference/mcp-agent/#combine-multiple-mcp-agents","title":"Combine multiple MCP agents","text":"<p>You can use multiple MCP agents in a single program:</p> <pre><code># Weather MCP\nmetadata:\n  remote:\n    type: mcp\n    url: http://weather-api.com/mcp\n---\nWeather service integration.\n\n# News MCP\nmetadata:\n  remote:\n    type: mcp\n    url: http://news-api.com/mcp\n---\nNews service integration.\n\n# Assistant\n## DailyBriefing\n### Steps\n- Get weather from Weather MCP's get_current_weather for New York\n- Get news from News MCP's get_top_headlines with technology category\n- Create briefing combining weather and news\n- Present briefing to user\n</code></pre>"},{"location":"reference/mcp-agent/#authentication","title":"Authentication","text":"<p>For MCP servers that require authentication:</p> <pre><code># Secure API Agent\nmetadata:\n  remote:\n    type: mcp\n    url: https://api.example.com/mcp\n    transport: sse\n    auth:\n      type: bearer\n      token: ${API_TOKEN}\n---\nConnects to a secured MCP endpoint.\n</code></pre>"},{"location":"reference/mcp-agent/#run-an-mcp-server-examples","title":"Run an MCP server (examples)","text":"<p>You can create simple MCP servers with <code>fastmcp</code>. Example servers in the repo:</p> <ul> <li>Insomnia server: <code>tests/data/insomnia/mcp.py</code></li> <li>Travel advisor server: <code>tests/data/travel_advisor/mcp.py</code></li> </ul> <p>Run them with:</p> <pre><code>python tests/data/insomnia/mcp.py\npython tests/data/travel_advisor/mcp.py\n</code></pre> <p>Then point your MCP agent <code>url</code> at the server (e.g., <code>http://localhost:8000</code> if using streamable-http) and set <code>transport</code> accordingly.</p>"},{"location":"reference/models/","title":"Models","text":"<p>Playbooks is tested and optimized for the following models:</p> <ul> <li>Anthropic Claude Sonnet 4 (\"claude-sonnet-4-20250514\")</li> <li>PlaybooksLM</li> </ul> <p>Playbooks framework uses complex prompts that are optimized for Sonnet 4. As a result, other frontier LLMs such as GPT-5, Gemini 2.5 Pro and Grok 4 may work, but additional testing and tuning may be required. Our current focus is on improving the core capabilities of the framework and demonstrating a novel way of programming AI agents. We plan to add testing and support for other models gradually. </p> <p> As of Sept 2025, we recommend using Sonnet 4 for experimentation and development.</p> <p>For production use, you may continue using Sonnet 4 or switch to PlaybooksLM for lower latency, lower cost and full control over data privacy &amp; security. PlaybooksLM is a proprietary, Enterprise-grade model developed by Playbooks AI. Please contact us at contact@runplaybooks.ai for more information.</p>"},{"location":"reference/playbook-types/","title":"Playbook Types","text":"<p>Playbooks framework supports multiple types of playbooks, each optimized for different scenarios. This flexibility allows you to choose the right approach for each aspect of your agent's behavior.</p>"},{"location":"reference/playbook-types/#overview","title":"Overview","text":"<p>Playbooks provides five distinct playbook types:</p> <ul> <li>Markdown Playbooks - Structured workflows with explicit steps</li> <li>ReAct Playbooks - Reasoning-based execution with tool usage</li> <li>Raw Prompt Playbooks - Direct LLM prompts with full control</li> <li>Python Playbooks - Complex logic and external integrations</li> <li>External Playbooks - Remote tools and services via MCP or APIs</li> </ul> <p>The power of Playbooks is the ability to mix and compose them seamlessly within a single agent. The frameworks also comes with a set of built-in playbooks.</p>"},{"location":"reference/playbook-types/#markdown-playbooks","title":"Markdown Playbooks","text":"<p>Best for: Prescribed workflows, customer service scripts, structured processes</p> <p>Markdown playbooks define step-by-step workflows in natural language. They are ideal when you know the exact sequence of actions the agent should follow.</p>"},{"location":"reference/playbook-types/#structure","title":"Structure","text":"<pre><code>## PlaybookName($param1, $param2)\nDescription of what this playbook does\n\n### Triggers\n- When user asks for help\n- At the beginning\n\n### Steps\n- Step 1 instruction\n- $variable = Step 2 with assignment\n- If condition\n  - Conditional step\n- Step 3 instruction\n\n### Notes\n- Additional guidance or business rules\n</code></pre>"},{"location":"reference/playbook-types/#key-features","title":"Key Features","text":"<p>Explicit Control Flow - Sequential steps executed in order - Conditional logic (if/else) - Loops (while, for each) - Variable assignments</p> <p>Parameters - Define parameters in the playbook name: <code>PlaybookName($param1, $param2)</code> - Use parameters as variables in steps: <code>$param1</code>, <code>$param2</code></p> <p>Triggers - Define when the playbook should execute - See Triggers for details</p> <p>Notes Section - Provide additional context and business rules - Guide LLM behavior throughout execution</p> <p> You can use natural language or explicit Python-like syntax in the steps. For example, <code>$order_details = GetOrderFromDatabase($order_id)</code>, <code>Get $order_details from the database</code> and <code>Get order details</code> can be equivalent.</p>"},{"location":"reference/playbook-types/#example","title":"Example","text":"<pre><code>## CheckOrderStatus($customer_id)\nCheck the status of a customer's order\n\n### Triggers\n- When user asks about their order\n\n### Steps\n- Ask user for their order id\n- Get order details from the database\n- If order was not found\n  - Tell user we couldn't find that order\n- Otherwise\n  - Tell user order status and when it will arrive\n- End program\n\n### Notes\n- If order is delayed, let user know that they will receive a $10 store credit\n</code></pre>"},{"location":"reference/playbook-types/#when-to-use","title":"When to Use","text":"<p>\u2705 Use Markdown Playbooks when:</p> <ul> <li>Steps are known in advance</li> <li>Process follows a clear, repeatable pattern</li> <li>Need explicit control over execution flow</li> <li>Building customer service workflows or support scripts</li> </ul> <p>\u274c Avoid when:</p> <ul> <li>Steps cannot be predetermined</li> <li>Task requires extensive research or exploration</li> <li>Need complex Python logic or external API calls</li> </ul>"},{"location":"reference/playbook-types/#react-playbooks","title":"ReAct Playbooks","text":"<p>Best for: Research, problem-solving, dynamic planning, adaptive behavior</p> <p>ReAct (Reasoning and Acting) playbooks let the LLM reason about the task and decide what actions to take. They excel when the exact steps cannot be predetermined.</p>"},{"location":"reference/playbook-types/#structure_1","title":"Structure","text":"ReAct playbook structure<pre><code>## PlaybookName($param)\nexecution_mode: react\nDetailed description of the task, goals, constraints, and expected output.\n\nUse XML tags like &lt;planning_rules&gt;, &lt;style_guide&gt;, and &lt;output_format&gt;\nto structure your prompt.\n\n### Triggers\n- When user needs research assistance\n</code></pre> <p>Key difference: No <code>### Steps</code> section. The framework provides a default think-plan-act loop. <code>execution_mode: react</code> is optional - any playbook without steps and without <code>execution_mode: raw</code> will be treated as a ReAct playbook.</p> <p> All playbooks are available as tools to be called from ReAct playbooks.</p>"},{"location":"reference/playbook-types/#default-execution-flow","title":"Default Execution Flow","text":"<p>When a playbook has no explicit steps, Playbooks automatically applies a ReAct execution loop:</p> Default ReAct execution flow<pre><code>1. Think deeply about the task to understand requirements\n2. Write down exit conditions for task completion\n3. While exit conditions are not met:\n   - Analyze current state and progress\n   - Decide what action to take next\n   - Execute the action (tool call, user interaction, computation)\n   - Evaluate results against exit conditions\n4. Return final results\n</code></pre>"},{"location":"reference/playbook-types/#example_1","title":"Example","text":"ReAct playbook example<pre><code>## ResearchCompetitor($company_name)\nConduct comprehensive competitive analysis of the specified company.\n\nResearch the company's products, market position, pricing strategy, and\nrecent developments. Provide a balanced, data-driven analysis.\n\n&lt;planning_rules&gt;\n- Start by identifying the company's primary products and services\n- Search for recent news and financial reports (last 6 months)\n- Analyze customer reviews and sentiment\n- Compare with top 3 competitors in the same space\n- Verify information across multiple reputable sources\n&lt;/planning_rules&gt;\n\n&lt;style_guide&gt;\n- Maintain objective, analytical tone\n- Support claims with specific evidence and sources\n- Present both strengths and weaknesses\n- Use clear headings and bullet points for organization\n&lt;/style_guide&gt;\n\n&lt;output_format&gt;\n    # Competitive Analysis: [Company Name]\n\n    ## Overview\n    [Company description and market position]\n\n    ## Product Portfolio\n    [Key products and services]\n\n    ## Market Position\n    [Market share, competitive advantages, challenges]\n\n    ## Recent Developments\n    [News, product launches, strategic changes]\n\n    ## SWOT Analysis\n    [Strengths, Weaknesses, Opportunities, Threats]\n\n    ## Conclusion\n    [Key insights and recommendations]\n&lt;/output_format&gt;\n\n### Triggers\n- When user requests competitive analysis\n</code></pre>"},{"location":"reference/playbook-types/#when-to-use_1","title":"When to Use","text":"<p>\u2705 Use ReAct Playbooks when:</p> <ul> <li>Task requires research or information gathering</li> <li>Steps cannot be determined in advance</li> <li>Need flexible, adaptive behavior</li> <li>Problem-solving requires iteration and refinement</li> </ul> <p>\u274c Avoid when:</p> <ul> <li>Need guaranteed execution order</li> <li>Process has strict compliance requirements</li> <li>Want explicit visibility into every step</li> </ul>"},{"location":"reference/playbook-types/#raw-prompt-playbooks","title":"Raw Prompt Playbooks","text":"<p>Best for: Single-shot tasks, full prompt control, simple transformations</p> <p>Raw prompt playbooks send your prompt directly to the LLM without any framework enrichment. Use when you need complete control over the exact text sent to the model.</p>"},{"location":"reference/playbook-types/#structure_2","title":"Structure","text":"Raw prompt playbook structure<pre><code>## PlaybookName\nexecution_mode: raw\n\nYour exact prompt text goes here. This will be sent to the LLM verbatim.\n\nYou can use {$variables} and {PlaybookCalls()} for dynamic content.\n</code></pre> <p>Key difference: Add <code>execution_mode: raw</code> metadata at the start of the description.</p>"},{"location":"reference/playbook-types/#key-features_1","title":"Key Features","text":"<p>Direct Prompt Control</p> <ul> <li>Exactly what you write is what the LLM sees</li> <li>No automatic context, no conversation history</li> <li>No execution loop - single LLM call</li> </ul> <p>Description Placeholders</p> <ul> <li>Use <code>{$variable}</code> to inject state variables</li> <li>Use <code>{PlaybookCall()}</code> to inject playbook results</li> <li>Placeholders resolved before sending to LLM</li> </ul> <p>No Framework Overhead - Minimal token usage - Fastest execution - Complete prompt transparency</p>"},{"location":"reference/playbook-types/#example_2","title":"Example","text":"Raw prompt playbook example<pre><code>## CategorizeTicket\nexecution_mode: raw\n\nHere is a customer support ticket message:\n\n{$ticket_message}\n\nCategorize this ticket into one of the following categories:\n- Technical Support\n- Billing\n- Account Management\n- General Inquiry\n\nRespond with ONLY the category name, nothing else.\n\nCategory:\n</code></pre>"},{"location":"reference/playbook-types/#when-to-use_2","title":"When to Use","text":"<p>\u2705 Use Raw Prompt Playbooks when:</p> <ul> <li>Need exact control over prompt text</li> <li>Single-shot task (classification, extraction, formatting)</li> <li>Want minimal token overhead</li> <li>Testing or debugging specific prompts</li> </ul> <p>\u274c Avoid when:</p> <ul> <li>Need multi-turn interaction</li> <li>Require tool usage or loops</li> <li>Want automatic context management</li> <li>Need observability into execution</li> </ul>"},{"location":"reference/playbook-types/#important-limitations","title":"Important Limitations","text":"<p>\u26a0\ufe0f Raw playbooks:</p> <ul> <li>Make a single LLM call (no loops)</li> <li>Cannot call other playbooks during execution</li> <li>Do not receive automatic execution context</li> <li>Lose framework safety checks</li> </ul> <p>For most use cases, prefer Markdown or ReAct playbooks for better observability and control.</p>"},{"location":"reference/playbook-types/#python-playbooks","title":"Python Playbooks","text":"<p>Best for: Complex calculations, data processing, external API integrations, business logic</p>"},{"location":"reference/playbook-types/#structure_3","title":"Structure","text":"Python playbook structure<pre><code># Agent Name\n\n```python\nfrom typing import Dict, List\n\n@playbook\nasync def PlaybookName(param1: str, param2: int) -&gt; float:\n    \"\"\"\n    Playbook description goes in the docstring.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n    \"\"\"\n    # Your Python code here\n    result = perform_calculation(param1, param2)\n\n    # Can call other playbooks\n    other_result = await OtherPlaybook(result)\n\n    return final_result\n```\n</code></pre>"},{"location":"reference/playbook-types/#key-features_2","title":"Key Features","text":"<p>Full Python Power</p> <ul> <li>Standard Python syntax and semantics</li> <li>Access to any Python library</li> <li>Complex calculations and data transformations</li> <li>External API calls and integrations</li> </ul> <p>Decorator Options</p> <ul> <li><code>@playbook</code> - Basic playbook</li> <li><code>@playbook(triggers=[...])</code> - Add trigger conditions</li> <li><code>@playbook(public=True)</code> - Make available to other agents</li> <li><code>@playbook(metadata={...})</code> - Add custom metadata</li> </ul> <p>Calling Other Playbooks</p> <ul> <li>Use <code>await</code> to call markdown or Python playbooks</li> <li>Execute on the same call stack</li> <li>Mix Python and natural language seamlessly</li> </ul>"},{"location":"reference/playbook-types/#example_3","title":"Example","text":"Python playbook example<pre><code># Shipping Calculator Agent\n\n```python\nfrom typing import Dict\n\n@playbook\nasync def CalculateShipping(\n    weight_kg: float,\n    destination: str,\n    is_expedited: bool = False\n) -&gt; Dict[str, float]:\n    \"\"\"\n    Calculate shipping costs based on weight, destination, and speed.\n\n    Args:\n        weight_kg: Package weight in kilograms\n        destination: Destination country code (e.g., \"US\", \"UK\")\n        is_expedited: Whether to use expedited shipping\n\n    Returns:\n        Dictionary with cost breakdown\n    \"\"\"\n    # Base rates by destination\n    base_rates = {\n        \"US\": 5.99,\n        \"UK\": 12.99,\n        \"EU\": 14.99,\n        \"ASIA\": 19.99\n    }\n\n    base_cost = base_rates.get(destination, 24.99)\n    weight_cost = weight_kg * 2.50\n    expedited_cost = 15.00 if is_expedited else 0.00\n\n    total = base_cost + weight_cost + expedited_cost\n\n    return {\n        \"base\": base_cost,\n        \"weight\": weight_cost,\n        \"expedited\": expedited_cost,\n        \"total\": total,\n        \"currency\": \"USD\"\n    }\n\n@playbook\nasync def ProcessShipment(order_id: str) -&gt; str:\n    \"\"\"Process shipment for an order.\"\"\"\n    # Call another playbook to get order details\n    order = await GetOrderDetails(order_id)\n\n    # Calculate shipping using Python playbook\n    cost = await CalculateShipping(\n        order[\"weight\"],\n        order[\"destination\"],\n        order[\"is_express\"]\n    )\n\n    # Update database\n    update_shipping_cost(order_id, cost[\"total\"])\n\n    return f\"Shipping cost calculated: ${cost['total']:.2f}\"\n```\n</code></pre>"},{"location":"reference/playbook-types/#decorator-parameters","title":"Decorator Parameters","text":"<p>Reserved Parameters:</p> <ul> <li><code>triggers</code> - List of trigger conditions (strings)</li> </ul> <p>Standard Metadata:</p> <ul> <li><code>public</code> - Boolean, make callable by other agents</li> <li><code>export</code> - Boolean, allow implementation export</li> <li><code>remote</code> - Dict with <code>type</code>, <code>url</code>, <code>transport</code> for remote services</li> </ul> <p>Custom Metadata: All other keyword arguments become metadata attached to the playbook.</p>"},{"location":"reference/playbook-types/#when-to-use_3","title":"When to Use","text":"<p>\u2705 Use Python Playbooks when:</p> <ul> <li>Need complex calculations or data processing</li> <li>Integrating with external APIs or databases</li> <li>Implementing business logic that's difficult in natural language</li> <li>Need type safety and code reuse</li> </ul> <p>\u274c Avoid when:</p> <ul> <li>Natural language description would be clearer</li> <li>Task is primarily about conversation or reasoning</li> <li>Don't need programmatic control</li> </ul>"},{"location":"reference/playbook-types/#alternative-mcp-tools","title":"Alternative: MCP Tools","text":"<p>For simple Python tools that don't need triggers or the ability to call markdown playbooks, consider using an MCP Agent instead.</p>"},{"location":"reference/playbook-types/#external-playbooks","title":"External Playbooks","text":"<p>Best for: Consuming tools from MCP servers</p> <p>When you use an MCP server backed agent, all tools exposed by the MCP server are automatically available as external playbooks.</p> <p>Roadmap:</p> <ul> <li>APIs: Using API specifications such as OpenAPI or Swagger, load available API endpoints as external playbooks.</li> <li>From external agents: Methods exposed by other agents via protocols such as the A2A protocol will be available as external playbooks.</li> </ul>"},{"location":"reference/playbook-types/#how-to-use","title":"How to Use","text":"<p>Define an MCP agent:</p> MCP agent example<pre><code># Github agent\nagent_type: remote\nremote:\n  type: mcp\n  url: \"https://github.com/mcp\"\n  transport: \"http\"\n</code></pre> <p>Then call its public tools/playbooks like any other playbook:</p> <pre><code>## MyWorkflow\n\n### Steps\n- $repo_handle = GithubAgent.GetRepository($repository_name)\n- Get last 10 $commits\n- Show user the list of $commits\n</code></pre> <p> <code>Get last 10 $commits</code> is a natural language instruction and would be equivalent to something like <code>GithubAgent.GetCommits($repo_handle, limit=10)</code>, assuming appropriate tool description is available from the MCP server.</p>"},{"location":"reference/playbook-types/#key-features_3","title":"Key Features","text":"<p>Seamless Integration</p> <ul> <li>Call remote services like local playbooks</li> <li>Framework handles authentication and transport transparently</li> <li>Automatic error handling and retries</li> </ul>"},{"location":"reference/playbook-types/#when-to-use_4","title":"When to Use","text":"<p>\u2705 Use External Playbooks when:</p> <ul> <li>Integrating with existing MCP servers</li> <li>(roadmap) Calling specialized external services</li> <li>(roadmap) Connecting to other AI agent frameworks</li> </ul>"},{"location":"reference/playbook-types/#choosing-the-right-type","title":"Choosing the Right Type","text":"Type Executed on Best For Key Advantage Limitation Observability Markdown LLM Structured workflows Explicit control flow Steps must be predetermined Yes ReAct LLM Research, problem-solving Adaptive behavior Less predictable execution Yes Raw Prompt LLM Single-shot tasks Full prompt control No loops or context Limited Python CPU Complex logic, APIs Full programming power More code to maintain Yes External Remote Remote services Leverage existing tools No callback capability Limited"},{"location":"reference/playbook-types/#decision-guide","title":"Decision Guide","text":"<p>Start with Markdown if:</p> <ul> <li>You know the steps in advance</li> <li>Process is repeatable and structured</li> </ul> <p>Use ReAct if:</p> <ul> <li>Steps depend on intermediate results</li> <li>Task requires research or exploration</li> </ul> <p>Choose Python if:</p> <ul> <li>Natural language can't express the logic</li> <li>Need external integrations or complex calculations</li> </ul> <p>Use Raw Prompt if:</p> <ul> <li>Simple transformation or classification</li> <li>Want minimal overhead and exact prompt control</li> </ul> <p>Use External if:</p> <ul> <li>Functionality already exists in an MCP server</li> <li>Integrating with external systems</li> </ul>"},{"location":"reference/playbook-types/#mixing-playbook-types","title":"Mixing Playbook Types","text":"<p>One of Playbooks' most powerful features is seamless composition. You can freely mix types within a single agent:</p> Mixing playbook types example<pre><code># Customer Service Agent\n\n## HandleInquiry\n### Steps\n- Find inquiry type for user message # Raw prompt playbook\n- If inquiry type is \"technical\"\n  - Research the technical issue  # ReAct playbook\n  - Format the research output # Python playbook\n  - Tell user the formatted response\n\n## ClassifyInquiry($message)\nexecution_mode: raw\nClassify this inquiry: {$message}\nCategories: technical, billing, general\nCategory:\n\n## ResearchTechnicalIssue($issue)\nResearch the technical issue and provide a detailed solution.\n&lt;planning_rules&gt;\n- Search knowledge base first\n- If not found, search web\n- Verify solution applies to user's situation\n&lt;/planning_rules&gt;\n\n```python\n@playbook\nasync def FormatResponse(answer: str) -&gt; str:\n    \"\"\"Format the answer with proper styling and links.\"\"\"\n    # Add styling, links, formatting\n    return formatted_html\n```\n</code></pre>"},{"location":"reference/playbooks-ai/","title":"Playbooks AI","text":"<p>Playbooks AI is a comprehensive technology stack designed specifically for building AI agents and LLM-powered automation. It includes a new programming language (.pb files), a compiler that compiles the language to Playbooks Assembly Language (.pbasm files), a runtime that executes the Playbooks Assembly Language programs, and a protocol for multi-agent communication and capability-sharing.</p>"},{"location":"reference/playbooks-ai/#playbooks-ai-technology-stack","title":"Playbooks AI Technology Stack","text":"<ul> <li>Playbooks Language (.pb)</li> <li>Playbooks Compiler: Compiles Playbooks Language to Playbooks Assembly Language</li> <li>Playbooks Assembly Language (.pbasm): Open standard for Common Language Specification (CLS) for LLM-executed programs</li> <li>Playbooks Runtime: Common Language Runtime (CLR) for Playbooks Assembly Language programs</li> <li>Playbooks SDK: playbooks Python module, CLI, web server and playground</li> <li>Playbooks Protocol: Multi-agent communication and capability-sharing standard</li> <li>PlaybooksLM: Enterprise-grade model for running Playbooks programs at scale, with full control over data privacy and security</li> </ul>"},{"location":"reference/playbooks-assembly-language/","title":"Playbooks Assembly Language (PBAsm)","text":"<p>The Playbooks Assembly Language (PBAsm) is a low-level, structured representation of Playbooks programs designed specifically for execution by Large Language Models (LLMs). Just as traditional assembly languages use instruction sets optimized for CPU architectures, PBAsm uses an instruction set optimized for the unique capabilities and characteristics of LLMs as execution engines.</p>"},{"location":"reference/playbooks-assembly-language/#the-llm-as-cpu-architecture","title":"The LLM as CPU Architecture","text":""},{"location":"reference/playbooks-assembly-language/#traditional-cpu-vs-llm-execution-engine","title":"Traditional CPU vs LLM Execution Engine","text":"CPU Executing Assembly/Binary code LLM Executing PBAsm code Instruction Format Binary opcodes (e.g., <code>0x89 0xE5</code> for MOV EBP, ESP) Semantic instructions (e.g., <code>01:EXE Var[$name:str, \"Alice\"]</code>) Basic Instructions MOV, ADD, JMP, CALL, RET, CMP EXE, TNK, QUE, CND, CHK, YLD, JMP, RET Memory Model Direct memory addresses, registers (EAX, EBX, ESP) Short term memory with variables (<code>$name:str</code>, <code>$count:int</code>), Long term memory system Variable Assignment <code>MOV [0x1000], 42</code> (write to memory address) <code>Var[$count:int, 42]</code> (semantic variable binding) Function Calls <code>PUSH params; CALL 0x4000; POP result</code> <code>$result = FunctionName(param=$value); YLD call</code> Control Flow <code>CMP EAX, 0; JE label</code> (compare and jump) <code>02:CND If $name is provided</code> (semantic condition) Loops <code>loop_start: DEC ECX; JNZ loop_start</code> <code>03:CND While $i &lt; 10</code> with nested steps Stack Operations <code>PUSH EAX; POP EBX</code> (explicit stack manipulation) Implicit call stack managed by runtime Return Values Store in EAX register by convention <code>04:RET $result</code> (explicit return statement) Interrupts INT 0x80 (system call), hardware IRQ <code>Trigger[\"PlaybookName:01:EVT\"]</code> (semantic events) Yielding Control Context switch via OS scheduler <code>YLD user/call/exit</code> (explicit yield reasons) Line Addressing Absolute/relative addresses (0x4000, +10) Hierarchical numbering (01, 01.01, 01.01.01) Conditional Execution Flag-based (ZF, CF, OF) after CMP Natural language conditions evaluated by LLM Data Types Primitive (byte, word, dword, float) Semantic types (str, int, float, bool, list, dict, artifact, memory) Error Handling Segfault, divide by zero, invalid opcode Graceful degradation, runtime validation of outputs Debugging GDB breakpoints, register inspection VSCode debugger - step debugging, variable inspection Side Effects Direct I/O port access, memory writes Queued operations via QUE, verified by runtime Compilation Source \u2192 AST \u2192 Machine code Playbooks \u2192 PBAsm \u2192 Runtime Context \u2192 LLM tokens Parallelism Out-of-order execution, SIMD Queued operations can batch (multiple QUE before YLD) State Persistence CPU registers reset on context switch Variables persist across YLD operations Program Counter EIP/RIP register points to next instruction Runtime tracks current playbook line number (e.g. OrderStatus:01.03) Subroutines CALL pushes return address, RET pops Playbook calls with QUE, across agents Execution Context CPU state (registers, flags, stack) Conversation history, variable state, queued ops"},{"location":"reference/playbooks-assembly-language/#the-pbasm-instruction-set","title":"The PBAsm Instruction Set","text":"<p>PBAsm's instruction set is specifically designed for these LLM characteristics:</p>"},{"location":"reference/playbooks-assembly-language/#core-instructions","title":"Core Instructions","text":"Instruction Purpose LLM Operation Runtime Verification EXE Execute imperative action/assignment Process semantic instruction, update state Parse variable assignments, validate state changes TNK Think deeply step by step Engage reasoning capabilities before proceeding Verify structured thinking output QUE Queue playbook/function call Prepare asynchronous operation Parse function calls with parameters CND Conditional/loop construct Evaluate semantic conditions and control flow Track conditional logic and execution paths CHK Apply contextual note/rule Incorporate business rules into context Verify rule application RET Return from playbook Complete function execution with optional value Parse return values JMP Jump to specific line Transfer execution control Validate line number targets YLD Yield control to runtime Pause execution, transfer control Parse yield targets (user/call/return/exit)"},{"location":"reference/playbooks-assembly-language/#yield-reasons","title":"Yield Reasons","text":"<p>The YLD instruction includes specific reasons that define why the LLM is yielding control:</p> <ul> <li><code>YLD call</code> - Execute queued function calls (including Say() calls)</li> <li><code>YLD user</code> - Wait for user input (only after asking for input)</li> <li><code>YLD agent</code> - Wait for input from another agent</li> <li><code>YLD meeting</code> - Wait for input from a meeting you are participating in</li> <li><code>YLD exit</code> - Terminate the program</li> </ul>"},{"location":"reference/playbooks-assembly-language/#structured-output-protocol","title":"Structured Output Protocol","text":"<p>Unlike traditional assembly that modifies CPU registers, PBAsm instructions produce structured outputs that the runtime can parse and verify:</p>"},{"location":"reference/playbooks-assembly-language/#variable-operations","title":"Variable Operations","text":"<p><pre><code>Var[$name, &lt;value&gt;]\n</code></pre> Similar to how assembly instructions modify CPU registers, but operates on named variables with semantic meaning. Variables must include type annotations: <code>$varname:type</code> where type is one of: <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>list</code>, <code>dict</code>, <code>artifact</code>.</p>"},{"location":"reference/playbooks-assembly-language/#function-calls","title":"Function Calls","text":"<pre><code>$result = PlaybookName(param1, param2=$value2) \u2190 Standard Python syntax\n$result = Call PlaybookName with param1, param2=$value2 \u2190 Natural language syntax\nGet $result from PlaybookName \u2190 Implicit argument passing\n$result = PlaybookName(task user specified, details=details of the task) \u2190 Natural language arguments\n</code></pre>"},{"location":"reference/playbooks-assembly-language/#trigger-events-llm-interrupts","title":"Trigger Events (LLM Interrupts)","text":"<p><pre><code>### Triggers\n- T1:BGN When program starts\n</code></pre> PBAsm's interrupt system - the LLM can signal semantic events that interrupt normal execution flow and trigger other playbooks to execute, similar to how hardware/software interrupts work in traditional CPUs.</p>"},{"location":"reference/playbooks-assembly-language/#compilation-from-playbooks-language","title":"Compilation from Playbooks Language","text":""},{"location":"reference/playbooks-assembly-language/#source-format-playbooks-language","title":"Source Format (Playbooks Language)","text":"<pre><code>## GreetUser\nThis playbook greets the user and asks for their name.\n\n### Triggers\n- At the beginning\n\n### Steps\n- Greet the user and ask for their name\n- If name is provided\n  - Thank the user by name\n- Otherwise\n  - Ask for their name again\n</code></pre>"},{"location":"reference/playbooks-assembly-language/#compiled-format-pbasm","title":"Compiled Format (PBAsm)","text":"<pre><code>## GreetUser() -&gt; None\nThis playbook greets the user and asks for their name.\n### Triggers\n- T1:BGN At the beginning\n### Steps\n- 01:QUE Say(Greet the user and ask for their $name:str); YLD user\n- 02:CND If $name is provided\n  - 02.01:QUE Say(Thank the user by $name); YLD call\n- 03:CND Otherwise\n  - 03.01:QUE Say(Ask for their $name:str again); YLD user\n- 04:RET\n</code></pre>"},{"location":"reference/playbooks-assembly-language/#line-numbering-and-control-flow","title":"Line Numbering and Control Flow","text":"<p>PBAsm uses a hierarchical line numbering system that enables precise control flow:</p> <ul> <li>Top-level steps: <code>01</code>, <code>02</code>, <code>03</code></li> <li>Sub-steps: <code>01.01</code>, <code>01.02</code>, <code>01.03</code></li> <li>Nested sub-steps: <code>01.01.01</code>, <code>01.01.02</code></li> </ul> <p>This enables: - Precise jumping: <code>JMP 01</code> to return to a specific line (used in loops) - Conditional nesting: Clear structure for if/else and loops - Error recovery: Ability to resume at specific execution points</p>"},{"location":"reference/playbooks-assembly-language/#trigger-system-llm-interrupts","title":"Trigger System: LLM Interrupts","text":"<p>PBAsm includes a sophisticated interrupt system that leverages the LLM's ability to recognize semantic patterns. Like traditional CPU interrupts, PBAsm triggers can interrupt normal execution flow when specific conditions are met:</p>"},{"location":"reference/playbooks-assembly-language/#trigger-types","title":"Trigger Types","text":"<ul> <li>BGN (Beginning): Execute when program starts</li> <li>CND (Conditional): Execute when semantic conditions are met</li> <li>EVT (Event): Execute on external events</li> </ul>"},{"location":"reference/playbooks-assembly-language/#trigger-registration-and-handling","title":"Trigger Registration and Handling","text":"<pre><code>### Triggers\n- T1:CND When user provides their email address\n- T2:BGN At the beginning  \n- T3:EVT When payment processed event is received\n- T4:EVT When Accountant agent is ready with the invoice\n</code></pre> <p>The LLM continuously monitors these semantic conditions during execution. When a trigger condition is met, it interrupts the current playbook execution, saves the current state, and invokes the triggered playbook - much like how a CPU handles interrupts.</p>"},{"location":"reference/playbooks-assembly-language/#interrupt-handling-flow","title":"Interrupt Handling Flow","text":"<ol> <li>Normal Execution: LLM processes instructions sequentially</li> <li>Condition Detection: After each step, LLM evaluates trigger conditions  </li> <li>Interrupt Signal: If condition is met, LLM signals <code>Trigger[\"PlaybookName:Line:Code\"]</code></li> <li>State Preservation: Current execution context is maintained</li> <li>Handler Invocation: Triggered playbook begins execution</li> <li>Return/Continue: After handling, execution resumes or transfers control</li> </ol> <p>This interrupt-driven architecture enables reactive, event-driven AI systems that can respond to changing conditions without polling - a fundamental advance in AI agent architecture.</p>"},{"location":"reference/playbooks-assembly-language/#key-patterns-and-best-practices","title":"Key Patterns and Best Practices","text":""},{"location":"reference/playbooks-assembly-language/#function-call-patterns","title":"Function Call Patterns","text":"<p>Simple function call: <pre><code>01:QUE $result:dict = GetWeather(city=$city); YLD call\n</code></pre></p> <p>Nested function calls (decomposed): <pre><code>01:QUE $temp:str = FuncB(x=$x); YLD call\n02:QUE $result:dict = FuncA(param=$temp); YLD call\n</code></pre></p> <p>Cross-agent calls: <pre><code>01:QUE $weather:dict = WeatherAgent.GetCurrentWeather(zip=98053); YLD call\n</code></pre></p> <p>Batch call processing (concurrent execution): <pre><code>01:EXE Initialize empty $results:dict\n02:CND For each $item in $items:list\n  02.01:QUE ProcessItem(item=$item); do not yield\n03:YLD call to execute all queued calls concurrently\n04:EXE Collect results into $results:dict by item id\n</code></pre></p>"},{"location":"reference/playbooks-assembly-language/#user-interaction-patterns","title":"User Interaction Patterns","text":"<p>Single question: <pre><code>01:QUE Say(Ask user for their $name:str); YLD user\n</code></pre></p> <p>Multi-turn conversation: <pre><code>01:QUE Say(Welcome and ask how to help); YLD user\n02:QUE Say(Continue conversation to meet criteria); YLD user; done after criteria met\n</code></pre></p> <p>Enqueue multiple messages: <pre><code>01:QUE Say(Present options); no yield needed\n02:QUE Say(Ask user to select one); YLD user\n</code></pre></p>"},{"location":"reference/playbooks-assembly-language/#metadata-and-public-playbooks","title":"Metadata and Public Playbooks","text":"<p>Agents and playbooks can include metadata in YAML format:</p> <pre><code># AgentName\nmetadata:\n  model: claude-sonnet-4.0\n  author: name@example.com\n---\nAgent description\n\n## PlaybookName\nmetadata:\n  public: true\n---\nPlaybook description\n</code></pre> <p>Public playbooks are exposed for cross-agent communication and included in the generated <code>public.json</code>.</p>"},{"location":"reference/playbooks-assembly-language/#advantages-of-pbasm","title":"Advantages of PBAsm","text":"<ol> <li>Semantic Precision: Natural language instructions with assembly-like precision</li> <li>Interoperability: Multiple authoring tools can target PBAsm</li> <li>Analysis capability: Static analysis tools can examine PBAsm programs</li> <li>Runtime flexibility: Different LLM runtimes can execute the same PBAsm code</li> <li>Debugging support: Clear execution model enables sophisticated debugging tools</li> <li>Concurrent execution: Support for batched operations and asynchronous calls</li> <li>Cross-agent communication: Built-in support for multi-agent systems</li> </ol>"},{"location":"reference/playbooks-assembly-language/#conclusion","title":"Conclusion","text":"<p>PBAsm represents a foundational step toward treating LLMs as first-class computational engines with their own optimized instruction sets, enabling the development of reliable, scalable, and maintainable AI agent systems. By providing a structured intermediate representation between natural language and LLM execution, PBAsm enables sophisticated tooling, analysis, and runtime optimization while maintaining the semantic richness that makes LLM-based computing powerful.</p>"},{"location":"reference/playbooks-language/","title":"Playbooks Language","text":"<p>Playbooks, created by Amol Kelkar in 2024, is a high-level, human-readable programming language for building AI agents and LLM-powered automation. It emphasizes clarity, maintainability, and verifiable execution over low-level orchestration.</p> <p>Here are some key characteristics of the Playbooks Language:</p> <ul> <li>Human-Readable and Structured: Author agent behavior in natural language within a simple markdown structure. Easy to read, review, and collaborate on.</li> <li>Agent-Oriented: Organize behavior as agents and playbooks, encouraging modularity, reuse, and composition.</li> <li>Natural Language + Code: Combine descriptive instructions with Python where needed for precise logic and integrations.</li> <li>Typed State and Safety: Use clearly typed variables and explicit state to improve reliability and reduce ambiguity.</li> <li>Event-Driven by Design: Triggers make programs reactive to user input, conditions, and external events.</li> <li>Multiple Playbook Styles: Support for structured workflows, ReAct reasoning, raw prompts, Python, and external tools.</li> <li>Verifiable and Observable: Compiles to a low-level assembly (PBAsm) for auditing, debugging, and reproducibility.</li> <li> <p>Open and Extensible: Designed to integrate with external services and other agent ecosystems.</p> </li> <li> <p>Playbooks Language compared to traditional programming languages</p> <ul> <li>Emphasizes readable markdown sections over braces, boilerplate, or complex orchestration code.</li> <li>Prioritizes explicit steps and triggers instead of line-by-line imperative syntax.</li> <li>Treats LLMs as CPUs: programs compile to PBAsm for consistent, inspectable execution.</li> <li>Focuses on behavior specification first; Python is used when hard logic is required.</li> </ul> </li> </ul>"},{"location":"reference/triggers/","title":"Triggers","text":"<p>Triggers are a powerful feature in Playbooks AI that enable declarative event-driven programming through natural language conditions. They allow playbooks to be dynamically invoked when specified conditions are met.</p>"},{"location":"reference/triggers/#what-are-triggers","title":"What are Triggers?","text":"<p>Triggers are conditions written in natural language that, when met, cause a playbook to be executed. They enable reactive and event-driven behavior in your AI agents.</p>"},{"location":"reference/triggers/#types-of-triggers","title":"Types of Triggers","text":"<p>Triggers can be classified into three types:</p> <ul> <li>Temporal triggers (\"when program starts\")</li> <li>State-based triggers (\"when $x becomes more than 15\")</li> <li>Execution flow hooks (\"after calling LoadAccount\")</li> <li>User interaction triggers (\"when user provides a PIN\")</li> <li>Sentiment based triggers (\"if the user is extremely frustrated\")</li> <li>User requested triggers (\"when user wants to connect with human agent\")</li> <li>External event triggers (\"when a new email is received\")</li> <li>Communication based triggers (\"when another agent asks you about tax rates\")</li> </ul>"},{"location":"reference/triggers/#how-to-add-triggers","title":"How to Add Triggers","text":"<p>Triggers are added to the <code>### Triggers</code> section of a playbook.</p> <pre><code>### Triggers\n- At the beginning\n</code></pre> <p>Triggers can also be added to Python playbooks.</p> <pre><code>```python\n@playbook(triggers=[\"At the beginning\"])\nasync def MyPlaybook():\n    pass\n```\n</code></pre>"},{"location":"tutorials/","title":"Tutorial: Building an Order Status Assistant","text":"<p>Goal: Learn Playbooks by building a customer support AI assistant that checks order status. You'll start with \"hello world\" and progressively add user input, validation, Python playbooks, and more.</p> <p>What you'll learn:</p> <ul> <li>Writing your first agent and playbook</li> <li>Collecting and validating user input</li> <li>Using triggers for automatic validation</li> <li>Mixing Python and Markdown playbooks</li> <li>Injecting dynamic context with description placeholders</li> </ul> <p>Prerequisites (see Getting Started):</p> <ul> <li>Installed Playbooks</li> <li>Successfully ran a program using <code>playbooks run &lt;program&gt;.pb</code></li> </ul> <p> Code: All examples available here</p> <p> New to Playbooks? This tutorial teaches by example. For comprehensive reference, see the Programming Guide.</p>"},{"location":"tutorials/#1-hello-world","title":"1) Hello, world!","text":""},{"location":"tutorials/#0101-lets-begin","title":"01.01 Let's begin","text":"<p>examples/tutorials/01.01/order_assistant.pb</p> order_assistant.pb<pre><code># Order Support Agent\nYou are an agent that greets users and helps with order questions.\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Greet the user and explain what you can help with\n- End program\n</code></pre> <p>Note:</p> <ul> <li>Line 1: <code># Order Support Agent</code> creates an agent. </li> <li>Line 3: <code>## Main</code> defines a playbook, which is triggered automatically at the beginning (line 6) of the program execution. </li> <li>Line 7: <code>### Steps</code> lists the steps to be executed.</li> </ul> Output <pre><code>&gt; playbooks run examples/tutorials/01.01/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/01.01/order_assistant.pb']\n  Compiling agent: Order Support Agent\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you with any questions or issues related to your orders. Whether you need to check order status, make changes, handle returns, or resolve any order-related concerns, I'm ready to assist you. How can I help you today?\n</code></pre> <p> Playbooks framework caches LLM responses by default. So, if you run the program again, compilation will be skipped and you will see the same output. The cache can be disabled using a <code>playbooks.toml</code> configuration file.</p> <p> Notice that in the output, the agent listed capabilities that we haven't provided playbooks for.</p> <p>Let's improve this by asking the agent to only list capabilties corresponding to the playbooks that we have provided.</p>"},{"location":"tutorials/#0102-prompt-tuning","title":"01.02 Prompt Tuning","text":"<p>examples/tutorials/01.02/order_assistant.pb order_assistant.pb<pre><code># Order Support Agent\nYou are an agent that greets users and helps with order questions. Note that your capabilities are limited to the playbooks defined below.\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Greet the user and explain what you can help with\n- End program\n</code></pre></p> <p>Changes:</p> <ul> <li>Line 2: We added extra instructions to the agent.</li> </ul> Output <pre><code>&gt; playbooks run examples/tutorials/01.02/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/01.02/order_assistant.pb']\n  Compiling agent: Order Support Agent\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you with any questions about your orders. However, I should let you know that my capabilities are currently limited to greeting you and providing this basic information. How can I assist you today?\n</code></pre> <p>Much better!</p>"},{"location":"tutorials/#2-ask-for-user-input","title":"2) Ask for user input","text":"<p>Let's ask the user for their order id.</p>"},{"location":"tutorials/#0201-user-input","title":"02.01 User input","text":"<p>examples/tutorials/02.01/order_assistant.pb</p> order_assistant.pb<pre><code># Order Support Agent\nYou are an agent that greets users and helps with order questions. Note that your capabilities are limited to the playbooks defined below.\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Greet the user and explain what you can help with\n- Ask user for their order id\n- Thank the user for providing the order id\n- End program\n</code></pre> <p>Changes:</p> <ul> <li>Line 9: Here we ask the user for their order id.</li> <li>Line 10: New step to thank the user for providing the order id.</li> </ul> Output <pre><code>&gt; playbooks run examples/tutorials/02.01/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/02.01/order_assistant.pb']\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you with any questions about your orders. I can assist you with order status, tracking information, and other order-related inquiries.\n\nOrderSupportAgent: To get started, could you please provide me with your order ID?\n\nUser: 47463874\n\nOrderSupportAgent: Thank you for providing your order ID: 47463874. I have recorded this information.\n</code></pre>"},{"location":"tutorials/#0202-conversational-input","title":"02.02 Conversational Input","text":"<p>We want the agent to wait on line 9 until the user provides their order id. Let's add that instruction.</p> <p>examples/tutorials/02.02/order_assistant.pb</p> order_assistant.pb<pre><code># Order Support Agent\nYou are an agent that greets users and helps with order questions. Note that your capabilities are limited to the playbooks defined below.\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Greet the user and explain what you can help with\n- Ask user for their order id; engage in a conversation as needed\n- Thank the user for providing the order id\n- End program\n</code></pre> <p>Changes:</p> <ul> <li>Line 9: Here we add a new step to engage in a conversation as needed.</li> </ul> Output <pre><code>&gt; playbooks run examples/tutorials/02.02/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/02.02/order_assistant.pb']\n  Compiling agent: Order Support Agent\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you with any questions about your orders. I can assist you with order status, tracking information, and other order-related inquiries.\n\nOrderSupportAgent: To get started, could you please provide me with your order ID? This will help me look up your specific order details.\n\nUser: how are you\n\nOrderSupportAgent: I'm doing well, thank you for asking! I'm here and ready to help you with your order. Could you please share your order ID so I can assist you with your order-related questions?\n\nUser: hold on.. let me look that up\n\nOrderSupportAgent: No problem at all! Take your time finding your order ID. I'll wait here for you.\n\nUser: found it 44344456\n\nOrderSupportAgent: Perfect! Thank you for providing your order ID: 44344456. I have that recorded now.\n</code></pre> <p>Notice that now the agent engaged in a conversation with the user while waiting for the order id.</p>"},{"location":"tutorials/#0203-agent-behavior","title":"02.03 Agent Behavior","text":"<p>This behavior trait can be added to the agent's instructions so it applies to any time the agent asks the user for some information.</p> <p>examples/tutorials/02.03/order_assistant.pb</p> order_assistant.pb<pre><code># Order Support Agent\nYou are an agent that greets users and helps with order questions. Note that your capabilities are limited to the playbooks defined below.\nWhenever you are asking for some information from the user, you engage the user in a conversation if needed without being pushy and you will wait for appropriate place in conversation to remind the user.\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Greet the user and explain what you can help with\n- Ask user for their order id\n- Thank the user for providing the order id\n- End program\n</code></pre> <p>Changes:</p> <ul> <li>Line 3: We added instructions for the agent</li> </ul> Output <pre><code>&gt; playbooks run examples/tutorials/02.03/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/02.03/order_assistant.pb']\n  Compiling agent: Order Support Agent\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you with any questions about your orders. I can assist you with tracking, status updates, and general order inquiries.\n\nOrderSupportAgent: To get started, could you please provide your order ID? This will help me look up your specific order details.\n\nUser: how are you\n\nOrderSupportAgent: I'm doing well, thank you for asking! I'm here and ready to help you with your order questions. To assist you best, I'll still need your order ID. Could you please share that with me?\n\nUser: nice weather here today.. how is it where you are\n\nOrderSupportAgent: That sounds lovely! As an AI assistant, I don't experience weather, but I'm glad you're having a nice day. I'd love to help you with your order - could you please share your order ID so I can assist you with any questions or concerns you might have?\n\nUser: sure, i'll look that up\n\nOrderSupportAgent: Perfect! Take your time finding your order ID. I'll be right here waiting to help you once you have it.\n\nUser: kk it's 88788790\n\nOrderSupportAgent: Thank you for providing your order ID 88788790! I have that recorded now.\n</code></pre>"},{"location":"tutorials/#3-validating-the-input","title":"3) Validating the input","text":"<p>Let's add a new playbook to validate the order id.</p>"},{"location":"tutorials/#0301-validation-playbook","title":"03.01 Validation Playbook","text":"<p>examples/tutorials/03.01/order_assistant.pb</p> order_assistant.pb<pre><code># Order Support Agent\nYou are an agent that greets users and helps with order questions. Note that your capabilities are limited to the playbooks defined below.\nWhenever you are asking for some information from the user, you engage the user in a conversation if needed without being pushy and you will wait for appropriate place in conversation to remind the user.\n\n## Main\n### Triggers\n- At the beginning\n### Steps\n- Greet the user and explain what you can help with\n- Ask user for their order id\n- Validate the order id and keep asking until user provides a valid id\n- Thank the user for providing the order id\n- End program\n\n## Validate order id\n### Steps\n- If order id is made up of 8 numbers\n  - Return valid\n- otherwise\n  - Return invalid\n</code></pre> <p>Changes:</p> <ul> <li>Line 15: We added a new playbook to validate the order id.</li> <li>Line 11: After user provides the order id, now we call the <code>Validate order id</code> playbook to validate it, and engage with the user until they provide a valid id.</li> </ul> Output <pre><code>&gt; playbooks run examples/tutorials/03.01/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/03.01/order_assistant.pb']\n  Compiling agent: Order Support Agent\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you with questions about your orders. I can assist you by looking up order information once you provide me with your order ID. How can I help you today?\n\nOrderSupportAgent: To get started, could you please share your order ID with me? Take your time - I'll wait for you to provide it or let me know if you'd prefer not to continue.\n\nUser: 8843\n\nOrderSupportAgent: I see that order ID '8843' isn't quite right - it looks like it needs to be 8 digits long. Could you please double-check your order ID and share the complete number with me?\n\nUser: 8843A098\n\nOrderSupportAgent: I see that order ID '8843A098' contains letters, but order IDs should be exactly 8 digits only. Could you please check your order confirmation and share the correct 8-digit order ID?\n\nUser: 98745968\n\nOrderSupportAgent: Perfect! Thank you for providing your order ID 98745968. I now have all the information I need to help you with your order.\n</code></pre> <p>A note to my fellow Software Engineers:</p> <p>I know, <code>Return valid</code> looks weird. What is getting returned here exactly? Is it a string or a boolean? We aren't capturing the return value in the call on line 11 either. The call <code>Validate the order id</code> also doesn't match the playbook name <code>Validate order id</code> exactly. It all seems too fuzzy and a bit magical. I realize that it makes you uncomfortable.</p> <p>You can make the code explicit. Declare the playbook like <code>## ValidateOrderId($order_id) -&gt; bool</code>, use <code>return true</code> and <code>return false</code>. Change the call to <code>$valid = ValidateOrderId($order_id)</code>, and so on. Have it your way! This is also valid Playbooks code, but mostly unnecessary because of the compiler (see below). On the other hand, you could -</p> <p>Embrace the magic! LLMs are highly capable semantic execution machines. By themselves, they are not reliable, so your hesitation is justifiable. But this is where the advanced engineering behind Playbooks comes in. The way Playbooks compiler and runtime are designed, you can expect reliable execution of semantic instructions. Of course, as with any AI software, thourough evaluation is still necessary.</p> <p>The Playbooks compiler compiles <code>.pb</code> program to Playbooks Assembly Language (<code>.pbasm</code>), which converts some of the semantic instructions into explicit instructions, adds explicit type annotations, and so on. See the compiler generated PBAsm code below (actual file) -</p> Compiled .pbasm Order_Support_Agent_6a901f96b774fe82.pbasm<pre><code># OrderSupportAgent\nYou are an agent that greets users and helps with order questions. Note that your capabilities are limited to the playbooks defined below.\nWhenever you are asking for some information from the user, you engage the user in a conversation if needed without being pushy and you will wait for appropriate place in conversation to remind the user.\n\n## Main() -&gt; None\nMain interaction flow for order support assistance\n\n### Triggers\n- T1:BGN At the beginning\n\n### Steps\n- 01:QUE Say(user, Greet the user and explain what you can help with)\n- 02:QUE Say(user, Ask user for their $order_id:str); YLD for user; done when user provides an order id or gives up\n- 03:QUE $validation_result:str = ValidateOrderId(order_id=$order_id)\n- 04:YLD for call\n- 05:CND While $validation_result is invalid\n  - 05.01:QUE Say(user, Ask user for a valid order id); YLD for user; done when user provides an order id or gives up\n  - 05.02:QUE $validation_result:str = ValidateOrderId(order_id=$order_id)\n  - 05.03:YLD for call\n  - 05.04:JMP 05\n- 06:QUE Say(user, Thank the user for providing the order id)\n- 07:YLD for exit\n\n## ValidateOrderId($order_id:str) -&gt; str\nValidates if the provided order ID meets the required format\n\n### Steps\n- 01:CND If order id is made up of 8 numbers\n  - 01.01:RET valid\n- 02:RET invalid\n</code></pre>  This looks a lot more like actual code, doesn't it? This is Assembly Language for the LLM, with opcodes like `QUE` for function calls, `CND` for conditional logic, and so on.   <p> The goal is to make the agent's behavior specification as readable as possible,  as if it is written for a competent employee.</p> <p> Learn more: See Natural Language vs Explicit Syntax in the Programming Guide.</p>"},{"location":"tutorials/#0302-using-triggers","title":"03.02 Using Triggers","text":"<p>Triggers automatically invoke playbooks when conditions are met - like CPU interrupts. Let's add a trigger to the <code>Validate order id</code> playbook to automatically run when the user provides an order id.</p> <p>examples/tutorials/03.02/order_assistant.pb</p> order_assistant.pb<pre><code> - At the beginning\n ### Steps\n - Greet the user and explain what you can help with\n-- Ask user for their order id\n-- Validate the order id and keep asking until user provides a valid id\n+- Ask user for their order id till user provides a valid order id\n - Thank the user for providing the order id\n - End program\n\n ## Validate order id\n+### Trigger\n+- When user provides order id\n ### Steps\n - If order id is made up of 8 numbers\n   - Return valid\n</code></pre> <p>Changes:</p> <ul> <li>We no longer need to explicitly call the <code>Validate order id</code> playbook on line 11.</li> <li>We added a trigger condition to the <code>Validate order id</code> playbook to run automatically when the user provides an order id.</li> </ul> <p> Key Benefit: Main flow stays clean. Validation happens automatically. No explicit validation calls needed.</p> <p> Learn more: See Triggers: Event-Driven Programming for patterns, best practices, and when to use (or avoid) triggers.</p>"},{"location":"tutorials/#4-mixing-python-and-markdown-playbooks","title":"4) Mixing Python and Markdown Playbooks","text":""},{"location":"tutorials/#0401-markdown-python","title":"04.01 Markdown \u2192 Python","text":"<p>Use Python playbooks when you need data access, deterministic logic, or external libraries. Define async functions decorated with <code>@playbook</code> inside python code blocks.</p> <p>examples/tutorials/04.01/order_assistant.pb</p> order_assistant.pb<pre><code> # Order Support Agent\n You are an agent that greets users and helps with order questions. Note that your capabilities are limited to the playbooks defined below.\n Whenever you are asking for some information from the user, you engage the user in a conversation if needed without being pushy and you will wait for appropriate place in conversation to remind the user.\n\n+```python\n+# In real life you'd query your DB or API here.\n+_FAKE_ORDERS = {\n+  \"43345678\": {\"order_id\": \"43345678\", \"status\": \"Shipped\", \"expected_delivery_date\": \"2025-10-02\"},\n+  \"29376452\": {\"order_id\": \"29376452\", \"status\": \"Processing\", \"expected_delivery_date\": \"2025-10-05\"},\n+}\n+\n+@playbook\n+async def GetOrderStatus(order_id: str) -&gt; dict:\n+  \"\"\"\n+  Lookup an order's status by id.\n+  Returns a dict with order_id, status, expected_delivery_date.\n+  \"\"\"\n+\n+  info = _FAKE_ORDERS.get(order_id.upper())\n+  if not info:\n+    # Return user-readable errors when called from markdown\n+    return {\"error\": f\"Order {order_id} was not found.\"}\n+  return info\n+```\n+\n ## Main\n ### Triggers\n - At the beginning\n@@ -9,6 +30,7 @@ Whenever you are asking for some information from the user, you engage the user\n - Greet the user and explain what you can help with\n - Ask user for their order id till user provides a valid order id\n - Thank the user for providing the order id\n+- Get order status and tell user what it is\n - End program\n\n ## Validate order id\n</code></pre> <p>Changes:</p> <ul> <li>Lines 5-25: We added a Python playbook to get the order status.</li> <li>Line 33: We added a step to get the order status and tell the user what it is.</li> </ul> Output (unknown order id) <pre><code>&gt; playbooks run examples/tutorials/04.01/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/04.01/order_assistant.pb']\n  Compiling agent: Order Support Agent\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you with any questions about your orders. I can look up order status and provide information about your purchases. How can I assist you today?\n\nOrderSupportAgent: To get started, could you please provide your order ID? It should be an 8-digit number.\n\nUser: 34564323\n\nOrderSupportAgent: Thank you for providing your order ID 34564323. Let me look up the status for you.\n\nOrderSupportAgent: I'm sorry, but I couldn't find order 34564323 in our system. Please double-check your order ID or contact customer service if you believe this is an error.\n</code></pre> Output (known order id) <pre><code>&gt; playbooks run examples/tutorials/04.01/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/04.01/order_assistant.pb']\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you with any questions about your orders. I can look up order status and provide information about your purchases. How can I assist you today?\n\nOrderSupportAgent: To get started, could you please provide your order ID? It should be an 8-digit number.\n\nUser: 29376452\n\nOrderSupportAgent: Thank you for providing your order ID 29376452. Let me look up the status for you.\n\nOrderSupportAgent: Great news! I found your order 29376452. The current status is 'Processing' and your expected delivery date is October 5th, 2025. Your order is being prepared and will be shipped soon!\n</code></pre> <p> Learn more: See Python Playbooks - Hard Logic for full details, decorator options, and when to extract Python playbooks to MCP servers.</p>"},{"location":"tutorials/#0402-python-markdown","title":"04.02 Python \u2192 Markdown","text":"<p>Let's add a Markdown playbook that summarizes the order status in a specific way, and call it from the <code>GetOrderStatus</code> playbook.</p> <p>examples/tutorials/04.02/order_assistant.pb</p> order_assistant.pb<pre><code> # Order Support Agent\n You are an agent that greets users and helps with order questions. Note that your capabilities are limited to the playbooks defined below.\n Whenever you are asking for some information from the user, you engage the user in a conversation if needed without being pushy and you will wait for appropriate place in conversation to remind the user.\n\n+## SummarizeOrderStatus($order_status)\n+### Steps\n+- If order was shipped\n+  - Return summary indicating expected_delivery_date and $1 store credit if the order gets delayed\n+- If order is processing\n+  - Return a summary apologizing that the order is not shipped yet and don't provide the expected delivery date unless user asked for it\n+\n ```python\n # In real life you'd query your DB or API here.\n _FAKE_ORDERS = {\n@@ -10,17 +17,17 @@ _FAKE_ORDERS = {\n }\n\n @playbook\n-async def GetOrderStatus(order_id: str) -&gt; dict:\n+async def GetOrderStatus(order_id: str) -&gt; str:\n   \"\"\"\n   Lookup an order's status by id.\n-  Returns a dict with order_id, status, expected_delivery_date.\n+  Returns a string describing order status.\n   \"\"\"\n\n   info = _FAKE_ORDERS.get(order_id.upper())\n   if not info:\n     # Return user-readable errors when called from markdown\n-    return {\"error\": f\"Order {order_id} was not found.\"}\n-  return info\n+    return f\"Order {order_id} was not found.\"\n+  return await SummarizeOrderStatus(info)\n ```\n\n ## Main\n</code></pre> <p>Changes:</p> <ul> <li>Lines 5-11: We added a Markdown playbook to summarize the order status.</li> <li>Line 33: We call the <code>SummarizeOrderStatus</code> playbook <code>GetOrderStatus</code> playbook.</li> </ul> Output (shipped order, $1 store credit) <pre><code>&gt; playbooks run examples/tutorials/04.02/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/04.02/order_assistant.pb']\n  Compiling agent: Order Support Agent\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you check on your order status. Just provide me with your order ID and I'll look up the current status for you.\n\nUser: 43345678\n\nOrderSupportAgent: Thank you for providing your order ID 43345678!\n\nOrderSupportAgent: Great news! Your order 43345678 has been shipped and is expected to be delivered on 2025-10-02. If your order gets delayed, you'll receive $1 store credit as compensation.\n</code></pre> Output (processing order) <pre><code>&gt; playbooks run examples/tutorials/04.02/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/04.02/order_assistant.pb']\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you check on your order status. Just provide me with your order ID and I'll look up the current status for you.\n\nUser: 29376452\n\nOrderSupportAgent: Thank you for providing order ID 29376452. Let me look up the current status for you.\n\nOrderSupportAgent: I apologize, but your order is still being processed and hasn't shipped yet. We're working on getting it ready for you as soon as possible.\n</code></pre> Output (processing order, with expected delivery date) <pre><code>&gt; playbooks run examples/tutorials/04.02/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/04.02/order_assistant.pb']\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you check on your order status. Just provide me with your order ID and I'll look up the current status for you.\n\nUser: Here it is 29376452.. I am going on vacation soon so wondering if I get it before that.\n\nOrderSupportAgent: Thank you for providing order ID 29376452! Let me check the status for you right away.\n\nOrderSupportAgent: Your order #29376452 is currently being processed and hasn't shipped yet. However, I can see it has an expected delivery date of October 5th, 2025, so it should arrive well before your vacation! We're working on getting it ready for you as soon as possible.\n</code></pre>"},{"location":"tutorials/#0403-description-placeholders","title":"04.03 Description Placeholders","text":"<p>We want to check if a shipped order is overdue, but the LLM doesn't know today's date. We can inject dynamic information using description placeholders with <code>{expression}</code> syntax:</p> order_assistant.pb<pre><code>-  - Return summary indicating expected_delivery_date and $1 store credit if the order gets delayed\n+  - If order is overdue\n+    - Return summary with apologies for the delay and indicating that $1 store credit was added to user's account\n+  - Otherwise\n+    - Return summary indicating expected_delivery_date and $1 store credit if the order gets delayed\n</code></pre> <p>But, the LLM won't know about today's date so we need to inject that information in the LLM context. Let's use playbook description placeholder feature to add today's date in the description of the <code>SummarizeOrder</code> playbook.</p> order_assistant.pb<pre><code> ## SummarizeOrderStatus($order_status)\n+Summarize order status, taking into account today's date {date.today().strftime(\"%Y-%m-%d\")}\n</code></pre> <p>Placeholder expressions are evaluated when the playbook starts. They can access variables, call playbooks, and use Python expressions. Import any needed modules in a Python code block.</p> <p>examples/tutorials/04.03/order_assistant.pb</p> order_assistant.pb<pre><code> ## SummarizeOrderStatus($order_status)\n+Summarize order status, taking into account today's date {date.today().strftime(\"%Y-%m-%d\")}\n+\n ### Steps\n - If order was shipped\n-  - Return summary indicating expected_delivery_date and $1 store credit if the order gets delayed\n+  - If order is overdue\n+    - Return summary with apologies for the delay and indicating that $1 store credit was added to user's account\n+  - Otherwise\n+    - Return summary indicating expected_delivery_date and $1 store credit if the order gets delayed\n - If order is processing\n   - Return a summary apologizing that the order is not shipped yet and don't provide the expected delivery date unless user asked for it\n\n ```python\n+from datetime import date\n+\n # In real life you'd query your DB or API here.\n _FAKE_ORDERS = {\n-  \"43345678\": {\"order_id\": \"43345678\", \"status\": \"Shipped\", \"expected_delivery_date\": \"2025-10-02\"},\n+  \"43345678\": {\"order_id\": \"43345678\", \"status\": \"Shipped\", \"expected_delivery_date\": \"2025-08-02\"},\n   \"29376452\": {\"order_id\": \"29376452\", \"status\": \"Processing\", \"expected_delivery_date\": \"2025-10-05\"},\n }\n```\n</code></pre> <p>Changes:</p> <ul> <li>Line 2: Added a description with a placeholder for today's date.</li> <li>Line 7: Updated the expected delivery date for the shipped order to be 2025-08-02 to trigger the overdue behavior.</li> </ul> Output <pre><code>&gt; playbooks run examples/tutorials/04.03/order_assistant.pb\n\u2139 Loading playbooks from: ['examples/tutorials/04.03/order_assistant.pb']\n  Compiling agent: Order Support Agent\n\nOrderSupportAgent: Hello! I'm your Order Support Agent. I'm here to help you check on your order status. Just provide me with your order ID and I'll look up the current status for you.\n\nUser: 43345678\n\nOrderSupportAgent: Thank you for providing order ID 43345678. Let me look up your order status right away.\n\nOrderSupportAgent: I apologize for the significant delay with your order 43345678. Your order was shipped but should have been delivered by August 2nd, 2025. Due to this delay, we've added $1 store credit to your account as compensation for the inconvenience.\n</code></pre> <p> Learn more: See Programming Guide for advanced patterns and best practices.</p>"},{"location":"tutorials/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've built a working order assistant that:</p> <ul> <li>\u2705 Greets users and collects input conversationally</li> <li>\u2705 Validates input automatically with triggers</li> <li>\u2705 Mixes Python and Markdown playbooks seamlessly</li> <li>\u2705 Injects dynamic context with placeholders</li> </ul> <p>Continue Learning:</p> <ul> <li>Programming Guide - Comprehensive reference covering all features</li> <li>Multi-Agent Programs - Multiple agents, meetings, cross-agent calls</li> <li>ReAct Playbooks - Dynamic planning when steps aren't predetermined</li> <li>Raw Playbooks - Full prompt control for single-shot tasks</li> <li>Common Patterns - Best practices and real-world patterns</li> </ul> <p>Reference Documentation:</p> <ul> <li>Agents - Agent configuration and structure</li> <li>MCP Agents - Integrating external tools via MCP</li> <li>Triggers - Event-driven programming details</li> <li>Playbook Types - Deep dive on all playbook types</li> </ul> <p>Ready to build? Start with the Programming Guide and explore the examples in the Playbooks repository.</p>"}]}